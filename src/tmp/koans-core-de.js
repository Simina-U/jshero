if(typeof jshero==="undefined"){var jshero={}}jshero.koans=function(){var koans=[];var koansMap={};var add=function(koan){koans.push(koan);koansMap[koan.id]=koan};var getById=function(koanId){return koansMap[koanId]};var initReorder=function(order){if(order.length!==koans.length){console.log("ERROR: Koans-Order-Array length unequal to Koans length!")}var koan;koans=[];for(var i=0,l=order.length;i<l;i++){koan=koansMap[order[i]];if(koan!=null){koans.push(koan)}else{throw"ERROR: No koan for koan-Id ".concat(order[i]," in koansMap!")}}};var getKoans=function(){return koans};return{add:add,initReorder:initReorder,getKoans:getKoans,getById:getById}}();if(typeof module!=="undefined"){module.exports=jshero.koans}
jshero.koans.add({id:"arguments",title:"Das arguments-Objekt",lesson:"Das <code>arguments</code>-Objekt ist eine in jeder Funktion verf\xFCgbare Variable.\nEs ist ein Array \xE4hnliches Objekt, das die \xFCbergebenen Argumente einer Funktion der Reihe nach enth\xE4lt.\n\n<pre><code>var add = function() {\n  var arg0 = arguments[0];\n  var arg1 = arguments[1];\n  return arg0 + arg1;\n};\n\nvar sum = add(1, 2);</code></pre>\n\nHier wird <code>add</code> mit den Argumenten <code>1</code> und <code>2</code> aufgerufen.\n<code>arguments[0]</code> enth\xE4lt also den Wert <code>1</code>, <code>arguments[1]</code> den Wert <code>2</code>.\nMit dem <code>arguments</code>-Objekt kann man ohne Parameter auf die \xFCbergebenen Argumente zugreifen.\nDas ist z.B. dann praktisch, wenn man eine Funktion schreiben m\xF6chte, die eine beliebige Anzahl von Argumenten\nverarbeiten soll.\n\n<pre><code>var add = function() {\n  var sum = 0;\n  for (var i = 0; i < arguments.length; i++) {\n    sum = sum + arguments[i];\n  }\n  return sum;\n};\n\nvar s1 = add(2, 4);\nvar s2 = add(2, 3, 5, 7);</code></pre>\n\nHier iterieren wir \xFCber alle \xFCbergebenen Argumente und summieren sie auf.\n<code>arguments.length</code> liefert dabei die Anzahl der \xFCbergebenen Argumente.\nNun k\xF6nnen wir <code>add</code> mit einer beliebigen Anzahl von Argumenten aufrufen.",task:"Schreibe eine Funktion <code>maximum</code>, die beliebig viele Zahlen entgegennimmt und das Maximum dieser\nZahlen liefert. <code>maximum(12, 68, 3, 52)</code> sollte <code>68</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("maximum")},function(){return jshero.testutil.assert_functionReturns("maximum(1)",1)},function(){return jshero.testutil.assert_functionReturns("maximum(15, 2)",15)},function(){return jshero.testutil.assert_functionReturns("maximum(1, 15, 3)",15)},function(){return jshero.testutil.assert_functionReturns("maximum(-1, 0, 9, 8)",9)}]});
(function(testutil){jshero.koans.add({id:"array",title:"Arrays anlegen",lesson:"Arrays sind Objekte zur Speicherung vieler, meist \xE4hnlicher Werte. Diese sogenannten Elemente werden\nin einem Array der Reihe nach abgelegt. Arrays erzeugt man am besten mit eckigen Klammern.\n\n<pre><code>var sprachen = ['C', 'C++', 'Java', 'JavaScript'];\nvar primzahlen = [2, 3, 5, 7, 11];\nvar leeresArray = [];\nvar a = 'Douglas';\nvar b = 12;\nvar c = true;\nvar allesMoegliche = [a, b, c];</code></pre>\n\nDie Elemente eines Arrays k\xF6nnen, wie das letzte Beispiel zeigt, alle einen anderen Datentyp besitzen.",task:"Schreibe eine Funktion <code>toArray</code>, die 2 Paramter entgegennimmt und diese als Array zur\xFCckgibt.\n<br><br>Beispiel: <code>toArray(5, 9)</code> sollte das Array <code>[5, 9]</code> ergeben.",hint:"<pre><code>var toArray = function(a, b) {\n  return [...];\n};</code></pre>",solution:"<pre><code>var toArray = function(a, b) {\n  return [a, b];\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("toArray")},function(){return testutil.assert_functionHasNumOfParameter("toArray",2)},function(){return testutil.assert_functionReturnsType("toArray(1, 2)","Array")},function(){return testutil.assert_functionReturns("toArray(1, 2)",[1,2])},function(){return testutil.assert_functionReturns("toArray('H\xE4nsel', 'Gretel')",["H\xE4nsel","Gretel"])},function(){return testutil.assert_functionReturns("toArray(1, 'Maus')",[1,"Maus"])}]})})(jshero.testutil);
jshero.koans.add({id:"array2",title:"Array-Elemente lesen",lesson:"Die Elemente eines Arrays werden mit einem Index beginnend mit 0 ausgelesen.\n\n<pre><code>var sprachen = ['C', 'C++', 'Java', 'JavaScript'];\nvar c = sprachen[0];\nvar cPlusPlus = sprachen[1];\nvar java = sprachen[2];\nvar javaScript = sprachen[3];</code></pre>",task:"Schreibe eine Funktion <code>getFirstElement</code>, die ein Array entgegennimmt und die das erste Element des\nArrays zur\xFCckgibt.<br><br>Beispiel: <code>getFirstElement([1, 2])</code> sollte <code>1</code> zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("getFirstElement")},function(){return jshero.testutil.assert_functionHasNumOfParameter("getFirstElement",1)},function(){return jshero.testutil.assert_functionReturns("getFirstElement([1, 2])",1)},function(){return jshero.testutil.assert_functionReturns("getFirstElement(['H\xE4nsel', 'Gretel'])","H\xE4nsel")},function(){return jshero.testutil.assert_functionReturns("getFirstElement(['Maus', 1])","Maus")}]});
jshero.koans.add({id:"array3",title:"Array-Elemente schreiben",lesson:"Ebenso wie man Array-Elemente \xFCber einen Index auslesen kann, kann man sie \xFCber diesen Index setzen.\nDabei spielt es keine Rolle, ob das Array vorher gef\xFCllt oder leer war.\n\n<pre><code>var sprachen = [];\nsprachen[0] = 'C';\nsprachen[1] = 'C++';\nsprachen[2] = 'Java';\nsprachen[3] = 'JavaScript';</code></pre>\n\nHier wird ein leeres Array nacheinander mit den aufgef\xFChrten Werten gef\xFCllt.",task:"Schreibe eine Funktion <code>setFirstElement</code>, die ein Array und einen beliebigen Wert entgegennimmt.\nDer Wert soll als erstes Element in das Array geschrieben werden. Das Array soll dann zur\xFCckgegeben werden.<br><br>\nBeispiel: <code>setFirstElement([1, 2], 3)</code> sollte <code>[3, 2]</code> zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("setFirstElement")},function(){return jshero.testutil.assert_functionHasNumOfParameter("setFirstElement",2)},function(){return jshero.testutil.assert_functionReturns("setFirstElement([1, 2], 3)",[3,2])},function(){return jshero.testutil.assert_functionReturns("setFirstElement(['Hein', 'Gretel'], 'H\xE4nsel')",["H\xE4nsel","Gretel"])},function(){return jshero.testutil.assert_functionReturns("setFirstElement([1, 'Maus'], 'kleine')",["kleine","Maus"])}]});
jshero.koans.add({id:"arrayindexof",title:"Array: indexOf()",lesson:"Mit der <code>indexOf</code> Methode kann man die Positions des \xFCbergebenen Elements innerhalb eines\nArrays bestimmen. Die Z\xE4hlung beginnt mit 0:\n\n<pre><code>var systems = ['Debian', 'Ubuntu', 'Mint'];\nvar i1 = systems.indexOf('Mint');\nvar i2 = systems.indexOf('Windows');</code></pre>\n\n<code>i1</code> erh\xE4lt den Wert <code>2</code>, da <code>'Mint'</code> das 2te Element in\n<code>systems</code> ist. <code>i2</code> erh\xE4lt den Wert <code>-1</code>.\nDieser Wert wird zur\xFCckgegeben, wenn sich das \xFCbergebene Element nicht im Array befindet.",task:"Schreibe eine Funktion <code>add</code>, die ein Element an das Ende eines Arrays h\xE4ngt.\nDas Element soll aber nur dann angeh\xE4ngt werden, wenn es sich nicht schon im Array befindet.<br><br>Beispiel:\n<code>add([1, 2], 3)</code> sollte <code>[1, 2, 3]</code> und <code>add([1, 2], 2)</code> sollte\n<code>[1, 2]</code> zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("add")},function(){return jshero.testutil.assert_functionHasNumOfParameter("add",2)},function(){return jshero.testutil.assert_functionReturns("add(['J'], 'S')",["J","S"])},function(){return jshero.testutil.assert_functionReturns("add(['J'], 'J')",["J"])},function(){return jshero.testutil.assert_functionReturns("add([1, 2], 3)",[1,2,3])},function(){return jshero.testutil.assert_functionReturns("add([1, 2], 2)",[1,2])}]});
(function(){var random=function(){return Math.round(Math.random()*10)};jshero.koans.add({id:"arraylength",title:"Array: length",lesson:"Die Eigenschaft <code>length</code> hatten wird schon bei Strings kennengelernt. Dort gab sie die Anzahl\nder Zeichen eines Strings zur\xFCck. Bei Arrays gibt sie die Anzahl der Elemente zur\xFCck.\n\n<pre><code>var sprachen = [];\nvar l0 = sprachen.length;\nsprachen[0] = 'C';\nvar l1 = sprachen.length;\nsprachen[1] = 'C++';\nvar l2 = sprachen.length;</code></pre>\n\nDas leere Array zu Anfang enth\xE4lt keine Elemente. <code>l0</code> ist also <code>0</code>.\nNun f\xFCllen wir das Array nach und nach. <code>l1</code> und <code>l2</code> haben dann die Werte <code>1</code> und <code>2</code>.\nBeachte: Die L\xE4nge eines Arrays ist immer um 1 gr\xF6\xDFer als der h\xF6chste Index des Arrays.",task:"Schreibe eine Funktion <code>getLastElement</code>, die ein Array entgegennimmt und die das letzte Element\ndes Arrays zur\xFCckgibt.<br><br>Beispiel: <code>getLastElement([1, 2])</code> sollte <code>2</code> zur\xFCckgeben.",hint:"Bestimme den Index des letzten Elements mit der Array-Eigenschaft <code>length</code>.\nBeachte, dass das erste Element im Array den Index <code>0</code> besitzt.",solution:"<pre><code>var getLastElement = function(anArray) {\n  var lastIndex = anArray.length - 1;\n  return anArray[lastIndex];\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("getLastElement")},function(){return jshero.testutil.assert_functionHasNumOfParameter("getLastElement",1)},function(){return jshero.testutil.assert_functionReturns("getLastElement([1, 2])",2)},function(){return jshero.testutil.assert_functionReturns("getLastElement(['H\xE4nsel', 'Gretel'])","Gretel")},function(){return jshero.testutil.assert_functionReturns("getLastElement(['a', 'b', 'c'])","c")},function(){return jshero.testutil.assert_functionReturns("getLastElement(['Maus', 1])",1)},function(){var testArray=new Array;var testArrayString="[";var size=4;for(var i=0;i<size-1;i++){testArray[i]=random();testArrayString+=testArray[i]+", "}testArray[size-1]=random();testArrayString+=testArray[size-1]+"]";return jshero.testutil.assert_functionReturns("getLastElement("+testArrayString+")",testArray[size-1])}]})})();
(function(testutil){jshero.koans.add({id:"arraypush",title:"Array: shift() und push()",lesson:"Arrays besitzen eine Reihe von Methoden. Zwei dieser Methoden sind <code>shift</code> und <code>push</code>.\nZur Erinnerung: Methoden sind Funktionen, die auf einem Objekt, hier einem Array, ausgef\xFChrt werden. Methoden werden mit einem Punkt\nan das Objekt angeh\xE4ngt. Wie bei Funktionen \xFCblich folgt dem Methodennamen die runden Klammern, ggf. gef\xFCllt mit Parametern.\n<code>shift</code> hat keine Parameter und verschiebt die Elemente eines Arrays nach links.\nDas 1te Element wird zum 0ten, das 2te zum 1ten, das 3te zum 2ten, usw.\nDas 0te Element wird aus dem Array entfernt und zur\xFCckgegeben. Nach dem <code>shift</code> hat das Array ein Element weniger.\n\n<pre><code>var sprachen = ['C', 'Java', 'JavaScript'];\nvar naechsteSprache = sprachen.shift();</code></pre>\n\nDas Array <code>sprachen</code> wird mit 3 Programmiersprachen angelegt.\nNach dem <code>shift</code> enth\xE4lt <code>sprachen</code> nur noch 2 Elemente,\nn\xE4mlich <code>['Java', 'JavaScript']</code>. Der Wert <code>'C'</code> ist in der Variablen\n<code>naechsteSprache</code> gelandet.<br>\nMit der h\xE4ufig verwendeten Methode <code>push</code> f\xFCgt man dem Array ein neues Element hinzu.\nDas neue Element wird als Parameter \xFCbergeben und an das Ende des Arrays geh\xE4ngt.\n\n<pre><code>var sprachen = [];\nsprachen.push('C');\nsprachen.push('Java');\nsprachen.push('JavaScript');</code></pre>\n\nHier wird ein leeres Array nacheinander mit den aufgef\xFChrten Werten gef\xFCllt. Am Ende erhalten wir das Array\n<code>['C', 'Java', 'JavaScript']</code>. Wir hatten gesehen, dass man ein Array auch per Index f\xFCllen kann.\n<code>sprachen[sprachen.length] = 'PHP'</code> ist dasselbe wie <code>sprachen.push('PHP')</code>. Doch schon\nan der L\xE4nge des Codes sieht man, dass die Variante mit <code>push</code> eleganter ist.",task:"Schreibe eine Funktion <code>rotiere</code>, die die Elemente eines Arrays rotiert.\nAlle Elemente des Arrays sollen um eine Position nach links verschoben werden.\nDas 0te Element soll ans Ende des Arrays gestellt werden. Das rotierte Array soll zur\xFCckgegeben werden.<br><br>Beispiel:\n<code>rotiere(['a', 'b', 'c'])</code> sollte <code>['b', 'c', 'a']</code> ergeben.",hint:"<pre><code>Entferne mit shift das 0te Element.\nF\xFCge mit push das 0te Element wieder hinzu.\n</code></pre>",solution:"<pre><code>var rotiere = function(einArray) {\n  var element0 = einArray.shift();\n  einArray.push(element0);\n  return einArray;\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("rotiere")},function(){return testutil.assert_functionHasNumOfParameter("rotiere",1)},function(){return testutil.assert_functionReturns("rotiere([1, 2])",[2,1])},function(){return testutil.assert_functionReturns("rotiere(['a', 'b', 'c'])",["b","c","a"])},function(){return testutil.assert_functionReturns("rotiere([1, 'b', 'c', 37])",["b","c",37,1])}]})})(jshero.testutil);
jshero.koans.add({id:"arraysort",title:"Arrays sortieren",lesson:"Jetzt k\xF6nnen wir Arrays mit vorgegebener L\xE4nge sortieren.",task:"Schreibe eine Funktion <code>sortiere</code>, die ein mit 3 beliebigen Zahlen gef\xFClltes Array entgegennimmt\nund die diese 3 Zahlen aufsteigend sortiert als Array  zur\xFCckgibt.<br><br>Beispiel:\n<code>sortiere([2,&nbsp;3,&nbsp;1])</code> sollte <code>[1,&nbsp;2,&nbsp;3]</code> und\n<code>sortiere([11,&nbsp;-1,&nbsp;4])</code> sollte <code>[-1,&nbsp;4,&nbsp;11]</code>ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("sortiere")},function(){return jshero.testutil.assert_functionHasNumOfParameter("sortiere",1)},function(){return jshero.testutil.assert_functionReturns("sortiere([1, 2, 3])",[1,2,3])},function(){return jshero.testutil.assert_functionReturns("sortiere([1, 3, 2])",[1,2,3])},function(){return jshero.testutil.assert_functionReturns("sortiere([2, 1, 3])",[1,2,3])},function(){return jshero.testutil.assert_functionReturns("sortiere([2, 3, 1])",[1,2,3])},function(){return jshero.testutil.assert_functionReturns("sortiere([3, 1, 2])",[1,2,3])},function(){return jshero.testutil.assert_functionReturns("sortiere([3, 2, 1])",[1,2,3])}]});
jshero.koans.add({id:"bool",title:"Wahrheitswerte",lesson:"Der dritte wichtige Datentyp neben Strings und Zahlen sind Wahrheitswerte. Sie werden auch boolesche Werte\ngenannt. Boolesche Werte kennen nur zwei Zust\xE4nde: <code>true</code> und <code>false</code>. Mit booleschen Werten kann\nman \xE4hnlich \"rechnen\" wie mit Zahlen. JavaScript kennt drei boolesche Operatoren: '<code>&&</code> (und),\n<code>||</code> (oder) und <code>!</code> (nicht). Das Ergebnis dieser Operationen ist wieder ein boolescher Wert.\n<code>&&</code> verkn\xFCpft zwei boolesche Werte. Sind beide Werte <code>true</code>, ist das Ergebnis auch\n<code>true</code>. In allen anderen F\xE4llen ist es <code>false</code>. Bei <code>||</code> ist das Ergebnis\n<code>false</code>, wenn beide Eingangswerte auch <code>false</code> sind. In  allen anderen F\xE4llen ist das Ergebnis\n<code>true</code>. <code>!</code> wird nur auf einen booleschen Wert angewendet und invertiert diesen Wert: aus\n<code>true</code> wird <code>false</code> und aus <code>false</code> wird <code>true</code>.\n\n<pre><code>var x1 = true && false;\nvar x2 = !x1;\nvar x3 = x1 || x2;</code></pre>\n\n<code>x1</code> ist <code>false</code>,  <code>x2</code> ist <code>true</code> und <code>x3</code> ist ebenfalls\n<code>true</code>.",task:"Schreibe eine Funktion <code>nand</code>, die zwei boolesche Werte als Parameter entgegennimmt. Die R\xFCckgabe\nder Funktion soll <code>false</code> sein, wenn beide Paramter <code>true</code> sind. In den anderen F\xE4llen soll die\nR\xFCckgabe <code>true</code> sein.<br><br>D.h.: <code>nand(true, true)</code> soll <code>false</code> liefern,\n<code>nand(true, false)</code>, <code>nand(false, true)</code> und <code>nand(false, false)</code> sollen\n<code>true</code> zur\xFCckgeben.",hint:"<pre><code>var nand = function(a, b) {\n  var and = a && b;\n  ...\n};</code></pre>",solution:"<pre><code>var nand = function(a, b) {\n  var and = a && b;\n  return !and;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("nand")},function(){return jshero.testutil.assert_functionHasNumOfParameter("nand",2)},function(){return jshero.testutil.assert_functionReturns("nand(true, true)",false)},function(){return jshero.testutil.assert_functionReturns("nand(true, false)",true)},function(){return jshero.testutil.assert_functionReturns("nand(false, true)",true)},function(){return jshero.testutil.assert_functionReturns("nand(false, false)",true)}]});
jshero.koans.add({id:"break",title:"break und continue",lesson:"Mit <code>break</code> wird eine Schleife beendet. Das Programm wird nach der Schleife fortgesetzt.\n\n<pre><code>var words = 'blau wei\xDF rot';\nvar indexFirstSpace = -1;\nfor (var i = 0; i < words.length; i++) {\n  if (words.charAt(i) === ' ') {\n    indexFirstSpace = i;\n    break;\n  }\n}</code></pre>\n\nIst das Zeichen mit dem Index <code>i</code> in <code>words</code> das Leerzeichen, so ist die\n<code>if</code>-Bedingung erf\xFCllt. <code>indexFirstSpace</code> bekommt den Laufindex <code>i</code> zugewisen\nund der <code>break</code>-Befehl wird ausgef\xFChrt. Die Schleife wird beendet.\nDie Codeausf\xFChrung wird nach der Schleife fortgesetzt. In unserem Beispiel ist das Zeichen mit dem Index <code>4</code>\ndas Leerzeichen. Sobald die Schleifenvariable <code>i</code> den Wert <code>4</code> erreicht hat,\nbekommt <code>indexFirstSpace</code> den Wert <code>4</code> zugewiesen und die Schleife wird beendet.<br><br>\n\nMit <code>continue</code> wird der aktuelle Schleifendurchlauf beendet. Die Programmausf\xFChrung springt zum Schleifenkopf.\n\n<pre><code>var sum = 0;\nfor (var i = 0; i < 10; i++) {\n  if (i % 2 === 0) {\n    continue;\n  }\n  sum = sum + i;\n}</code></pre>\n\nIst <code>i</code> eine ungerade Zahl, so gilt: i modulo 2 = 1. Die <code>if</code> - Bedingung ist nicht erf\xFCllt.\nDie Codeausf\xFChrung wird nach dem <code>if</code> fortgesetzt und <code>i</code> wird zu <code>sum</code> hinzugez\xE4hlt.\nIst <code>i</code> eine gerade Zahl, so gilt: i modulo 2 = 0. Die <code>if</code> - Bedingung ist erf\xFCllt und\n<code>continue</code> wird ausgef\xFChrt. Die Code-Ausf\xFChrung springt direkt zum Schleifenkopf. <code>i</code> wird nicht\nzu <code>sum</code> hinzugez\xE4hlt. So werden alle ungeraden Zahlen kleiner 10 aufaddiert.<br><br>\n<code>break</code> und <code>continue</code> kann man in allen Schleifen (for, while, do...while) verwenden.",task:"Schreibe eine Funktion <code>isPrime</code>. Sie soll pr\xFCfen, ob eine \xFCbergebene Zahl eine Primzahl ist oder\nnicht. Ist die Zahl prim, so soll <code>true</code> zur\xFCckgegeben werden, im anderen Fall <code>false</code>.\nDer Aufruf <code>isPrime(2)</code> soll <code>true</code> zur\xFCckgeben, <code>isPrime(4)</code> soll <code>false</code>\nergeben. Eine Primzahl ist eine nat\xFCrliche Zahl, die gr\xF6\xDFer als 1 und nur durch sich selbst und durch 1 teilbar ist.",tests:[function(){return jshero.testutil.assert_isFunction("isPrime")},function(){return jshero.testutil.assert_functionHasNumOfParameter("isPrime",1)},function(){return jshero.testutil.assert_functionReturns("isPrime(1)",false)},function(){return jshero.testutil.assert_functionReturns("isPrime(2)",true)},function(){return jshero.testutil.assert_functionReturns("isPrime(3)",true)},function(){return jshero.testutil.assert_functionReturns("isPrime(4)",false)},function(){return jshero.testutil.assert_functionReturns("isPrime(11)",true)},function(){return jshero.testutil.assert_functionReturns("isPrime(281)",true)},function(){return jshero.testutil.assert_functionReturns("isPrime(351)",false)}]});
(function(ArrayUtil){jshero.koans.add({id:"bubblesort",title:"Bubblesort",lesson:"H\xE4ufig m\xF6chte man Daten der Gr\xF6\xDFe nach sortieren. Hierf\xFCr gibt es verschiedene Sortierverfahren. Ein bekanntes,\neinfaches, aber auch langsames Verfahren ist <a href=\"https://de.wikipedia.org/wiki/Bubblesort\">Bubblesort</a>.\nLiegen die zu sortierenden Daten in einem Array der L\xE4nge n vor und sollen die Daten aufsteigend sortiert werden,\nso wird in einer sogenannten Bubble-Phase das Array vom 1 &apos;ten bis zum n-1 &apos;ten Element durchlaufen.\nDabei wird in jedem Schritt das aktuelle Element an der Stelle i mit dem nachfolgenden Element an der Stelle i+1 verglichen.\nIst das Element an der Stelle i gr\xF6\xDFer als das Element an der Stelle i+1, so vertauscht man beide Elemente.\nHat man so eine Bubble-Phase durchlaufen, ist das gr\xF6\xDFte Element am Ende des Arrays angekommen.\nWiederholt man nun eine Bubble-Phase, so steht auch das zweitgr\xF6\xDFte Element an der richtigen Stelle.\nHat man n-1 Bubble-Phasen durchlaufen, ist das komplette Array sortiert.\nUm ein Array mit 4 Zahlen zu sortieren, ben\xF6tigt man also drei Bubble-Phasen:\n\n<pre><code>Erste Bubble-Phase:\n[4, 2, 3, 1] -> [2, 4, 3, 1] Das erste Element wird mit dem zweiten verglichen. Sie werden vertauscht, da 4>2 ist.\n[2, 4, 3, 1] -> [2, 3, 4, 1] Das zweite Element wird mit dem dritten verglichen. Sie werden vertauscht, da 4>3 ist.\n[2, 3, 4, 1] -> [2, 3, 1, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden vertauscht, da 4>1 ist.\nDas gr\xF6\xDFte Element ist an die richtige Stelle geblubbert.\n\nZweite Bubble-Phase:\n[2, 3, 1, 4] -> [2, 3, 1, 4] Das erste Element wird mit dem zweiten verglichen. Sie werden nicht vertauscht, da 2<3 ist.\n[2, 3, 1, 4] -> [2, 1, 3, 4] Das zweite Element wird mit dem dritten verglichen. Sie werden vertauscht, da 3>1 ist.\n[2, 1, 3, 4] -> [2, 1, 3, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden nicht vertauscht, da 3<4 ist.\nDas zweitgr\xF6\xDFte Element ist an die richtige Stelle geblubbert.\n\nDritte Bubble-Phase:\n[2, 1, 3, 4] -> [1, 2, 3, 4] Das erste Element wird mit dem zweiten verglichen. Sie werden vertauscht, da 2>1 ist.\n[1, 2, 3, 4] -> [1, 2, 3, 4] Das zweite Element wird mit dem dritten verglichen. Sie werden nicht vertauscht, da 2<3 ist.\n[1, 2, 3, 4] -> [1, 2, 3, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden vertauscht, da 3<4 ist.\nDas drittgr\xF6\xDFte Element ist an die richtige Stelle geblubbert.\nDamit ist automatisch auch das kleinste Element an der richtigen Stelle.\nDas Array ist aufsteigend sortiert.</code></pre>",task:"Schreibe eine Funktion <code>sort</code>, die ein mit Zahlen gef\xFClltes Array entgegennimmt und die diese Zahlen\naufsteigend sortiert als Array zur\xFCckgibt. Wird ein leeres Array \xFCbergeben, so soll auch ein leeres Array zur\xFCckgegeben\nwerden. <code>sort([4,&nbsp;2,&nbsp;3,&nbsp;1])</code> sollte <code>[1,&nbsp;2,&nbsp;3,&nbsp;4]</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("sort")},function(){return jshero.testutil.assert_functionHasNumOfParameter("sort",1)},function(){return jshero.testutil.assert_functionReturns("sort([])",[])},function(){return jshero.testutil.assert_functionReturns("sort([1])",[1])},function(){return jshero.testutil.assert_functionReturns("sort([3, 1])",[1,3])},function(){return jshero.testutil.assert_functionReturns("sort([3, 1, 2])",[1,2,3])},function(){return jshero.testutil.assert_functionReturns("sort([3, 2, 1])",[1,2,3])},function(){return jshero.testutil.assert_functionReturns("sort([5, 4, 3, 2, 1])",[1,2,3,4,5])},function(){return jshero.testutil.assert_functionReturns("sort(['c', 'a', 'b'])",["a","b","c"])}]})})(jshero.array);
jshero.koans.add({id:"comment",title:"Kommentare",lesson:"Neben dem eigentlichen Code kann man Kommentare schreiben. Kommentare dienen dazu, Programme zu erkl\xE4ren.\nSie helfen uns Menschen, Programme zu verstehen und zu verwenden.\nComputer, die Programme ausf\xFChren, ignorieren Kommentare. In JavaScript gibt zwei M\xF6glichkeiten, Kommentare zu schreiben:\nZeilen-Kommentare werden mit <code>//</code> eingeleitet und gelten immer bis zum Ende der Zeile.\nBlock-Kommentare werden mit <code>/*</code> eingeleitet und mit <code>*/</code> beendet.\nAlles dazwischen ist Kommentar. Hier ein paar Beispiele:\n<pre><code>// Das ist ein Zeilenkommentar.\n\n// Dieser Zeilenkommentar geht\n// \xFCber 2 Zeilen.\n\n/* Das ist ein Blockkommentar. */\n\n/* Dieser Blockkommentar geht\n\xFCber mehrere Zeilen. */\n\n/**\n * Auch dies ist ein Blockkommentar.\n * Die zus\xE4tzlichen Sterne zwischen\n * dem Beginn und dem Ende des\n * Blockkommentars dienen nur zur\n * Verzierung. So sieht ein l\xE4ngerer\n * Blockkommentar \xFCbersichtlicher aus.\n */</code></pre>\n\n Block-Kommentare schreibt man gerne \xFCber Funktionen, Zeilen-Kommentare in den Code-Fluss.\n\n <pre><code>/**\n * Pr\xFCft, ob eine String kein Zeichen\n * au\xDFer Leerzeichen enth\xE4lt.\n */\nvar isEmpty = function(string) {\n  // Die Methode trim() entfernt Leerzeichen\n  // am Anfang und am Ende einer Zeichenfolge.\n  var trimmedString = string.trim();\n  return trimmedString.length === 0;\n};</code></pre>\n\nDa Kommentare mit den hier verwendeten Tests nicht \xFCberpr\xFCfen werden k\xF6nnen, eine Aufgabe, bei der man vieles von dem bisher Gelernten anwenden muss.",task:"Schreibe eine Funktion <code>median</code>, die ein Array von aufsteigend sortierten Zahlen entgegennimmt und die den Median dieser Zahlen zur\xFCckgibt.\n<code>median([1, 2, 10])</code> sollte <code>2</code> ergeben; <code>median([1, 2, 10, 100])</code> sollte <code>6</code> ergeben.\nDer Median einer sortierten Zahlenreihe ist der Wert, der an der mittleren Stelle steht. Ist die Anzahl der Werte gerade, so ist der Median der Mittelwert\nder beiden mittleren Zahlen.",tests:[function(){return jshero.testutil.assert_isFunction("median")},function(){return jshero.testutil.assert_functionHasNumOfParameter("median",1)},function(){return jshero.testutil.assert_functionReturns("median([1])",1)},function(){return jshero.testutil.assert_functionReturns("median([1, 2])",1.5)},function(){return jshero.testutil.assert_functionReturns("median([1, 2, 10])",2)},function(){return jshero.testutil.assert_functionReturns("median([1, 1, 2, 10, 100, 101])",6)}]});
jshero.koans.add({id:"concat",title:"Array: concat()",lesson:"Mit der <code>concat</code> Methode kann man zwei Arrays aneinanderh\xE4ngen:\n\n<pre><code>var a1 = [1, 2, 3];\nvar a2 = [4, 5, 6];\nvar a3 = a1.concat(a2);</code></pre>\n\n<code>a3</code> enth\xE4lt das Array <code>[1, 2, 3, 4, 5, 6]</code>.\nWichtig ist, dass die beiden urspr\xFCnglichen Arrays <code>a1</code> und <code>a2</code> nicht ver\xE4ndert werden.",task:"Schreibe eine Funktion <code>concatUp</code>, die zwei Arrays zu einem zusammenf\xFChrt.\nDabei soll das l\xE4ngere Array an das k\xFCrzere Array angeh\xE4ngt werden. Sind beide Arrays gleich lang,\nso soll das zweite Array dem ersten Array angeh\xE4ngt werden.<br><br>Beispiel: <code>concatUp([5, 7], [6])</code> sollte\n<code>[6, 5, 7]</code> und <code>concatUp([5, 7], [6, 8])</code> sollte <code>[5, 7, 6, 8]</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("concatUp")},function(){return jshero.testutil.assert_functionHasNumOfParameter("concatUp",2)},function(){return jshero.testutil.assert_functionReturns("concatUp([5, 7], [6])",[6,5,7])},function(){return jshero.testutil.assert_functionReturns("concatUp(['x'], ['a', 'b'])",["x","a","b"])},function(){return jshero.testutil.assert_functionReturns("concatUp([5, 7], [6, 8])",[5,7,6,8])}]});
jshero.koans.add({id:"date",title:"Datum und Uhrzeit",lesson:"Um mit Datum und Uhrzeit zu arbeiten, verwendet man <code>Date</code>-Objekte. Ein <code>Date</code>-Objekt repr\xE4sentiert\neinen Zeitpunkt, also ein Datum zusammen mit einer Uhrzeit. Die Uhrzeit wird dabei auf die Millisekunde genau festgelegt.\nEin Date-Objekt erzeugt man mit <code>new Date()</code>. Es gibt 4 m\xF6gliche Aufrufe:\n\n<pre><code>// aktueller Zeitpunkt\nvar d1 = new Date();</code></pre>\n\nOhne Parameter erzeugt <code>new Date()</code> ein Date-Objekt, das dem Zeitpunkt seines Aufrufs entspricht. Wird obiges Beispiel\nam 1. Mai 2017 um 8:15 Uhr aufgerufen, so enth\xE4lt <code>d1</code> eben diesen Zeitpunkt.\n\n<pre><code>// Aufruf mit Jahr, Monat, Tag, Stunde,\n// Stunde, Minute, Sekunde, Millisekunde\nvar d2 = new Date(2017, 2, 8, 16, 31, 10, 117);</code></pre>\n\nM\xF6chte man ein Date-Objekt zu einem bestimmten Zeitpunkt erstellen, verwendet man am besten die zweite M\xF6glichkeit.\nHier \xFCbergibt man als Parameter das Jahr, den Monat, den Tag, die Stunde, die Minute, die Sekunde und die Millisekunde.\nDas Jahr muss in voller L\xE4nge \xFCbergeben werden. <code>17</code> ergibt das Jahr 17 n. Chr. und <code>2017</code> das Jahr 2017 n. Chr.\nBei dem Monat muss man aufpassen. JavaScript nummeriert die Monate von 0 (Januar) bis 11 (Dezember).\nAlle weiteren Zahlen entsprechen der \xFCblichen Bedeutung. <code>d2</code> repr\xE4sentiert also den\nZeitpunkt 8.3.2017, 16:31:10 Uhr und 117 Millisekunden.<br>\nDie Parameter Millisekunde, Sekunde, Minute, Stunde und Tag sind - in dieser Reihenfolge - optional. Man kann sie weglassen.\nGibt man sie nicht an, werden die Zeitangaben automatisch auf 0 gesetzt. Der Tag wird auf den Monatsersten gesetzt.\nDas ist besonders praktisch, wenn man nur mit einem Datum arbeiten m\xF6chte.\nDann l\xE4\xDFt man einfach alle Zeitangaben weg. <code>new&nbsp;Date(2017, 5, 2)</code> ist der 2.6.2017, 0:00 Uhr.\n\n<pre><code>// Millisekunden seit dem 1.1.1970\nvar d3 = new Date(86400000);</code></pre>\n\nBei der dritten Variante \xFCbergibt man die vergangenen Millisekunden seit dem 1.1.1970, 0:00 Uhr.\nDer Bezugspunkt 1.1.1970 f\xFCr Datumsangaben ist seit den Tagen von Unix und der Programmiersprache C in der IT \xFCblich geworden.\nEin Tag hat 24 * 60 * 60 * 1000 = 86400000 Millisekunden. <code>d3</code> ist also der 2.1.1970, 0:00 Uhr.\n\n<pre><code>// \xDCbergabe eines Datumsstrings\nvar d4 = new Date('2017-3-8T16:31:10.117');</code></pre>\n\nBei der vierten Variante wird ein Datumsstring in einem bestimmten Format, d.h. in einer bestimmten Schreibweise, \xFCbergeben.\n<code>d4</code> entspricht ebenfalls dem Zeitpunkt 8.3.2017, 16:31:10 Uhr und 117 Millisekunden. Diese Varainte ist jedoch nicht zu empfehlen,\nda verschiedene Browser leichte Unterschiede bei der Bestimmung des Datums aufweisen.",task:"Schreibe eine Funktion <code>nikolaus</code>, die eine Jahreangabe als Zahl entgegennimmt und die ein Date-Objekt mit dem 6. Dezember\ndes \xFCbergebenen Jahres, 0:00 Uhr, zur\xFCckgibt. <code>nikolaus(2017)</code> sollte ein Date-Objekt mit dem Zeitpunkt 6.12.2017, 0:00 Uhr zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("nikolaus")},function(){return jshero.testutil.assert_functionHasNumOfParameter("nikolaus",1)},function(){return jshero.testutil.assert_functionReturnsType("nikolaus(2017)","Date")},function(){return jshero.testutil.assert_functionReturns("nikolaus(2017)",new Date(2017,11,6))},function(){return jshero.testutil.assert_functionReturnsType("nikolaus(1960)","Date")},function(){return jshero.testutil.assert_functionReturns("nikolaus(1960)",new Date(1960,11,6))}]});
jshero.koans.add({id:"date2",title:"Datum und Uhrzeit ausgeben",lesson:"Zur Ausgabe der Daten eines Date-Objekts gibt es sieben sogenannte Getter-Methoden:\n\n<pre><code>var startFastnacht = new Date(2017, 10, 11, 11, 11);\nvar jahr = startFastnacht.getFullYear();\nvar monat = startFastnacht.getMonth();\nvar tag = startFastnacht.getDate();\nvar stunde = startFastnacht.getHours();\nvar minute = startFastnacht.getMinutes();\nvar sekunde = startFastnacht.getSeconds();\nvar millisekunde = startFastnacht.getMilliseconds();</code></pre>\n\nMan erh\xE4lt die erwarteten Werte: <code>2017</code> f\xFCr das Jahr, <code>10</code> f\xFCr den Monat,\n<code>11</code> f\xFCr den Tag, die Stunde und die Minute, sowie <code>0</code> f\xFCr die Sekunde und die Millisekunde.\nDie Monatsz\xE4hlung beginnt wie beim Erzeugen eines Date-Objektes mit <code>0</code>.\nDie Zahl <code>10</code> steht also f\xFCr den November.",task:"Schreibe eine Funktion <code>toGerman</code>, die ein Date-Objekt entgegennimmt und dessen Datum im Format 'd.M.YYYY' zur\xFCckgibt.\nMit <code>date = new Date(2017, 2, 8)</code> sollte <code>toGerman(date)</code> den String <code>'8.3.2017'</code> zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("toGerman")},function(){return jshero.testutil.assert_functionHasNumOfParameter("toGerman",1)},function(){return jshero.testutil.assert_functionReturns("toGerman(new Date(2017, 2, 8))","8.3.2017")},function(){return jshero.testutil.assert_functionReturns("toGerman(new Date(1724, 3, 22))","22.4.1724")}]});
jshero.koans.add({id:"date3",title:"Datum und Uhrzeit \xE4ndern",lesson:"Passend zu den sieben Getter-Methoden besitzt das Date-Objekt sieben Setter-Methoden:\n<code>setFullYear</code>, <code>setMounth</code>, <code>setDate</code>, <code>setHours</code>, <code>setMinutes</code>,\n<code>setSeconds</code> und <code>setMilliseconds</code>.\nMit diesen 7 Methoden kann man den entsprechenden Date-Eintrag setzen:\n\n<pre><code>var today = new Date();\ntoday.setHours(0);\ntoday.setMinutes(0);\ntoday.setSeconds(0);\ntoday.setMilliseconds(0);</code></pre>\n\n<code>today</code> enth\xE4lt zun\xE4chst den Zeitpunkt seiner Erstellung.\nAnschlie\xDFend wird mit den vier Setter-Aufrufen die Zeit auf 0:00:00.000 Uhr gesetzt.\nSo enth\xE4lt <code>today</code> das aktuelle Tagesdatum mit zur\xFCckgesetzter Uhrzeit.<br><br>\n\xDCberschreitet oder unterschreitet man bei einer dieser Methoden den zul\xE4ssigen Wertebereich,\ndann rechnen diese Methoden den \xDCber- oder Untertrag automatisch um:\n\n<pre><code>var someDay = new Date(2020, 3, 1);\nsomeDay.setDate(32);\nsomeDay.setDate(0);</code></pre>\n\nZun\xE4chst repr\xE4sentiert <code>someDay</code> den 1.4.2020. Nun wird der Tag auf den 32. gesetzt.\nDa der April 30 Tage hat, entspricht das dem 2.5.2020. Wird nun der Tag auf 0 gesetzt, erh\xE4lt man den 30.4.2020.",task:"Schreibe eine Funktion <code>yesterday</code>, die ein Date-Objekt entgegennimmt, dessen Datum um einen Tag zur\xFCcksetzt\nund dann dieses Date-Objekt zur\xFCckgibt. Die Uhrzeit soll dabei nicht ver\xE4ndert werden. Mit <code>date = new Date(1965, 8, 14)</code>\nsollte <code>yesterday(date)</code> ein Date-Objekt zur\xFCckgeben, das den 13.9.1965 repr\xE4sentiert.",tests:[function(){return jshero.testutil.assert_isFunction("yesterday")},function(){return jshero.testutil.assert_functionHasNumOfParameter("yesterday",1)},function(){return jshero.testutil.assert_functionReturnsType("yesterday(new Date(2015, 8, 14))","Date")},function(){return jshero.testutil.assert_functionReturns("yesterday(new Date(2015, 8, 14))",new Date(2015,8,13))},function(){return jshero.testutil.assert_functionReturnsType("yesterday(new Date(2018, 0, 1, 12))","Date")},function(){return jshero.testutil.assert_functionReturns("yesterday(new Date(2018, 0, 1, 12))",new Date(2017,11,31,12))}]});
(function(testutil){jshero.koans.add({id:"dimarray",title:"Mehrdimensionale Arrays",lesson:"Bisher haben wir in Arrays Zahlen, Strings und boolsche Werte gespeichert.\nMan kann aber auch Arrays in Arrays speichern.\n\n<pre><code>var teams = [\n  ['Ruby', 'Angel'],\n  ['Mia', 'Yui', 'Merve', 'Elif'],\n  ['Saanvi', 'Giulia', 'Zeynep']\n];\n\nvar zeile1 = [4, 9, 2];\nvar zeile2 = [3, 5, 7];\nvar zeile3 = [8, 1, 6];\nvar loshu = [zeile1, zeile2, zeile3];</code></pre>\n\nIm ersten Beispiel werden 3 Teams in einem Array gespeichert. Jedes Team ist wiederum ein Array aus Namen.\nDie einzelnen Teams sind verschieden gro\xDF. Mit <pre><code>var team = teams[0];</code></pre> greift man auf ein Team zu\nund mit <pre><code>var member = teams[0][0];</code></pre> kann man auf die einzelnen Teammitglieder zugreifen.<br><br>\nArrays, die Arrays enthalten, nennt man auch zweidimensionals Arrays. Treibt man dies weiter, erh\xE4lt man\ndrei- bzw. mehrdimensionale Arrays.<br><br>\nIm zweiten Beispiel wird das <a href='https://de.wikipedia.org/wiki/Magisches_Quadrat'>magische Quadrat</a> Lo-Shu in einem\nzweidimensionalen Array gespeichert.",task:"Schreibe eine Funktion <code>flat</code>, die ein zweidimensionales Array mit 3 Eintr\xE4gen in ein\neinfaches Array \xFCberf\xFChrt. <code>flat(loshu)</code> sollte <code>[4, 9, 2, 3, 5, 7, 8, 1, 6]</code> ergeben.\nDabei ist <code>loshu</code> das magische Quadrat aus dem obigen Beispiel.",tests:[function(){return testutil.assert_isFunction("flat")},function(){return testutil.assert_functionHasNumOfParameter("flat",1)},function(){return testutil.assert_functionReturns("flat([[], [], []])",[])},function(){return testutil.assert_functionReturns("flat([[1], [], []])",[1])},function(){return testutil.assert_functionReturns("flat([[1], [2], [3]])",[1,2,3])},function(){return testutil.assert_functionReturns("flat([[1, 2], [3, 4], [5, 6]])",[1,2,3,4,5,6])},function(){return testutil.assert_functionReturns("flat([['a'], ['b', 'c'], ['d', 'e', 'f']])",["a","b","c","d","e","f"])}]})})(jshero.testutil);
jshero.koans.add({id:"doubleloop",title:"Geschachtelte Schleifen",lesson:"Schleifen kann man auch ineinander schachteln. Im Falle einer for-Schleife muss man zwei verschiedene\nLaufindizes benutzen.\n\n<pre><code>var a = [[1, 7, 3], [2, 8, 5], [9, 0, 4]];\nvar sum = 0;\nfor (var i = 0; i < 3; i++) {\n  for (var j = 0; j < 3; j++) {\n    sum = sum + a[i][j];\n  }\n}</code></pre>\n\nIm Codeschnipsel wird die Summe aller Elemente eines zweidimensionalen Arrays berechnet.",task:"Schreibe eine Funktion <code>sum</code>, die die Summe aller Elemente eines zweidimensionalen,\nnumerischen Arrays berechnet. <code>sum([[1, 2], [3]])</code> sollte <code>6</code> zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("sum")},function(){return jshero.testutil.assert_functionHasNumOfParameter("sum",1)},function(){return jshero.testutil.assert_functionReturns("sum([[1]])",1)},function(){return jshero.testutil.assert_functionReturns("sum([[1, 2], [3]])",6)},function(){return jshero.testutil.assert_functionReturns("sum([[1, 2, 3], [1, 2], [1, 2, 3, 4]])",19)}]});
jshero.koans.add({id:"dowhile",title:"do...while-Schleife",lesson:"Die <code>do...while</code>-Schleife funktioniert \xE4hnlich wie die <code>while</code>-Schleife.\nDer Schleifen-Code wird ausgef\xFChrt, solange die Schleifenbedingung <code>true</code> ergibt.\nEinziger Unterschied ist, dass die Schleifenbedingung nach dem Schleifen-Code \xFCberpr\xFCft wird.\nDadurch ist sichergestellt, dass der Schleifen-Code mindestens einmal durchlaufen wird.\n\n<pre><code>var restDurch6;\nvar restDurch8;\nvar kgV = 0;\ndo {\n  kgV++;\n  restDurch6 = kgV % 6;\n  restDurch8 = kgV % 8;\n} while (restDurch6 !== 0 || restDurch8 !== 0);</code></pre>\n\nDieser Codeabschnitt berechnet das\n<a href='https://de.wikipedia.org/wiki/Kleinstes_gemeinsames_Vielfaches'>kleinste gemeinsame Vielfache (kgV)</a> von 6 und 8.\nDas kgV ist die kleinste Zahl, die sowohl ein Vielfaches von 6 als auch ein Vielfaches von 8 ist.\nDie Vielfachen von 6 sind 6, 12, 18, 24, 30, ... und die Vielfachen von 8 sind 8, 16, 24, 32, ... .\nDamit ist das kgV von 6 und 8 die Zahl 24.<br>\nUnser Codebeispiel pr\xFCft beginnend mit <code>1</code>, ob <code>kgV</code> sowohl durch <code>6</code> als auch durch <code>8</code> teilbar ist.\nDie Teilbarkeit wird mithilfe des Modulo-Operators \xFCberpr\xFCft. Eine Zahl ist durch 6 bzw. 8 teilbar,\nwenn sie Modulo 6 bzw. Modulo 8 den Wert 0 liefert. Die Modulo-Berechnung findet im Schleifen-Code statt.\nIn der Schleifenbedingung wird dann \xFCberpr\xFCft, ob beide Modulo-Berechnungen <code>0</code> ergeben. Ist eine von beiden\nModulo-Berechnungen nicht <code>0</code>, ist die Schleifenbedingung <code>true</code> und der Schleifen-Code wird mit einem um 1 erh\xF6hten <code>kgV</code>\nerneut durchlaufen. Ergeben beide Modulo-Berechnungen <code>0</code>, ist die Schleifenbedingung <code>false</code> und die Schleife wird beendet.\n<code>kgV</code> hat dann den gew\xFCnschten Wert (n\xE4mlich 24), da es die erste Zahl ist, die sowohl durch 6 als auch durch 8 teilbar ist.",task:"Schreibe eine Funktion <code>kgV</code>, die zwei nat\xFCrliche Zahlen als Parameter entgegennimmt und deren kgV berechnet.\n<code>kgV(6, 8)</code> sollte <code>24</code> zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("kgV")},function(){return jshero.testutil.assert_functionHasNumOfParameter("kgV",2)},function(){return jshero.testutil.assert_functionReturns("kgV(1, 1)",1)},function(){return jshero.testutil.assert_functionReturns("kgV(1, 2)",2)},function(){return jshero.testutil.assert_functionReturns("kgV(2, 3)",6)},function(){return jshero.testutil.assert_functionReturns("kgV(3, 2)",6)},function(){return jshero.testutil.assert_functionReturns("kgV(4, 6)",12)},function(){return jshero.testutil.assert_functionReturns("kgV(5, 7)",35)},function(){return jshero.testutil.assert_functionReturns("kgV(6, 8)",24)},function(){return jshero.testutil.assert_functionReturns("kgV(10, 20)",20)},function(){return jshero.testutil.assert_functionReturns("kgV(20, 10)",20)}]});
jshero.koans.add({id:"else",title:"if...else",lesson:"Soll ein Codeblock nur dann ausgef\xFChrt werden, wenn eine <code>if</code>-Bedingung\nnicht erf\xFCllt ist, verwendet man zus\xE4tzlich zum <code>if</code> ein <code>else</code> (engl.: sonst).\n\n<pre><code>var mitteilung;\nif (betrag > 1000) {\n  mitteilung = 'Keine Auszahlung m\xF6glich!';\n} else {\n  mitteilung = 'Der Betrag wird ausgezahlt!';\n}</code></pre>\n\nJe nachdem, ob <code>betrag</code> gr\xF6\xDFer oder kleiner <code>1000</code> ist, wird entweder der\n<code>if</code>-Zweig oder der <code>else</code>-Zweig ausgef\xFChrt.",task:"Schreibe eine Funktion <code>addiereMitZuschlag</code>, die zwei Betr\xE4ge mit Zuschlag addiert.\nF\xFCr jeden Betrag, der kleiner gleich <code>10</code> ist, betr\xE4gt der Zuschlag <code>1</code>.\nF\xFCr jeden Betrag, der gr\xF6\xDFer <code>10</code> ist, betr\xE4gt der Zuschlag <code>2</code>.<br><br>Beispiel:\nDer Aufruf <code>addiereMitZuschlag(5, 15)</code> sollte <code>23</code> ergeben.",hint:"<pre><code>var addiereMitZuschlag = function(a, b) {\n\n  var zuschlag = 0;\n  \n  if (a <= 10) {\n    zuschlag = zuschlag + 1;\n  } else ...\n  \n  ...\n\n  return a + b + zuschlag;\n};</code></pre>",solution:"<pre><code>var addiereMitZuschlag = function(a, b) {\n\n  var zuschlag = 0;\n  \n  if (a <= 10) {\n    zuschlag = zuschlag + 1;\n  } else {\n    zuschlag = zuschlag + 2;\n  }\n  \n  if (b <= 10) {\n    zuschlag = zuschlag + 1;\n  } else {\n    zuschlag = zuschlag + 2;\n  }\n  \n  return a + b + zuschlag;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("addiereMitZuschlag")},function(){return jshero.testutil.assert_functionHasNumOfParameter("addiereMitZuschlag",2)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(1, 1)",4)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(10, 10)",22)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(11, 10)",24)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(10, 11)",24)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(11, 11)",26)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(15, 27)",46)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(5, 25)",33)}]});
jshero.koans.add({id:"elseif",title:"else if",lesson:"M\xF6chte man mehrere F\xE4lle unterscheiden, kann man ein <code>if</code> mit beliebig vielen <code>else if</code>\nerg\xE4nzen. Zum Schluss kann bei Bedarf noch ein einzelnes <code>else</code> stehen.\n\n<pre><code>var mitteilung;\nif (betrag > 1000) {\n  mitteilung = 'Zu gro\xDF. Keine Auszahlung m\xF6glich!';\n} else if (betrag < 10) {\n  mitteilung = 'Zu klein. Keine Auszahlung m\xF6glich!';\n} else {\n  mitteilung = 'Der Betrag wird ausgezahlt!';\n}</code></pre>\n\nZuerst wird gepr\xFCft, ob <code>betrag</code> gr\xF6\xDFer <code>1000</code> ist. Ist das der Fall, wird die 'Zu gro\xDF...'-Mitteilung\ngesetzt und der Code am Ende des gesamten Blocks fortgesetzt. Ist das nicht der Fall, wird die <code>else if</code>-Bedingung\ngepr\xFCft. Ist diese erf\xFCllt, wird die 'Zu klein...'-Mitteilung gesetzt und der Code am Ende des gesamten Blocks fortgesetzt.\nErst wenn keine Bedingung erf\xFCllt ist, wird der abschlie\xDFenden <code>else</code>-Block ausgef\xFChrt.",task:"Schreibe eine Funktion <code>addiereMitZuschlag</code>, die zwei Betr\xE4ge mit Zuschlag addiert.\nF\xFCr jeden Betrag, der kleiner gleich <code>10</code> ist, betr\xE4gt der Zuschlag <code>1</code>. F\xFCr jeden\nBetrag, der gr\xF6\xDFer <code>10</code> und kleiner gleich <code>20</code> ist, betr\xE4gt der Zuschlag <code>2</code>.\nF\xFCr jeden Betrag, der gr\xF6\xDFer <code>20</code> ist, betr\xE4gt der Zuschlag <code>3</code>.<br><br>Beispiel:\n<code>addiereMitZuschlag(10, 30)</code> sollte <code>44</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("addiereMitZuschlag")},function(){return jshero.testutil.assert_functionHasNumOfParameter("addiereMitZuschlag",2)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(1, 1)",4)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(10, 9)",21)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(11, 10)",24)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(10, 11)",24)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(13, 20)",37)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(20, 13)",37)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(15, 27)",47)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(27, 15)",47)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(25, 5)",34)},function(){return jshero.testutil.assert_functionReturns("addiereMitZuschlag(5, 25)",34)}]});
jshero.koans.add({id:"equals",title:"Strikte Gleichheit",lesson:"Zwei Werte kann man auf strikte Gleichheit \xFCberpr\xFCfen. Das Ergebnis eines solchen Vergleichs ist entweder\n<code>true</code>, die beiden Werte sind gleich, oder <code>false</code>, die beiden Werte sind ungleich.\nDer Operator f\xFCr strikte Gleichheit ist <code>===</code>.\n\n<pre><code>var sprache = 'JavaScript';\nvar x = 10;\nvar v1 = sprache === 'Java';\nvar v2 = x === 10;\nvar v3 = x === '10';</code></pre>\n\n<code>v1</code> bekommt das Ergebnis des Vergleichs der Variablen <code>sprache</code> mit dem Wert\n<code>'Java'</code> zugewiesen. Da <code>sprache</code> zuvor den Wert <code>JavaScript</code> erhalten hat und\ndiese beiden Werte verschieden sind, hat <code>v1</code> den Wert <code>false</code>. <code>v2</code> ist\n<code>true</code>, da der Wert von <code>x</code> gleich <code>10</code> ist. Bei der strikten Gleichheit kommt es\nauch darauf an, dass die Datentypen der beiden verglichenen Werte gleich sind. <code>v3</code> ist <code>false</code>,\nda hier unterschiedliche Typen verglichen werden. Auf der linken Seite des Vergleichs steht eine Zahl, auf der\nrechten Seite ein String.",task:"Schreibe eine Funktion <code>gleich</code>, die zwei Werte auf strikte Gleichheit \xFCberpr\xFCft.<br><br>Beispiel:\n<code>gleich(1, 1)</code> soll <code>true</code> zur\xFCckgeben, <code>gleich(1, 2)</code> soll\n<code>false</code> ergeben.",hint:"<pre><code>var gleich = function(a, b) {\n  return ...\n};</code></pre>",solution:"<pre><code>var gleich = function(a, b) {\n  return a === b;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("gleich")},function(){return jshero.testutil.assert_functionHasNumOfParameter("gleich",2)},function(){return jshero.testutil.assert_functionReturns("gleich(1, 1)",true)},function(){return jshero.testutil.assert_functionReturns("gleich(1, '1')",false)},function(){return jshero.testutil.assert_functionReturns("gleich(1, 2)",false)},function(){return jshero.testutil.assert_functionReturns("gleich('klein', 'klein')",true)},function(){return jshero.testutil.assert_functionReturns("gleich('Links', 'Rechts')",false)}]});
jshero.koans.add({id:"equals2",title:"Drei gleiche Werte",lesson:"Die folgende Aufgabe soll das Zusammenspiel von strikter Gleichheit und booleschen Operatoren vertiefen.",task:"Schreibe eine Funktion <code>gleich</code>, die 3 Werte auf strikte Gleichheit \xFCberpr\xFCft. Die Funktion soll nur\ndann <code>true</code> ergeben, wenn alle 3 Werte strikt gleich sind.<br><br>Beispiel: <code>gleich(1, 1, 1)</code> soll\n<code>true</code> zur\xFCckgeben, <code>gleich(1, 1, 2)</code> soll <code>false</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("gleich")},function(){return jshero.testutil.assert_functionHasNumOfParameter("gleich",3)},function(){return jshero.testutil.assert_functionReturns("gleich(1, 1, 1)",true)},function(){return jshero.testutil.assert_functionReturns("gleich(1, 1, 2)",false)},function(){return jshero.testutil.assert_functionReturns("gleich('1', 1, 1)",false)},function(){return jshero.testutil.assert_functionReturns("gleich(1, '1', 1)",false)},function(){return jshero.testutil.assert_functionReturns("gleich(1, 1, '1')",false)},function(){return jshero.testutil.assert_functionReturns("gleich('klein', 'klein', 'klein')",true)},function(){return jshero.testutil.assert_functionReturns("gleich('klein', 'klein', 'gro\xDF')",false)}]});
jshero.koans.add({id:"even",title:"Gerade Zahlen",task:"Schreibe eine Funktion <code>isEven</code>, die pr\xFCft, ob eine Zahl gerade oder ungerade ist.\nIst die Zahl gerade, so soll die Funktion <code>true</code> zur\xFCckgeben, andernfalls <code>false</code>.<br><br>\nBeispiel: Der Aufruf <code>isEven(6)</code> soll <code>true</code> ergeben und <code>isEven(7)</code> soll\n<code>false</code> zur\xFCckgeben.",hint:"Verwende den Modulo-Operator zusammen mit strikter Gleichheit, um zu bestimmen, ob eine Zahl gerade ist.",solution:"<pre><code>var isEven = function(n) {\n  return n % 2 === 0;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("isEven")},function(){return jshero.testutil.assert_functionHasNumOfParameter("isEven",1)},function(){return jshero.testutil.assert_functionReturns("isEven(0)",true)},function(){return jshero.testutil.assert_functionReturns("isEven(1)",false)},function(){return jshero.testutil.assert_functionReturns("isEven(2)",true)},function(){return jshero.testutil.assert_functionReturns("isEven(37)",false)},function(){return jshero.testutil.assert_functionReturns("isEven(208)",true)}]});
jshero.koans.add({id:"fahrenheit",title:"Fahrenheit",lesson:"Die folgende Aufgabe ist dem <a href=\"https://www.freecodecamp.org\">freeCodeCamp</a> entnommen.",task:"Schreibe eine Funktion <code>toFahrenheit</code>, die eine Temperaturangabe von\n<a href=\"https://de.wikipedia.org/wiki/Grad_Celsius\">Grad Celsius</a> in\n<a href=\"https://de.wikipedia.org/wiki/Grad_Fahrenheit\">Grad Fahrenheit</a> umrechnet.<br><br>Tipp: Ist C die Temperatur\nin Grad Celsius und F die Temperatur in Grad Fahrenheit, so gilt: F = 1.8 * C + 32.\n<br><br>Beispiel: <code>toFahrenheit(0)</code> sollte <code>32</code> ergeben.",hint:"<pre><code>var toFahrenheit = function(celsius) {\n  return ...\n};</code></pre>",solution:"<pre><code>var toFahrenheit = function(celsius) {\n  return 1.8 * celsius + 32;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("toFahrenheit")},function(){return jshero.testutil.assert_functionHasNumOfParameter("toFahrenheit",1)},function(){return jshero.testutil.assert_functionReturns("toFahrenheit(0)",32)},function(){return jshero.testutil.assert_functionReturns("toFahrenheit(10)",50)},function(){return jshero.testutil.assert_functionReturns("toFahrenheit(40)",104)},function(){return jshero.testutil.assert_functionReturns("toFahrenheit(100)",212)}]});
(function(testutil){jshero.koans.add({id:"fakultaet",title:"Fakult\xE4t",lesson:"Die <code>for</code>-Schleife soll nochmal anhand der in der Mathematik verwendeten Funktion\n<a href='https://de.wikipedia.org/wiki/Fakult%C3%A4t_(Mathematik)'>Fakult\xE4t</a> ge\xFCbt werden.\nDie Fakult\xE4t einer nat\xFCrlichen Zahl n ist das Produkt aller nat\xFCrlichen Zahlen (ohne Null) kleiner oder gleich n.\nSie wird durch ein nachgestelltes Ausrufezeichen abgek\xFCrzt: 3! = 1*2*3 = 6. Per Definition gilt 0! = 1.",task:"Schreibe eine Funktion <code>fakultaet</code>, die die Fakult\xE4t einer nat\xFCrlichen Zahl berechnet.\n<code>fakultaet(3)</code> sollte <code>1*2*3</code> = <code>6</code> ergeben.",hint:"<pre><code>var fakultaet = function(n) {\n      var result = 1;\n      for (...) {\n        ...\n      }\n      return result;\n    };</pre></code>",solution:"<pre><code>var fakultaet = function(n) {\n  var result = 1;\n  for (var i = 1; i <= n; i++) {\n    result = result * i;\n  }\n  return result;\n};</pre></code>",tests:[function(){return testutil.assert_isFunction("fakultaet")},function(){return testutil.assert_functionHasNumOfParameter("fakultaet",1)},function(){return testutil.assert_functionReturns("fakultaet(0)",1)},function(){return testutil.assert_functionReturns("fakultaet(1)",1)},function(){return testutil.assert_functionReturns("fakultaet(2)",2)},function(){return testutil.assert_functionReturns("fakultaet(3)",6)},function(){return testutil.assert_functionReturns("fakultaet(4)",24)},function(){return testutil.assert_functionReturns("fakultaet(9)",362880)}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"for1",title:"for-Schleife",lesson:"Mit Schleifen k\xF6nnen Code-Abschnitte mehrmals durchlaufen werden. JavaScript kennt mehrere Schleifenarten.\nDie einfachste ist die <code>for</code>-Schleife.\n\n<pre><code>var summe = 0;\nfor (var i = 1; i < 3; i++) {\n  summe = summe + i;\n}</code></pre>\n\nDie <code>for</code>-Schleife besteht aus drei Steuer-Anweisungen und dem Schleifen-Code. Die drei Anweisungen folgen dem <code>for</code> in runden Klammern.\nSie werden durch Semikolons voneinander getrennt. Die erste Anweisung ist die Start-Anweisung. Sie wird einmal zu Beginn der Schleife ausgef\xFChrt.\nHier wird normalerweise eine Variable, die sogenannte Schleifenvariable, initialisiert. Die zweite Anweisung ist die Schleifen-Bedingung.\nSie wird vor jedem Schleifendurchlauf zu <code>true</code> oder <code>false</code> ausgewertet.\nIst der Ausdruck <code>true</code>, wird der Schleifen-Code ausgef\xFChrt.\nIst er <code>false</code>, wird die Schleife beendet und die Programmausf\xFChrung wird nach der Schleife fortgesetzt.\nNach jedem Schleifen-Durchlauf wird die dritte Anweisung, die sogenannten End-Anweisung, ausgef\xFChrt.\nHier wird normalerweise die Schleifenvariable erh\xF6ht.\nAnschlie\xDFend beginnt ein neuer Schleifendurchlauf mit erneuter Auswertung der Schleifen-Bedingung.\nDer Schleifen-Code folgt in Mengenklammern den drei Steueranweisungen.\nIn unserem Beispiel hat <code>summe</code> zun\xE4chst den Wert <code>0</code>. In der Start-Anweisung wird <code>i</code> mit <code>1</code> initialisiert.\nDie Schleifenbedingung <code>1 < 3</code> ist erf\xFCllt, also wird der Schleifen-Code ausgef\xFChrt.\n<code>summe</code> erh\xE4lt den Wert <code>0 + 1</code>, also <code>1</code>.\nNun wird in der End-Anweisung <code>i</code> um <code>1</code> erh\xF6ht (<code>i++</code> ist identisch mit <code>i = i + 1</code>).\nEs erh\xE4lt also den Wert <code>2</code>. Der zweite Schleifendurchlauf startet mit Auswertung der Schleifenbedingung.\nDiese Bedingung (<code>2 < 3</code>) ist immer noch erf\xFCllt.\nDer Schleifen-Code wird erneut ausgef\xFChrt und <code>summe</code> erh\xE4lt jetzt den Wert <code>1 + 2</code>, also <code>3</code>.\n<code>i</code> wird abermals erh\xF6ht und hat nun den Wert <code>3</code>.\nDie Schleifenbedingung <code>3 < 3</code> ist jetzt nicht mehr erf\xFCllt. Die Schleife wird beendet und die Programmausf\xFChrung wird nach der Schleife fortgesetzt.\nUnser Codebeispiel hat also alle nat\xFCrlichen Zahlen echt kleiner 3 addiert.",task:"Schreibe eine Funktion <code>addiereBis</code>, die eine Zahl als Parameter entgegennimmt und die\nalle nat\xFCrlichen Zahlen kleiner gleich dem Paramter aufaddiert. Das Ergebnis der Addition soll zur\xFCckgegeben werden.\n<code>addiereBis(3)</code> sollte <code>1+2+3</code> = <code>6</code> ergeben.",hint:"<pre><code>var addiereBis = function(n) {\n  var summe = 0;\n  for (var i = 0; i <= n; i++) {\n    ...\n  }\n  return summe;\n};</pre></code>",solution:"<pre><code>var addiereBis = function(n) {\n  var summe = 0;\n  for (var i = 0; i <= n; i++) {\n    summe = summe + i;\n  }\n  return summe;\n};</pre></code>",tests:[function(){return testutil.assert_isFunction("addiereBis")},function(){return testutil.assert_functionHasNumOfParameter("addiereBis",1)},function(){return testutil.assert_functionReturns("addiereBis(0)",0)},function(){return testutil.assert_functionReturns("addiereBis(1)",1)},function(){return testutil.assert_functionReturns("addiereBis(2)",3)},function(){return testutil.assert_functionReturns("addiereBis(3)",6)},function(){return testutil.assert_functionReturns("addiereBis(9)",45)}]})})(jshero.testutil);
jshero.koans.add({id:"for2",title:"Schleifen und Arrays",lesson:"<code>for</code>-Schleifen eignen sich besonders gut zum Durchlaufen von Arrays.\nIm folgenden Beispiel werden die Elemente eines Arrays aufaddiert:\n\n<pre><code>var sum = 0;\nfor (var i = 0; i < myArray.length; i++) {\n  sum = sum + myArray[i];\n}</code></pre>",task:"Schreibe eine Funktion <code>mean</code>, die ein Array gef\xFCllt mit Zahlen entgegennimmt und den\nDurchschnitt dieser Zahlen zur\xFCckgibt. Tipp: Um den Durchschnitt von n Zahlen zu berechnen,\nmu\xDFt du die Zahlen aufaddieren und die erhaltene Summe durch n teilen.\n<code>mean([1, 2, 3])</code> sollte <code>(1+2+3)/3</code> = <code>2</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("mean")},function(){return jshero.testutil.assert_functionHasNumOfParameter("mean",1)},function(){return jshero.testutil.assert_functionReturns("mean([0])",0)},function(){return jshero.testutil.assert_functionReturns("mean([1, 2])",1.5)},function(){return jshero.testutil.assert_functionReturns("mean([1, 2, 3])",2)},function(){return jshero.testutil.assert_functionReturns("mean([-2, -4, 17, 34])",11.25)}]});
(function(testutil){jshero.koans.add({id:"function",title:"Funktionen",lesson:"Eine Funktion ist ein Block von Anweisungen, der beliebig oft ausgef\xFChrt werden kann. Eine Funktion kann\nParameter entgegennehmen und eine Funktion kann einen Wert zur\xFCckgeben. Funktionen werden mit dem Schl\xFCsselwort\n<code>function</code> definiert. Darauf folgen in runden Klammern eingeschlossen die Parameter und anschlie\xDFend,\neingeschlossen in geschweiften Klammern, die Anweisungen. Mit dem Schl\xFCsselwort <code>return</code> kann ein Wert\nzur\xFCckgegeben werden. Gleichzeitig beendet <code>return</code> die Funktion. Anweisungen nach einem <code>return</code>\nwerden nicht mehr ausgef\xFChrt. Funktionen kann man Variablen zuordnen. Mit\n\n<pre><code>var farbe = function() {\n  return 'gr\xFCn';\n};</code></pre>\n\ndefinieren wir eine Funktion, die <code>'gr\xFCn'</code> zur\xFCckgibt. Die Funktion nimmt keine Paramter entgegen\n(die runde Klammer ist leer) und sie enth\xE4lt genau eine Anweisung, die R\xFCckgabe. Die Funktion wird der Variablen\n<code>farbe</code> zugeordnet. \xDCber diese Variable wird die Funktion aufgerufen:\n\n<pre><code>var ergebnis = farbe();</code></pre>\n\nJetzt wird die Funktion ausgef\xFChrt. Ihre R\xFCckgabe wird der Variablen <code>ergebnis</code> zugewiesen.\n<code>ergebnis</code> hat dann den Wert <code>'gr\xFCn'</code>.",task:"Deklariere eine Variable <code>hallo</code> und weise ihr eine Funktion zu, die <code>'Hallo Welt!'</code> zur\xFCckgibt.",hint:"<pre><code>var hallo = function() {\n  ...\n};</code></pre>",solution:"<pre><code>var hallo = function() {\n  return 'Hallo Welt!';\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("hallo")},function(){return testutil.assert_functionReturns("hallo()","Hallo Welt!")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"function2",title:"Mehrere Funktionen",lesson:"Wir definieren nun mehr als eine Funktion.\n  Zur Erinnerung: So wird eine Funktion mit Namen <code>farbe</code> definiert, die den Wert <code>'rot'</code>\n  zur\xFCckgibt:\n\n<pre><code>var farbe = function() {\n  return 'rot';\n};</code></pre>",task:"Definiere zwei Funktionen. Die erste Funktion <code>a</code> soll <code>'Hallo a!'</code>\nzur\xFCckgeben. Die zweite Funktion <code>b</code> soll <code>'Hallo b!'</code> zur\xFCckgeben.",tests:[function(){return testutil.assert_isFunction("a")},function(){return testutil.assert_isFunction("b")},function(){return testutil.assert_functionReturns("a()","Hallo a!")},function(){return testutil.assert_functionReturns("b()","Hallo b!")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"functioncall",title:"Funktionsaufruf",lesson:"Wichtig ist der Unterschied zwischen der Definition und dem Aufruf einer Funktion.\nMit der Definition, z. B.\n\n<pre><code>var f = function() {\n  return 'hallo';\n};</code></pre>\n\nwird festgelegt, was die Funktion machen soll. Sie wird dabei nicht ausgef\xFChrt. Sie wird lediglich zur Ausf\xFChrung bereitgestellt.\nErst mit ihrem Aufruf\n\n<pre><code>var x = f();</code></pre>\n\nwird die Funktion ausgef\xFChrt. Dann werden die Anweisungen im Funktionsblock der Reihe nach abgearbeitet.\nDie R\xFCckgabe der Funktion wird in diesem Beispiel der Variablen <code>x</code> zugewiesen.\nDefiniert werden Funktionen mit dem Schl\xFCsselwort <code>function</code>.\nIst die Funktion einer Variablen zugewiesen, geschieht der Aufruf der Funktion \xFCber diese Variable.\nFunktionen werden einmal definiert, um sie dann an verschiedenen Programmstellen durch ihren Aufruf mehrfach zu benutzen.",task:"1. Definiere eine Funktion <code>begruesse</code>, die den Wert <code>'Moin!'</code> zur\xFCckgibt.\n<br/>\n2. Deklariere eine Variable <code>begruessung</code>. Rufe die Funktion <code>begruesse</code> auf und weise der Variablen\n<code>begruessung</code> die R\xFCckgabe dieses Aufrufs zu.",hint:"<pre><code>var begruesse = function() {\n  ...\n};\n\nvar begruessung = ...</code></pre>",solution:"<pre><code>var begruesse = function() {\n  return 'Moin!';\n};\n\nvar begruessung = begruesse();</code></pre>",tests:[function(){return testutil.assert_isFunction("begruesse")},function(){return testutil.assert_functionReturns("begruesse()","Moin!")},function(){return testutil.assert_variableDefined("begruessung")},function(){return testutil.assert_variableHasValue("begruessung","Moin!")}]})})(jshero.testutil);
jshero.koans.add({id:"further",title:"Quersumme",lesson:"Mit dieser Lektion endet die Einf\xFChrung in den Sprachkern von JavaScript.\n Die folgenden Lektionen bieten einen kleinen Einstieg in das sogenannte clientseitige JavaScript.\n Zum Abschluss der Einf\xFChrung in den Sprachkern noch eine Aufgabe aus dem Gebiet der Mathematik:",task:"Schreibe eine Funktion <code>quersumme</code>, die die Quersumme einer nat\xFCrlichen Zahl berechnet.\nDie Quersumme einer Zahl ist dabei die Summe ihrer Ziffern. <code>quersumme(198)</code> sollte <code>18</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("quersumme")},function(){return jshero.testutil.assert_functionHasNumOfParameter("quersumme",1)},function(){return jshero.testutil.assert_functionReturns("quersumme(1)",1)},function(){return jshero.testutil.assert_functionReturns("quersumme(198)",18)},function(){return jshero.testutil.assert_functionReturns("quersumme(123456789)",45)}],hint:"<pre><code>var quersumme = function(zahl) {\n// Extrahiere in einer Schleife\n// mit Modulo jeweils die\n// Einer-Stelle und addiere \n// sie auf.\n};</code></pre>",solution:"<pre><code>var quersumme = function(zahl) {\n  var sum = 0;\n  var rest = zahl;\n  while (rest > 0) {\n    var einer = rest % 10;\n    sum = sum + einer;\n    rest = (rest - einer)/10;\n  }\n  return sum;\n};</code></pre>"});
(function(testutil){jshero.koans.add({id:"gettime",title:"Date: getTime()",lesson:"Die Date-Methode <code>getTime</code> liefert die Millisekunden, die zwischen dem 1.1.1970, 0:00 UTC\nund dem Zeitpunkt des Datumsobjekts liegen.\n\n<pre><code>var date = new Date(Date.UTC(1970, 0, 1, 0, 0, 1));\nvar time = date.getTime();</code></pre>\n\nZwischen dem 1.1.1970, 0:00:00 UTC und dem 1.1.1970, 0:00:01 UTC liegen 1000 Millisekunden.\n<code>time</code> erh\xE4lt den Wert <code>1000</code>.",task:"Schreibe eine Funktion <code>days</code>, die die Differenz in Tagen zwischen zwei Date-Objekten berechnet.\nEs sollen nur volle Tage gez\xE4hlt werden.\n<code>days(new Date(2018, 0, 1), new Date(2018, 0, 2))</code> und\n<code>days(new Date(2018, 0, 1), new Date(2018, 0, 2, 12))</code> sollten <code>1</code> zur\xFCckgeben.",tests:[function(){return testutil.assert_isFunction("days")},function(){return testutil.assert_functionHasNumOfParameter("days",2)},function(){return testutil.assert_functionReturns("days(new Date(2018, 0, 1), new Date(2018, 0, 1))",0)},function(){return testutil.assert_functionReturns("days(new Date(2018, 0, 1), new Date(2018, 0, 2))",1)},function(){return testutil.assert_functionReturns("days(new Date(2018, 0, 1), new Date(2018, 0, 3))",2)},function(){return testutil.assert_functionReturns("days(new Date(2018, 0, 1), new Date(2018, 0, 4))",3)},function(){return testutil.assert_functionReturns("days(new Date(2018, 0, 1), new Date(2018, 0, 4, 23, 59))",3)},function(){return testutil.assert_functionReturns("days(new Date(2018, 0, 1), new Date(2019, 0, 1))",365)}]})})(jshero.testutil);
jshero.koans.add({id:"ggt",title:"ggT",lesson:"Das Gegenst\xFCck zum kleinsten gemeinsamen Vielfachen (kgV) ist der\n<a href='https://de.wikipedia.org/wiki/Gr%C3%B6%C3%9Fter_gemeinsamer_Teiler'>gr\xF6\xDFte gemeinsamer Teiler (ggT)</a>.\nDer gr\xF6\xDFte gemeinsame Teiler zweier Zahlen a und b ist die gr\xF6\xDFte Zahl, durch die sich sowohl a als auch b teilen l\xE4\xDFt.",task:"Schreibe eine Funktion <code>ggT</code>, die zwei nat\xFCrliche Zahlen als Parameter entgegennimmt und deren ggT berechnet.\n<code>ggT(6, 15)</code> sollte <code>3</code> zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("ggT")},function(){return jshero.testutil.assert_functionHasNumOfParameter("ggT",2)},function(){return jshero.testutil.assert_functionReturns("ggT(1, 1)",1)},function(){return jshero.testutil.assert_functionReturns("ggT(1, 2)",1)},function(){return jshero.testutil.assert_functionReturns("ggT(2, 3)",1)},function(){return jshero.testutil.assert_functionReturns("ggT(2, 4)",2)},function(){return jshero.testutil.assert_functionReturns("ggT(6, 15)",3)},function(){return jshero.testutil.assert_functionReturns("ggT(12, 18)",6)},function(){return jshero.testutil.assert_functionReturns("ggT(18, 12)",6)},function(){return jshero.testutil.assert_functionReturns("ggT(15, 45)",15)},function(){return jshero.testutil.assert_functionReturns("ggT(45, 15)",15)}]});
jshero.koans.add({id:"greaterthan",title:"Zahlen vergleichen",lesson:"Zahlen kann man mit den aus der Mathematik bekannten Zeichen\n<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code> und <code>&lt;=</code>\nauf gr\xF6\xDFer, gr\xF6\xDFer gleich, kleiner und kleiner gleich vergleichen.\nIm folgenden Beispiel liefern alle Ausdr\xFCcke den Wert <code>true</code>:\n<pre><code>var v1 = 5 > 4;\nvar v2 = 5 >= 5;\nvar v3 = 5 < 6;\nvar v4 = 5 <= 5;</code></pre>",task:"Schreibe eine Funktion <code>istDreistellig</code>, die pr\xFCft, ob eine Zahl gr\xF6\xDFer gleich 100 und kleiner 1000\nist.<br><br>Beispiel: <code>istDreistellig(500)</code> sollte <code>true</code> zur\xFCckgeben,\n<code>istDreistellig(50)</code> sollte <code>false</code> ergeben.",hint:"<pre><code>var istDreistellig = function(x) {\n  return x >= 100 && ...\n};</code></pre>",solution:"<pre><code>var istDreistellig = function(x) {\n  return x >= 100 && x < 1000;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("istDreistellig")},function(){return jshero.testutil.assert_functionHasNumOfParameter("istDreistellig",1)},function(){return jshero.testutil.assert_functionReturns("istDreistellig(100)",true)},function(){return jshero.testutil.assert_functionReturns("istDreistellig(709)",true)},function(){return jshero.testutil.assert_functionReturns("istDreistellig(999)",true)},function(){return jshero.testutil.assert_functionReturns("istDreistellig(99)",false)},function(){return jshero.testutil.assert_functionReturns("istDreistellig(1000)",false)}]});
jshero.koans.add({id:"if",title:"if",lesson:"H\xE4ufig soll Code nur dann ausgef\xFChrt werden, wenn eine bestimmte Bedingung erf\xFCllt ist.\nDazu verwendet man die <code>if</code>-Anweisung.\n\n<pre><code>var gewinn = 0;\nif (wuerfelzahl === 6) {\n  gewinn = 100;\n}</code></pre>\n\nDiese Anweisung besteht aus dem Schl\xFCsselwort <code>if</code> (engl: wenn) gefolgt von runden Klammern. In den runden\nKlammern steht ein Ausdruck - die Bedingung -, der zu <code>true</code> oder <code>false</code> ausgewertet wird.\nErgibt die Bedingung <code>true</code>, werden alle Anweisungen in dem durch die geschweiften Klammern begrenzten Block\nausgef\xFChrt. Ergibt die Bedingung <code>false</code>, wird der durch die geschweiften Klammern begrenzte Block \xFCbersprungen.\nHat in unserem Beispiel die Variable <code>wuerfelzahl</code> den Wert <code>6</code>, so wird <code>gewinn</code> auf\n<code>100</code> gesetzt. Hat <code>wuerfelzahl</code> nicht den Wert <code>6</code>, bleibt <code>gewinn</code> bei\n<code>0</code>.",task:"Schreibe eine Funktion <code>gleich</code>, die 2 Werte auf strikte Gleichheit \xFCberpr\xFCft. Sind die beiden Werte\ngleich, so soll der String <code>'GLEICH'</code> zur\xFCckgegeben werden. Sind sie ungleich, so soll man\n<code>'UNGLEICH'</code> erhalten.",hint:"<pre><code>var gleich = function(a, b) {\n// Initialisiere eine Variable\n// mit 'UNGLEICH'. Verwende 'if',\n// um die Variable ggf. auf\n// 'GLEICH' zu setzen. Gebe die\n// Variable zur\xFCck.\n};</code></pre>",solution:"<pre><code>var gleich = function(a, b) {\n  var ergebnis = 'UNGLEICH';\n  if (a === b) {\n    ergebnis = 'GLEICH';\n  }\n  return ergebnis;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("gleich")},function(){return jshero.testutil.assert_functionHasNumOfParameter("gleich",2)},function(){return jshero.testutil.assert_functionReturns("gleich(1, 1)","GLEICH")},function(){return jshero.testutil.assert_functionReturns("gleich(1, 2)","UNGLEICH")},function(){return jshero.testutil.assert_functionReturns("gleich(1, '1')","UNGLEICH")},function(){return jshero.testutil.assert_functionReturns("gleich('klein', 'klein')","GLEICH")},function(){return jshero.testutil.assert_functionReturns("gleich('Links', 'Rechts')","UNGLEICH")}]});
jshero.koans.add({id:"if2",title:"Zwei return-Anweisungen",lesson:"Mit der <code>if</code>-Anweisung hat man die M\xF6glichkeit, Funktionen mit zwei <code>return</code>-Anweisungen\nzu schreiben:\n\n<pre><code>var gewinn = function(zahl) {\n  if (zahl === 6) {\n    return 100;\n  }\n  return 0;\n};</code></pre>\n\nHat <code>zahl</code> den Wert <code>6</code>, so ist die <code>if</code>-Bedingung erf\xFCllt und die erste\n<code>return</code>-Anweisung wird ausgef\xFChrt. Die Funktion wird beendet und gibt <code>100</code> zur\xFCck.\nHat <code>zahl</code> nicht den Wert <code>6</code>, so ist die <code>if</code>-Bedingung nicht erf\xFCllt.\nDie Codeausf\xFCfrung wird hinter dem zur <code>if</code>-Anweisung geh\xF6rigen Block fortgesetzt. Die zweite\n<code>return</code>-Anweisung wird ausgef\xFChrt. Die Funktion gibt <code>0</code> zur\xFCck.<br><br>\nAber Achtung: Zwei oder auch mehr <code>return</code>-Anweisungen in einer Funktion sollte man sorgsam verwenden.\nAndernfalls wird der Code un\xFCbersichtlich.",task:"Schreibe eine Funktion <code>schnapszahl</code>, die feststellt, ob eine zweistellige Zahl eine Schnapszahl ist\noder nicht. Ist die Zahl eine Schnapszahl, soll <code>'Schnaps!'</code> zur\xFCckgegeben werden, andernfalls\n<code>'Kein Schnaps!'</code>. <br><br>Eine <a href='https://de.wikipedia.org/wiki/Schnapszahl'>Schnapszahl</a>\nist eine mehrstellige Zahl, die ausschlie\xDFlich durch identische Ziffern dargestellt wird.\n<br><br>Beispiel: <code>schnapszahl(22)</code> sollte <code>'Schnaps!'</code> und\n<code>schnapszahl(23)</code> sollte <code>'Kein Schnaps!'</code> zur\xFCckgeben.",hint:"<pre><code>var schnapszahl = function(n) {\n// Berechne die Einerstelle\n// von n mit Modulo 10.\n// Berechne die Zehnerstelle\n// von n mit Division\n// durch 10 und Abrunden.\n// Vergleiche Einer- und\n// Zehnerstelle.\n};</code></pre>",solution:"<pre><code>var schnapszahl = function(n) {\n  var einer = n % 10;\n  var zehner = Math.floor(n / 10);\n  if (einer === zehner) {\n    return 'Schnaps!';\n  }\n  return 'Kein Schnaps!';\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("schnapszahl")},function(){return jshero.testutil.assert_functionHasNumOfParameter("schnapszahl",1)},function(){return jshero.testutil.assert_functionReturns("schnapszahl(11)","Schnaps!")},function(){return jshero.testutil.assert_functionReturns("schnapszahl(55)","Schnaps!")},function(){return jshero.testutil.assert_functionReturns("schnapszahl(99)","Schnaps!")},function(){return jshero.testutil.assert_functionReturns("schnapszahl(10)","Kein Schnaps!")},function(){return jshero.testutil.assert_functionReturns("schnapszahl(12)","Kein Schnaps!")},function(){return jshero.testutil.assert_functionReturns("schnapszahl(98)","Kein Schnaps!")}]});
(function(testutil){jshero.koans.add({id:"increment",title:"Inkrement",lesson:"In der Programmierung m\xF6chte man h\xE4ufig einen Z\xE4hler um eins erh\xF6hen oder verringern.\nDas kann man leicht mit dem Inkrement- bzw. dem Dekrementoperator tun.\n\n<pre><code>var x = 1;\nx++;\nvar y = 10;\ny--;</code></pre>\n\n<code>x++</code> ist identisch mit <code>x = x + 1</code> und <code>y--</code> ist identisch mit <code>y = y - 1</code>.\nNach Ausf\xFChrung des Beispielcodes hat <code>x</code> den Wert <code>2</code> und <code>y</code> den Wert <code>9</code>.",task:"Welchen Wert hat <code>x</code> nach Ausf\xFChrung des folgenden Codes?\n<pre><code>var x = 3;\nx++;\nx = x * 2;\nx--;</code></pre>",solution:"<pre><code>7</code></pre>",tests:[function(){return testutil.assert_isValue("7")}]})})(jshero.testutil);
jshero.koans.add({id:"join",title:"Array: join()",lesson:"Mit <code>join</code> verbindet man alle Elemente eines Arrays zu einem String:\n\n<pre><code>var words = ['Sex', 'Drugs', 'Rock', 'Roll'];\nvar l1 = words.join();\nvar l2 = words.join(' & ');\nvar l3 = words.join(' and ');</code></pre>\n\nOhne Argument f\xFCgt <code>join</code> die Elemente kommasepariert zusammen.\n<code>l1</code> ergibt <code>'Sex,Drugs,Rock,Roll'</code>.\nAnsonsten gibt das \xFCbergebene Argument das Trennzeichen vor.\n<code>l2</code> ergibt <code>'Sex & Drugs & Rock & Roll'</code> und\n<code>l3</code> den String <code>'Sex and Drugs and Rock and Roll'</code>.",task:"Schreibe eine Funktion <code>list</code>, die W\xF6rter in einem Array zu einer Aufz\xE4hlung zusammenf\xFChrt.\nEin leeres Array soll den Leerstring ergeben.\n<br><br>Beispiel: <code>list(['Sonne', 'Mond', 'Sterne'])</code> soll <code>'Sonne, Mond und Sterne'</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("list")},function(){return jshero.testutil.assert_functionHasNumOfParameter("list",1)},function(){return jshero.testutil.assert_functionReturns("list(['Ernie', 'Bert'])","Ernie und Bert")},function(){return jshero.testutil.assert_functionReturns("list(['Sonne', 'Mond', 'Sterne'])","Sonne, Mond und Sterne")},function(){return jshero.testutil.assert_functionReturns("list(['C', 'C++', 'Python', 'PHP'])","C, C++, Python und PHP")},function(){return jshero.testutil.assert_functionReturns("list(['Apfel'])","Apfel")},function(){return jshero.testutil.assert_functionReturns("list([])","")}]});
(function(testutil){jshero.koans.add({id:"jsx01",title:"Was ist x?",lesson:"Das eben gelernt wollen wir nochmal \xFCben. W\xE4hrend Du bei der ersten Aufgabe Code geschrieben hast,\nsollst du hier Code lesen.",task:"Welchen Wert hat <code>x</code> nach Ausf\xFChrung des folgenden Codes?\n<pre><code>var x = 'Josefine';</code></pre>",solution:"<pre><code>'Josefine'</code></pre>",tests:[function(){return testutil.assert_isString("Josefine")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"jsx02",title:"Neuzuweisung",lesson:"Einer Variablen kann man jederzeit mit dem Gleichheitszeichen einen neuen Wert zuweisen.\nDas Schl\xFCsselwort <code>var</code> wird dabei nicht nochmal verwendet.\n<pre><code>var farbe = 'rot';\nfarbe = 'gr\xFCn';</code></pre>\nDie Variable <code>farbe</code> wird mit dem Wert <code>'rot'</code> initialisiert. Danach erh\xE4lt sie den Wert <code>'gr\xFCn'</code>.",task:"Welchen Wert hat <code>x</code> nach Ausf\xFChrung des folgenden Codes?\n<pre><code>var x = 'Georg';\nx = 'Karl';\nx = 'Gregor';</code></pre>",solution:"<pre><code>'Gregor'</code></pre>",tests:[function(){return testutil.assert_isString("Gregor")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"jsx03",title:"Variablen zuweisen",lesson:"Einer Variablen kann man auch den Wert einer anderen Variablen zuweisen:\n<pre><code>var name1 = 'Olga';\nvar name2 = name1;\nname1 = 'Clara';</code></pre>\nIn der zweiten Codezeile wird der Variablen <code>name2</code> der Wert der Variablen <code>name1</code> zugewiesen.\n<code>name2</code> erh\xE4lt den Wert <code>'Olga'</code>. Diesen Wert beh\xE4lt <code>name2</code> bei,\nauch wenn anschlie\xDFend <code>name1</code> einen neuen Wert erh\xE4lt.",task:"Welchen Wert hat <code>x</code> nach Ausf\xFChrung des folgenden Codes?\n<pre><code>var x = 'rot';\nvar y = 'gr\xFCn';\nvar z = y;\ny = x;\nx = z;</code></pre>",solution:"<pre><code>'gr\xFCn'</code></pre>",tests:[function(){return testutil.assert_isString("gr\xFCn")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"jsx04",title:"Was ist x?",lesson:"Das eben Gelernte wollen wir nochmal \xFCben.",task:"Welchen Wert hat <code>x</code> nach Ausf\xFChrung des folgenden Codes?\n<pre><code>var hello = function() {\n  return 'Hi!';\n};\n\nvar x = hello();</code></pre>",solution:"<pre><code>'Hi!'</code></pre>",tests:[function(){return testutil.assert_isString("Hi!")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"jsx05",title:"Was ist x?",lesson:"Auch bei Funktionen mit Parametern wollen wir den Funktionsaufruf \xFCben.",task:"Welchen Wert hat <code>x</code> nach Ausf\xFChrung des folgenden Codes?\n<pre><code>var reply = function(phrase) {\n  return phrase;\n};\n\nvar x = reply('How do you do?');</code></pre>",solution:"<pre><code>'How do you do?'</code></pre>",tests:[function(){return testutil.assert_isString("How do you do?")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"jsx06",title:"Was ist x?",task:"Welchen Wert hat <code>x</code> nach Ausf\xFChrung des folgenden Codes?\n<pre><code>var woIst = function(name) {\n  return 'Wo ist ' + name + '?';\n};\n\nvar x = woIst('Fred');</code></pre>",solution:"<pre><code>'Wo ist Fred?'</code></pre>",tests:[function(){return testutil.assert_isString("Wo ist Fred?")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"jsx06b",title:"Was ist x?",task:"Welchen Wert hat <code>x</code> nach Ausf\xFChrung des folgenden Codes?\n<pre><code>var hi = function(name) {\n  return 'Hi ' + name + '!';\n};\n\nvar h1 = hi('Selva');\nvar h2 = hi('Pola');\nvar x = h1 + ' ' + h2;</code></pre>",solution:"<pre><code>'Hi Selva! Hi Pola!'</code></pre>",tests:[function(){return testutil.assert_isString("Hi Selva! Hi Pola!")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"jsx07",title:"Was ist x?",task:"Welchen Wert hat <code>x</code> nach Ausf\xFChrung des folgenden Codes?\n<pre><code>var bleiben = function(name) {\n  return name + ' bleibt ' + name;\n};\n\nvar x = bleiben('Mainz');</code></pre>",solution:"<pre><code>'Mainz bleibt Mainz'</code></pre>",tests:[function(){return testutil.assert_isString("Mainz bleibt Mainz")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"log",title:"Loggen und Strings",lesson:"Jetzt wollen wir das Loggen zusammen mit dem Verketten von Strings \xFCben.",task:"Schreibe eine Funktion <code>rufe</code>, die einen String als Parameter entgegennimmt und diesen String verdoppelt zur\xFCckgibt.\n  Gleichzeitig soll die R\xFCckgabe geloggt werden.<br><br>\n  Beispiel: Der Aufruf <code>rufe('Werder')</code>\n  sollte <code>'WerderWerder'</code> zur\xFCckgeben und er sollte <code>'WerderWerder'</code> loggen.",hint:"<pre><code>var rufe = function(name) {\n  var ruf = name + name;\n  ...\n};</code></pre>",solution:"<pre><code>var rufe = function(name) {\n  var ruf = name + name;\n  console.log(ruf);\n  return ruf;\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("rufe")},function(){return testutil.assert_functionHasNumOfParameter("rufe",1)},function(){return testutil.assert_functionReturns("rufe('Werder')","WerderWerder")},function(){return testutil.assert_functionReturns("rufe('Kickers')","KickersKickers")},function(){return testutil.assert_functionLogs("rufe('Werder')","WerderWerder")},function(){return testutil.assert_functionLogs("rufe('Kickers')","KickersKickers")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"log1",title:"Logging",lesson:"Programmieren beinhaltet immer auch die Suche nach Fehlern.\nEine M\xF6glichkeit Fehler zu finden ist das <a href='https://de.wikipedia.org/wiki/Logging'>Loggen</a>.\nMan macht w\xE4hrend der Programmausf\xFChrung gezielte Ausgaben.\nIn JavaScript verwendet man daf\xFCr die Funktion <code>console.log</code>:\n\n<pre><code>console.log('Hallo Konsole!');</code></pre>\n\nHier wird der String <code>'Hallo Konsole!'</code> mit <code>console.log</code> ausgegeben.\nWo man die Ausgabe zu sehen bekommt, h\xE4ngt von der JavaScript-Umgebung ab.\nIn Browsern sieht man die Log-Ausgabe im normalen Betrieb nicht.\nDoch die meisten Desktop-Browser besitzen sogenannte <a href='https://de.wikipedia.org/wiki/Entwicklerwerkzeuge_in_Webbrowsern'> Entwicklerwerkzeuge</a>.\nDas sind m\xE4chtige Tools zur Unterst\xFCtzung von Webentwicklern. Eines dieser Tools ist die Konsole.\nDort wird das Log ausgegeben. Wie man die Entwickler-Werkzeuge \xF6ffnet h\xE4ngt vom jeweiligen Browser ab.\nBei vielen Desktop-Browsern wird sie mit der Taste F12 ge\xF6ffnet.\nDie Konsole kannst du dann als Reiter ausw\xE4hlen. Alternativ kann man die Konsole \xFCber das Browser-Men\xFC \xF6ffnen.\nAuf mobilen Ger\xE4ten stehen die Entwickler-Werkzeuge nicht zur Verf\xFCgung.\nDeshalb schreibt JS Hero das Log zus\xE4tzlich in die Testausgabe.",task:"Schreibe eine Funktion <code>logge</code>, die den String <code>'Hallo Konsole!'</code> loggt.\nArbeitest du mit einem Desktop-Browser \xF6ffne zus\xE4tzlich die Entwickler-Tools, um auch dort die Ausgabe zu sehen.",hint:"<pre><code>var logge = function() {\n  console.log(...);\n};</code></pre>",solution:"<pre><code>var logge = function() {\n  console.log('Hallo Konsole!');\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("logge")},function(){return testutil.assert_functionLogs("logge()","Hallo Konsole!")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"log2",title:"Variablen loggen",lesson:"Nun wollen wir Variablen loggen:\n\n<pre><code>var informatiker = 'Ken Thompson';\nconsole.log(informatiker);</code></pre>\n\nHier wird die Variable <code>informatiker</code> mit <code>console.log</code> geloggt.\nIn der Konsole erscheint <code>'Ken Thompson'</code>. Das ist der Wert der Variablen <code>informatiker</code>.",task:"Schreibe eine Funktion <code>logge</code>, die einen Parameter entgegennimmt und diesen Parameter loggt.<br><br>\nBeispiel: Der Aufruf <code>logge('Ken Thompson')</code> sollte <code>'Ken Thompson'</code> loggen.",hint:"<pre><code>var logge = function(wert) {\n  ...\n};</code></pre>",solution:"<pre><code>var logge = function(wert) {\n  console.log(wert);\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("logge")},function(){return testutil.assert_functionHasNumOfParameter("logge",1)},function(){return testutil.assert_functionLogs("logge('Ken Thompson')","Ken Thompson")},function(){return testutil.assert_functionLogs("logge('Dennis Ritchie')","Dennis Ritchie")}]})})(jshero.testutil);
jshero.koans.add({id:"math",title:"Math",lesson:"Viele mathematische Funktionen sind in dem Objekt <code>Math</code> zusammengefasst.\nSo gibt <code>Math.sqrt(x)</code> die Quadratwurzel (engl.: square root) zur\xFCck\nund mit <code>Math.pow(x, y)</code> berechnet man die Potenz (engl.: power) x hoch y.\n\n<pre><code>var y1 = Math.sqrt(9);\nvar y2 = Math.pow(10, 3);</code></pre>\n\n<code>y1</code> hat den Wert <code>3</code> und <code>y2</code> den Wert <code>1000</code> (10&sup3; = 10 * 10 * 10 = 1000).",task:"Schreibe eine Funktion <code>hypotenuse</code>, die die L\xE4nge der Hypotenuse eines rechtwinkligen Dreiecks berechnet.\n\xDCbergeben wird der Funktion als Parameter die L\xE4ngen der beiden Katheten.\n<br><br>Tipp: In einem rechtwinkligen Dreieck gilt der Satz des Pythagoras. Sind a, b die L\xE4ngen der beiden\nKatheten und c die L\xE4nge der Hypotenuse, so gilt: a&sup2; + b&sup2; = c&sup2;.\n<br><br>Beispiel: Da 3&sup2; + 4&sup2; = 5&sup2; gilt, sollte <code>hypotenuse(3,&nbsp;4)</code> den Wert <code>5</code> liefern.",hint:"<pre><code>var hypotenuse = function(a, b) {\n  var cQuadrat = Math.pow(a, 2) + Math.pow(b, 2);\n  return ...\n};</code></pre>",solution:"<pre><code>var hypotenuse = function(a, b) {\n  var cQuadrat = Math.pow(a, 2) + Math.pow(b, 2);\n  return Math.sqrt(cQuadrat);\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("hypotenuse")},function(){return jshero.testutil.assert_functionHasNumOfParameter("hypotenuse",2)},function(){return jshero.testutil.assert_functionReturns("hypotenuse(3, 4)",5)},function(){return jshero.testutil.assert_functionReturns("hypotenuse(5, 12)",13)},function(){return jshero.testutil.assert_functionReturns("hypotenuse(1, 1)",Math.sqrt(2))}]});
jshero.koans.add({id:"mean",title:"Klammern",lesson:"Ebenso wie in der Mathematik gilt in JavaScript die Punkt-vor-Strichrechnung. Multiplikation und Division\nwerden vor Addition und Subtraktion ausgef\xFChrt. M\xF6chte man zuerst die Strichrechnung ausf\xFChren, verwendet man genauso\nwie in der Mathematik Klammern.\n\n<pre><code>var x1 = 3 + 4 * 2;\nvar x2 = (3 + 4) * 2;</code></pre>\n\n<code>x1</code> hat den Wert <code>11</code>, der Wert von <code>x2</code> ist <code>14</code>.",task:"Schreibe eine Funktion <code>mittelwert</code>, die zwei Zahlen als Parameter entgegennimmt und deren\nMittelwert zur\xFCckgibt.<br><br>Beispiel: <code>mittelwert(1, 2)</code> sollte <code>1.5</code> ergeben.",hint:"<pre><code>Der Mittelwert zweier Zahlen\nx und y ist (x + y) / 2.</code></pre>",solution:"<pre><code>var mittelwert = function(x, y) {\n  return (x + y) / 2;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("mittelwert")},function(){return jshero.testutil.assert_functionHasNumOfParameter("mittelwert",2)},function(){return jshero.testutil.assert_functionReturns("mittelwert(1, 2)",1.5)},function(){return jshero.testutil.assert_functionReturns("mittelwert(0, 0)",0)},function(){return jshero.testutil.assert_functionReturns("mittelwert(3, -1)",1)}]});
(function(testutil,evaluator){jshero.koans.add({id:"method1",title:"Methoden",lesson:"Bisher waren die Werte von Objekt-Eigenschaften Daten wie Strings oder Zahlen.\nObjekt-Eigenschaften k\xF6nnen aber auch Funktionen sein. Solche Objekt-Eigenschaften nennt man\nMethoden. Methoden operieren auf den Daten eines Objekts.\n\n<pre><code>var ware = {\n  name: '\xC4pfel',\n  preis: 2.15,\n  erhoehePreis: function(erhoehung) {\n    this.preis = this.preis + erhoehung;\n  };\n};\n\nvar alterPreis = ware.preis;\nware.erhoehePreis(0.05);\nvar neuerPreis = ware.preis;</code></pre>\n\nDas Objekt <code>ware</code> besitzt die Methode <code>erhoehePreis</code>. Diese Methode greift mithilfe von\n<code>this</code> auf die Objekt-Eigenschaft <code>preis</code> zu. <code>this</code> steht innerhalb eines Objekts f\xFCr\ndas Objekt selbst. Mit der bekannten Punkt-Notation kann man nun auf die Objekt-Eigenschaften zugreifen und sie\nver\xE4ndern.<br>\nVon au\xDFen wird eine Methode \xFCber die zugeordnete Variable und der Punkt-Notation aufgerufen.",task:"Definiere ein Objekt mit den beiden Eigenschaften <code>x</code> und <code>y</code> sowie einer Methode\n<code>moveX</code>. <code>x</code> und <code>y</code> sollen den Wert <code>0</code> erhalten. <code>moveX</code>\nsoll den Wert von <code>x</code> um <code>1</code> erh\xF6hen. Weise das Objekt einer Variablen <code>point</code> zu.",tests:[function(){return testutil.assert_variableDefined("point")},function(){var out=evaluator.evalTest("point");var ok,msg;if(out===null){ok=false;msg="<code>point</code> ist <code>null</code>."}else if(out.x===0){ok=true;msg="<code>point.x</code> hat den Wert <code>0</code>."}else{ok=false;msg="<code>point.x</code> hat nicht den Wert <code>0</code>, sondern <code>"+out.x+"</code>."}return{ok:ok,msg:msg}},function(){var out=evaluator.evalTest("point");var ok,msg;if(out.y===0){ok=true;msg="<code>point.y</code> hat den Wert <code>0</code>."}else{ok=false;msg="<code>point.y</code> hat nicht den Wert <code>0</code>, sondern <code>"+out.y+"</code>."}return{ok:ok,msg:msg}},function(){return testutil.assert_isFunction("point.moveX")},function(){var out=evaluator.evalTest("point");var ok,msg;out.moveX();if(out.x===1&&out.y===0){ok=true;msg="<code>moveX</code> verschiebt den Punkt von (0, 0) nach (1, 0)."}else{ok=false;msg="<code>moveX</code> verschiebt den Punkt von (0, 0) nicht nach (1, 0), sondern nach ("+out.x+", "+out.y+")."}return{ok:ok,msg:msg}}]})})(jshero.testutil,jshero.evaluator);
jshero.koans.add({id:"minmax",title:"Min und Max",lesson:"Das Minimum und Maximum einer Reihe von Zahlen bestimmt man mit\n<code>Math.min()</code> und <code>Math.max()</code>:\n\n<pre><code>var min = Math.min(5, 7);\nvar max = Math.max(3, 9, 2);</code></pre>\n\n<code>min</code> erh\xE4lt den Wert <code>5</code> und <code>max</code> den Wert <code>9</code>.\nDas Besondere: Beide Funktionen k\xF6nnen mit einer beliebigen Anzahl von Argumenten aufgerufen werden.",task:"Schreibe eine Funktion <code>bereichsmittel</code>, die das Bereichsmittel von 3 Zahlen berechnet.\n<br><br>Tipp: Das <a href='https://de.wikipedia.org/wiki/Mittelwert#Bereichsmittel'>Bereichsmittel</a>\neiner Reihe von Zahlen ist der Mittelwert der kleinsten und gr\xF6\xDFten Zahl.\n<br><br>Beispiel: <code>bereichsmittel(3, 9, 1)</code> sollte <code>(9+1)/2</code> = <code>5</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("bereichsmittel")},function(){return jshero.testutil.assert_functionHasNumOfParameter("bereichsmittel",3)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(3, 9, 1)",5)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(3, 0, 8)",4)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(7, 4, 0)",3.5)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(-6, -5, -2)",-4)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(5, -5, 2)",0)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(10, 20, 17)",15)}]});
jshero.koans.add({id:"modulo",title:"Modulo",lesson:"Ein weiterer arithmetischer Operator ist Modulo. Er berechnet den Rest einer Division und wird mit dem Prozentzeichen <code>%</code> notiert."+"<pre><code>var x = 7 % 2;<br>"+"var y = 20 % 3;</code></pre>"+"7 geteilt durch 2 ergibt 3 Rest 1. <code>x</code> ist also <code>1</code>.<br>"+"20 geteilt durch 3 ergibt 6 Rest 2. <code>y</code> ist also <code>2</code>.",task:"Schreibe eine Funktion <code>einer</code>, die eine nat\xFCrliche Zahl entgegenimmt und die Ziffer der\nEiner-Stelle zur\xFCckgibt.<br><br>Beispiel: <code>einer(2674)</code> sollte <code>4</code> zur\xFCckgeben.",hint:"<pre><code>var einer = function(n) {\n// Benutze Modulo 10.  \n};</code></pre>",solution:"<pre><code>var einer = function(n) {\n  return n % 10;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("einer")},function(){return jshero.testutil.assert_functionHasNumOfParameter("einer",1)},function(){return jshero.testutil.assert_functionReturns("einer(3)",3)},function(){return jshero.testutil.assert_functionReturns("einer(17)",7)},function(){return jshero.testutil.assert_functionReturns("einer(210)",0)},function(){return jshero.testutil.assert_functionReturns("einer(2674)",4)}]});
(function(testutil){jshero.koans.add({id:"nan",title:"NaN",lesson:"<code>NaN</code> repr\xE4sentiert den Wert Not-A-Number (engl.: Keine-Zahl). Numerische Operationen oder\nFunktionen geben <code>NaN</code> zur\xFCck, wenn sie keinen Wert berechnen k\xF6nnen. Wir hatten dies bei\n<code><a href='parseint.html'>parseInt</a></code> kennengelernt. <code>parseInt</code> gibt <code>NaN</code>\nzur\xFCck, wenn es keine Zahl parsen kann. Ein weiteres Beispiel ist die Berechnung der Wurzel aus einer negativen Zahl:\n\n<pre><code>var age = parseInt('Babylon');\nvar length = Math.sqrt(-1);</code></pre>\n\nSowohl <code>age</code> als auch <code>length</code> haben den Wert <code>NaN</code>.<br><br>\nM\xF6chte man testen, ob <code>NaN</code> vorliegt, kann man leider nicht <code>===</code> verwenden.\n<code>NaN</code> ist der einzige Wert in JavaScript, der nicht mit sich selbst gleich ist.\n<code>NaN&nbsp;===&nbsp;NaN</code> ergibt <code>false</code>.\n\nUm auf <code>NaN</code> zu testen, sollte man die Funktion <code>Number.isNaN</code> verwenden:\n\n<pre><code>var input = 'Babylon';\nvar message;\nvar age = parseInt(input);\nif ( Number.isNaN(age) ) {\n  message = 'Du hast keine Zahl eingegeben.';\n}</code></pre>",task:"Schreibe eine Funktion <code>parseFirstInt</code>, die einen String entgegennimmt und die die erste in dem\nString vorkommende ganze Zahl zur\xFCckgibt. Enth\xE4lt der String keine ganze Zahl, soll man <code>NaN</code> erhalten.\n<code>parseFirstInt('Sonnebornstr. 27')</code> sollte <code>27</code>\nzur\xFCckgeben. <code>parseFirstInt('Babylon')</code> sollte <code>NaN</code> ergeben.",tests:[function(){return testutil.assert_isFunction("parseFirstInt")},function(){return testutil.assert_functionHasNumOfParameter("parseFirstInt",1)},function(){return testutil.assert_functionReturns("parseFirstInt('Sonnebornstr. 2')",2)},function(){return testutil.assert_functionReturns("parseFirstInt('28.12.05')",28)},function(){return testutil.assert_functionReturns("parseFirstInt('Willi ist 22 Jahre alt.')",22)},function(){return testutil.assert_functionReturns("parseFirstInt('Temperatur: -12 Grad')",-12)},function(){return testutil.assert_functionReturns("parseFirstInt('Ohne Zahl')",NaN)}]})})(jshero.testutil);
jshero.koans.add({id:"nor",title:"NOR",lesson:"In der letzten Aufgabe hast du ein sogenanntes NAND-Gatter (engl.: Not AND - nicht und) programmiert.\nNAND-Gatter sind in der Digitaltechnik ein sogenannter Standardbaustein.\nMit ihm lassen sich alle logischen Verkn\xFCpfungen zusammenstellen.\nHier sollst du einen weiteren Standardbaustein, das NOR-Gatter (engl.: Not OR - nicht oder), kennen lernen.",task:"Schreibe eine Funktion <code>nor</code>, die zwei boolesche Werte als Parameter entgegennimmt.\nDie R\xFCckgabe der Funktion soll genau dann <code>true</code> sein, wenn beide Paramter <code>false</code> sind.\nIn den anderen F\xE4llen soll die R\xFCckgabe <code>false</code> sein.<br><br>D. h.: <code>nor(false, false)</code> soll\n<code>true</code> liefern, <code>nor(false, true)</code>, <code>nor(true, false)</code> und <code>nor(true, true)</code>\nsollen <code>false</code> zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("nor")},function(){return jshero.testutil.assert_functionHasNumOfParameter("nor",2)},function(){return jshero.testutil.assert_functionReturns("nor(false, false)",true)},function(){return jshero.testutil.assert_functionReturns("nor(false, true)",false)},function(){return jshero.testutil.assert_functionReturns("nor(true, false)",false)},function(){return jshero.testutil.assert_functionReturns("nor(true, true)",false)}]});
jshero.koans.add({id:"notequals",title:"Strikte Ungleichtheit",lesson:"Mit <code>!==</code> vergleicht man zwei Werte auf strikte Ungleichheit.\n\n<pre><code>var v1 = 'lauf' !== 'Lauf';\nvar v2 = 10 !== '10';</code></pre>\n\nBeide Vergleiche ergeben <code>true</code>. Der erste, weil sich die beiden\nStrings in der Gro\xDF- und Kleinschreibung unterscheiden.\nDer zweite, weil sich die beiden Werte von Typ her unterscheiden.",task:"Schreibe eine Funktion <code>ungleich</code>, die 3 Werte auf strikte Ungleichheit \xFCberpr\xFCft.\nDie Funktion soll nur dann <code>true</code> ergeben, wenn alle drei Parameter unterschiedlich sind.<br><br>Beispiel:\n<code>ungleich(1, 2, 3)</code> soll <code>true</code> liefern, <code>ungleich(1, 1, 2)</code> soll\n<code>false</code> ergeben.",hint:"<pre><code>var ungleich = function (a, b, c) {\n  return a !== b && ...\n};</code></pre>",solution:"<pre><code>var ungleich = function (a, b, c) {\n  return a !== b && a !== c && b !== c;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("ungleich")},function(){return jshero.testutil.assert_functionHasNumOfParameter("ungleich",3)},function(){return jshero.testutil.assert_functionReturns("ungleich(1, 2, 3)",true)},function(){return jshero.testutil.assert_functionReturns("ungleich(1, 2, 1)",false)},function(){return jshero.testutil.assert_functionReturns("ungleich(2, 1, 1)",false)},function(){return jshero.testutil.assert_functionReturns("ungleich('2', 2, 2)",false)},function(){return jshero.testutil.assert_functionReturns("ungleich('kLein', 'klein', 'kleiN')",true)},function(){return jshero.testutil.assert_functionReturns("ungleich('1', 1, true)",true)},function(){return jshero.testutil.assert_functionReturns("ungleich('klein', 'klein', 'kIein')",false)}]});
jshero.koans.add({id:"null",title:"null",lesson:"Neben <code>undefined</code> kennt JavaScript einen weiteren Wert f\xFCr die Abwesentheit eines sinnvollen\nWerts: <code>null</code>. Man kann einer Variablen den Wert <code>null</code> zuordnen und testet mit strikter\nGleichheit auf diesen Wert:\n\n<pre><code>var foo = null;\nif (foo === null) {\n  foo = 1;\n}</code></pre>\n\nEs ist ein Design-Fehler, dass JavaScript zwei Werte f\xFCr \"kein Wert\" besitzt. Wenn m\xF6glich, sollte man\n<code>undefined</code> und <code>null</code> gleich behandeln.",task:"Schreibe eine Funktion <code>cutComment</code>, die eine Zeile JavaScript entgegennimmt\nund einen m\xF6glichen Zeilenkommentar getrimmt zur\xFCckgibt. Enth\xE4lt die Zeile keinen Kommentar, soll <code>null</code>\nzur\xFCckgegeben werden. <code>cutCommt('var i; // Laufvariable')</code> sollte <code>'Laufvariable'</code> zur\xFCckgeben.\nEin\xADfach\xADheits\xADhal\xADber gehen wir davon aus, dass der Code kein Kommentar-Zeichen innerhalb eines Strings enth\xE4lt.",tests:[function(){return jshero.testutil.assert_isFunction("cutComment")},function(){return jshero.testutil.assert_functionHasNumOfParameter("cutComment",1)},function(){return jshero.testutil.assert_functionReturns("cutComment('var i; // Laufvariable')","Laufvariable")},function(){return jshero.testutil.assert_functionReturns("cutComment('var n; // Number')","Number")},function(){return jshero.testutil.assert_functionReturns("cutComment('var i;')",null)}]});
jshero.koans.add({id:"number",title:"Zahlen",lesson:"Zahlen werden in JavaScript durch einfache Ziffern dargestellt. Sie k\xF6nnen einen\nDezimalpunkt und ein Minuszeichen besitzen.\n\n<pre><code>var x1 = 1;\nvar x2 = 1.0;\nvar x3 = 3.14;\nvar x4 = -1;</code></pre>\n\n<code>1</code> und <code>1.0</code> sind dieselbe Zahl. Mit Zahlen kann man rechnen. Die\nvier Grundrechenarten Addieren, Subtrahieren, Multiplizieren und Dividieren werden durch\n<code>+ - *</code> und <code>/</code> dargestellt.\n\n<pre><code>var x1 = 6;\nvar x2 = 2;\nvar x3 = x1 + x2;\nvar x4 = x1 - x2;\nvar x5 = x1 * x2;\nvar x6 = x1 / x2;</code></pre>\n\nDie Variablen <code>x3</code> bis <code>x6</code> haben so die Werte <code>8</code>,\n<code>4</code>, <code>12</code> und <code>3</code>.",task:"Schreibe eine Funktion <code>add</code>, die zwei Zahlen als Parameter entgegennimmt\nund deren Summe zur\xFCckgibt.<br><br>Beispiel: <code>add(1, 2)</code> sollte <code>3</code> ergeben.",hint:"<pre><code>var add = function(x, y) {\n  return ...\n};</code></pre>",solution:"<pre><code>var add = function(x, y) {\n  return x + y;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("add")},function(){return jshero.testutil.assert_functionHasNumOfParameter("add",2)},function(){return jshero.testutil.assert_functionReturns("add(0, 0)",0)},function(){return jshero.testutil.assert_functionReturns("add(2, 3)",5)},function(){return jshero.testutil.assert_functionReturns("add(-1, 3)",2)}]});
jshero.koans.add({id:"numbertostring",title:"Number: toString()",lesson:"Die Number-Methode <code>toString</code> wandelt eine Zahl in den entsprechenden String um.\nDer Dezimalpunkt wird dabei als Punkt dargestellt. Das kann man z.B. dazu verwenden, eine Zahl im deutschen Format,\nalso mit Komma als Dezimalpunkt, auszugeben:\n\n<code><pre>var number = 7.25;\nvar numberInEnglish = number.toString();\nvar numberInGerman = numberInEnglish.replace('.', ',');</code></pre>\n\n<code>numberInEnglish</code> enth\xE4lt den String <code>'7.25'</code>. Da wir jetzt unsere Zahl als String vorliegen haben,\nk\xF6nnen wir auf ihr die String-Methode <code>replace</code> anwenden. <code>numberInGerman</code> enth\xE4lt so den String\n<code>'7,25'</code>.",task:"Schreibe eine Funktion <code>digitLength</code>, die die Anzahl der Ziffern einer nat\xFCrlichen Zahl berechnet.\n<br><br>Beispiel: <code>digitLength(709)</code> sollte 3 zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("digitLength")},function(){return jshero.testutil.assert_functionHasNumOfParameter("digitLength",1)},function(){return jshero.testutil.assert_functionReturns("digitLength(1)",1)},function(){return jshero.testutil.assert_functionReturns("digitLength(709)",3)},function(){return jshero.testutil.assert_functionReturns("digitLength(123456)",6)}]});
(function(testutil){jshero.koans.add({id:"object1",title:"Objekte",lesson:"Um komplexere Sachverhalte abzubilden, verwendet man Objekte. Eine Person hat einen Namen und ein Alter.\nDiese beiden Daten k\xF6nnte man in zwei Variablen speichern. Besser ist es, daf\xFCr ein Objekt zu benutzen.\nObjekte in JavaScript sind eine Sammlung von Eigenschaften. Jede Eigenschaft besteht aus einem Namen und ihrem Wert.\nObjekte werden am einfachsten mit der Mengenklammer erzeugt:\n\n<pre><code>var person = {\n  name: 'Toni Morrison',\n  alter: 88\n};</code></pre>\n\nHier haben wir ein Objekt mit den beiden Eigenschaften <code>name</code> und <code>alter</code> erzeugt.\nDas Objekt wurde der Variablen <code>person</code> zugewiesen.\nAuf dem Namen einer Eigenschaft folgt ein Doppelpunkt und anschlie\xDFend ihr Wert.\nDie Eigenschaft <code>name</code> hat den Wert <code>'Toni Morrison'</code> und die Eigenschaft <code>alter</code>\nden Wert <code>52</code>. Jede Eigenschaft wird mit einem Komma beendet. Bei der letzten Eigenschaft wird das\nKomma weglassen. Man kann alle Eigenschaften zusammen mit ihren Werten in einer Zeile notieren.\n\xDCbersichtlicher ist es, wenn man wie hier f\xFCr jede Eigenschaft eine neue Zeile verwendet.<br><br>\nMit der folgenden Aufgabe wollen wir einen Punkt in einer Ebene modellieren.\nDieser Punkt k\xF6nnte zum Beispiel die Position einer Figur in einem 2-dimensionalen Computerspiel sein.",task:"Erzeuge ein Objekt mit den beiden Eigenschaften <code>x</code> und <code>y</code>.\n<code>x</code> soll den Wert <code>1</code> und <code>y</code> den Wert <code>2</code> erhalten.\nWeise das Objekt der Variablen <code>point</code> zu.",hint:"<pre><code>var point = {\n  ...\n};</code></pre>",solution:"<pre><code>var point = {\n  x: 1,\n  y: 2\n};</code></pre>",tests:[function(){return testutil.assert_variableDefined("point")},function(){return testutil.assert_variableIsObject("point",{x:1,y:2})}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"object2",title:"Objekte erzeugen",lesson:"Die Werte von Objekt-Eigenschaften kann man auch mithilfe von Variablen festlegen:\n\n<pre><code>var title = 'Clean Code';\nvar author = 'Robert C. Martin';\nvar book = {\n  title: title,\n  author: author\n};</code></pre>\n\nHier wird ein Objekt mit den Eigenschaften <code>title</code> und <code>author</code> erzeugt.\n<code>title</code> erh\xE4lt den Wert <code>'Clean Code'</code> und <code>author</code> den Wert\n<code>'Robert C. Martin'</code>.\nIn der Zeile <code>title: title</code> ist <code>title</code> vor dem Doppelpunkt die Objekt-Eigenschaft\nund nach dem Doppelpunkt die zuvor definierte Variable.",task:"Schreibe eine Funktion <code>createPoint</code>, die die Koordinaten eines Punkts in der Ebene\nentgegennimmt und ein Objekt mit den Eigenschaften x und y sowie den \xFCbergebenen Koordinaten zur\xFCckgibt.\n<code>createPoint(1,&nbsp;2)</code> sollte <code>{x:&nbsp;1,&nbsp;y:&nbsp;2}</code> zur\xFCckgeben.",hint:"<pre><code>var createPoint = function(x, y) {\n  return ...\n};</code></pre>",solution:"<pre><code>var createPoint = function(x, y) {\n  return {\n    x: x,\n    y: y\n  };\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("createPoint")},function(){return testutil.assert_functionHasNumOfParameter("createPoint",2)},function(){return testutil.assert_functionReturnsObject("createPoint(1, 2)",{x:1,y:2})},function(){return testutil.assert_functionReturnsObject("createPoint(-5, 18)",{x:-5,y:18})}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"object3",title:"Eigenschaften auslesen",lesson:"Auf Objekt-Eigenschaften kann man mit der Punkt-Notation zugreifen:\n\n<pre><code>var person = {\n  name: 'Constanze Kurz',\n  geburtstag: new Date(1974, 2, 2),\n  geburtsort: 'Ost-Berlin'\n};\n\nvar pName = person.name;\nvar pGeburtstag = person.geburtstag;\nvar pGeburtsort = person.geburtsort;</code></pre>\n\nDie drei Eigenschaften des Objekts <code>person</code> werden in drei Variablen gespeichert.",task:"Schreibe eine Funktion <code>distance</code>, die den Abstand eines Punkts zum Nullpunkt berechnet.\nHier und im Folgenden ist ein Punkt ein Objekt mit den Eigenschaften x und y.\n<code>distance({x:&nbsp3,&nbspy:&nbsp;4})</code> sollte <code>5</code> zur\xFCckgeben.",hint:"Der Abstand eines  Punkts mit den Koordinaten x und y zum Nullpunkt ist &radic;(x&sup2;&nbsp;+&nbsp;y&sup2;).",solution:"<pre><code>var distance = function(point) {\n  var xSquare = Math.pow(point.x, 2);\n  var ySquare = Math.pow(point.y, 2);\n  return Math.sqrt(xSquare + ySquare);\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("distance")},function(){return testutil.assert_functionHasNumOfParameter("distance",1)},function(){return testutil.assert_functionReturns("distance({x: 2, y: 0})",2)},function(){return testutil.assert_functionReturns("distance({x: 0, y: -3})",3)},function(){return testutil.assert_functionReturns("distance({x: 3, y: 4})",5)}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"object4",title:"Eigenschaften setzen",lesson:"Um Objekt-Eigenschaften zu \xE4ndern, verwendet man ebenfalls die Punkt-Notation:\n\n<pre><code>var ware = {\n  name: '\xC4pfel',\n  preis: 2.15\n};\n\n// irgendwann sp\xE4ter\nware.preis = 2.25;</code></pre>\n\nZun\xE4chst legen wir eine Ware mit dem Preis <code>2.15</code> an. Irgendwann sp\xE4ter wird dieser Preis auf\n<code>2.25</code> erh\xF6ht.",task:"Schreibe eine Funktion <code>moveX</code>, die einen Punkt um 1 nach rechts verschiebt.\n<code>moveX({x:&nbsp;2,&nbsp;y:&nbsp;5})</code> sollte <code>{x:&nbsp;3,&nbsp;y:&nbsp;5}</code> zur\xFCckgeben.",hint:"<pre><code>var moveX = function(point) {\n  ...\n  return point;\n};</code></pre>",solution:"<pre><code>var moveX = function(point) {\n  point.x = point.x + 1;\n  return point;\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("moveX")},function(){return testutil.assert_functionHasNumOfParameter("moveX",1)},function(){return testutil.assert_functionReturnsObject("moveX({x: 2, y: 0})",{x:3,y:0})},function(){return testutil.assert_functionReturnsObject("moveX({x: 3, y: 5})",{x:4,y:5})}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"parameter",title:"Parameter",lesson:"Jetzt lernen wir Funktionen mit Parametern kennen. Mit\n\n  <pre><code>var gebe = function(eingabe) {\n  return eingabe;\n};</code></pre>\n\ndefinieren wir eine Funktion, die den \xFCbergebenen Parameter <code>eingabe</code> einfach wieder zur\xFCckgibt.\nParameter sind Variablen. Sie stehen in der runden Klammer und ben\xF6tigen nicht das Schl\xFCsselwort <code>var</code> zu\nihrer Deklaration. Mit\n\n<pre><code>var ergebnis = gebe('Apfel');</code></pre>\n\nwird die Funktion mit dem Argument <code>'Apfel'</code> aufgerufen. Jetzt wird unsere zuvor definierte Funktion\nausgef\xFChrt. Dabei wird zun\xE4chst das Argument <code>'Apfel'</code> dem Parameter <code>eingabe</code> zugewiesen.\n<code>eingabe</code> hat jetzt den Wert <code>'Apfel'</code>. In der einzigen Codezeile der Funktion wird nun die\nVariable <code>eingabe</code> mit der <code>return</code>-Anweisung zur\xFCckgegeben. Diese R\xFCckgabe wird der Variablen\n<code>ergebnis</code> zugewiesen. <code>ergebnis</code> hat dann auch den Wert <code>'Apfel'</code>.",task:"Schreibe eine Funktion <code>echo</code>, die ebenfalls den \xFCbergebenen Parameter wieder zur\xFCckgibt.",hint:"<pre><code>var echo = function(ton) {\n  ...\n};</code></pre>",solution:"<pre><code>var echo = function(ton) {\n  return ton;\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("echo")},function(){return testutil.assert_functionHasNumOfParameter("echo",1)},function(){return testutil.assert_functionReturns("echo('Greta')","Greta")},function(){return testutil.assert_functionReturns("echo('CO2')","CO2")}]})})(jshero.testutil);
jshero.koans.add({id:"parameter2a",title:"Parameternamen",lesson:"Bitte achte darauf, dass du eventuelle Parameter deiner Funktion anders nennst als die Funktion selbst.\nDie Funktion <code>f1</code> zum Beispiel\n\n<pre><code>var f1 = function(f1) {\n  return f1;\n};</code></pre>\n\nmacht das gleiche wie diese Funktion:\n\n<pre><code>var f2 = function(eingabe) {\n  return eingabe;\n};</code></pre>\n\nDie zweite Funktionsdefinition ist aber besser, weil der Parameter <code>eingabe</code> hei\xDFt\nund damit anders als die Funktion selbst.",task:"Schreibe eine Funktion <code>ping</code>, die einen Parameter hat und dessen Wert einfach zur\xFCckgibt.\nAchte darauf, dass der Parameter anders hei\xDFt, als die Funktion selbst.",tests:[function(){return jshero.testutil.assert_isFunction("ping")},function(){return jshero.testutil.assert_functionHasNumOfParameter("ping",1)},function(){return jshero.testutil.assert_functionReturns("ping('Test')","Test")},function(){return jshero.testutil.assert_functionReturns("ping('Hallo Welt!')","Hallo Welt!")}]});
jshero.koans.add({id:"parseint",title:"parseInt",lesson:"H\xE4ufig m\xF6chte man eine Zahl, die als String vorliegt, in eine Zahl vom Typ Number umwandeln.\nF\xFCr das Umwandeln von ganzen Zahlen (..., -2, -1, 0, 1, 2, ..) gibt es in JavaScript die Funktion <code>parseInt</code>.\nFolgende Beispiele geben <code>19</code> oder <code>-19</code> zur\xFCck:\n<pre><code>var n1 = parseInt('19', 10);\nvar n2 = parseInt('+19', 10);\nvar n3 = parseInt('-19', 10);\nvar n4 = parseInt('19 Grad', 10);\nvar n5 = parseInt('19.1', 10);\nvar n6 = parseInt('019', 10);\nvar n7 = parseInt(' 19', 10);</code></pre>\nNeben dem direkten Einlesen von ganzen Zahlen mit oder ohne Vorzeichen (n1, n2, n3) beherrscht <code>parseInt</code>\nauch einige komplexe F\xE4lle. Nicht-numerische Zeichen nach der ganzen Zahl (n4, n5) sowie Nullen (n6) und\nLeerzeichen (n7) vor der Zahl werden ignoriert.<br><br>\nIn allen Beispielen ist der zweite an <code>parseInt</code> \xFCbergebene Parameter <code>10</code>.\nDieser Paramter gibt an, zu welcher Basis die Zahl interpretiert werden soll. <code>10</code> steht f\xFCr das\n\xFCbliche Dezimalsystem. L\xE4\xDFt man den zweiten Paramter weg, wird normalerweise das Dezimalsystem als Default verwendet.\nDa es aber von dieser Regel Ausnahmen gibt und diese Ausnahmen in verschiedenen Browsern auch noch unterschiedlich\ngehandhabt werden, sollte man immer die Basis mit angeben!\n<br><br>\nKann <code>parseInt</code> keine Zahl einlesen, gibt sie den Wert <code>NaN</code> (engl.: Not a Number) zur\xFCck:\n<pre><code>var n1 = parseInt('Nur Text', 10);\nvar n2 = parseInt('Nr. 8', 10);</code></pre>\nIm ersten Fall ist \xFCberhaupt keine Zahl vorhanden. Im zweiten Fall gibt es nicht-numerische Zeichen vor der\neigentlichen Zahl. Auch das ist nicht zul\xE4ssig und f\xFChrt zur R\xFCckgabe <code>NaN</code>.\n<br><br>\nEine ausf\xFChrliche Dokumentation von <code>parseInt</code> findest du bei\n<a href='https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/parseInt'>Mozilla web docs</a>.",task:"Schreibe eine Funktion <code>add</code>, die einen String mit einer Additionsaufgabe entgegennimmt und die das\nErgebnis der Addition als Zahl zur\xFCckgibt. Es sollen zwei nat\xFCrliche Zahlen addiert werden. Die Additionsaufgabe ist\nein String der Form <code>'102+17'</code>.\n<br><br>Beispiel: Der Aufruf <code>add('102+17')</code> soll die Zahl <code>119</code> zur\xFCckgeben.",hint:"Bestimme mit <code>parseInt</code> den ersten Summanden.\nBestimme mit <code>indexOf</code> die Position des Plus-Zeichens.\nBestimme mit <code>substring</code> den Teilstring nach dem Plus-Zeichen.\nBestimme mit <code>parseInt</code> aus diesem Teilstring den zweiten Summanden.",solution:"<pre><code>var add = function(s) {\n  var summand1 = parseInt(s, 10);\n  var positionPlus = s.indexOf('+');\n  var sNachPlus = s.substring(positionPlus + 1);\n  var summand2 = parseInt(sNachPlus, 10);\n  return summand1 + summand2;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("add")},function(){return jshero.testutil.assert_functionHasNumOfParameter("add",1)},function(){return jshero.testutil.assert_functionReturns("add('1+2')",3)},function(){return jshero.testutil.assert_functionReturns("add('10+100')",110)},function(){return jshero.testutil.assert_functionReturns("add('100123+456')",100579)}]});
jshero.koans.add({id:"pi",title:"Math.PI",lesson:"Neben Funktionen bietet <code>Math</code> auch einige mathematische Konstanten an.\n<code>Math.PI</code> liefert die Kreiszahl &pi; (gerundet 3.14) und <code>Math.E</code> die Eulersche Zahl e (gerundet 2.71).\nBeachte: Die Konstanten werden im Gegensatz zu Funktionen ohne anschlie\xDFende Klammern aufgerufen.",task:"Schreibe eine Funktion <code>flaeche</code>, die die Fl\xE4che eines Kreises berechnet.\n\xDCbergeben wird der Funktion als Parameter der Radius des Kreises.\n<br><br>Tipp: Die Fl\xE4che eines Kreises ist &pi; * r&sup2;. Dabei ist r der Radius des Kreises.",tests:[function(){return jshero.testutil.assert_isFunction("flaeche")},function(){return jshero.testutil.assert_functionHasNumOfParameter("flaeche",1)},function(){return jshero.testutil.assert_functionReturns("flaeche(4)",Math.PI*4*4)},function(){return jshero.testutil.assert_functionReturns("flaeche(1)",Math.PI)},function(){return jshero.testutil.assert_functionReturns("flaeche(0)",0)}]});
(function(testutil,evaluator){var evalDice=function(){return evaluator.evalTest("dice()")};var isOneToSix=function(x){return x===1||x===2||x===3||x===4||x===5||x===6};var throwA=function(x){var result;for(var i=0;i<1000;i++){result=evalDice();if(result===x){return true}}return false};var testWith=function(x){var ok,msg,e;try{ok=throwA(x);if(ok){msg="<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>"+x+"</code> zur\xFCck."}else{msg="<code>dice()</code> gab bei 1000 Aufrufen keine <code>"+x+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>dice()</code>.";e=exc}return{ok:ok,msg:msg,e:e}};jshero.koans.add({id:"random",title:"Zufallszahlen",lesson:"Mit <code>Math.random()</code> erzeugt man eine Pseudozufallszahl zwischen 0 (inklusive) und 1 (exklusive).\n\n<pre><code>var x = Math.random();</code></pre>\n\n<code>x</code> k\xF6nnte z.B. den Wert <code>0.6206372241429993</code> erhalten.\nJeder Aufruf von <code>Math.random()</code> generiert eine neue Pseudozufallszahl.\nDie Zahlen sind zwischen 0 und 1 gleichverteilt. Sie hei\xDFen Pseudozufallszahlen,\nweil sie zuf\xE4llig aussehen, aber dennoch berechnet werden.\nM\xF6chte man Zufallszahlen in einem anderen Wertebereich oder mit einer anderen Verteilung erhalten,\nmuss man die von <code>Math.random()</code> generierten Zahlen\ngeeignet umrechnen. Das soll jetzt gleich ge\xFCbt werden.",task:"Schreibe eine Funktion <code>dice</code>, die wie ein W\xFCrfel eine Zufallszahl zwischen 1 und 6 zur\xFCckgibt.",tests:[function(){return testutil.assert_isFunction("dice")},function(){return testutil.assert_functionHasNumOfParameter("dice",0)},function(){var ok,msg,e;try{ok=true;var result;for(var i=0;i<1000;i++){result=evalDice();if(!isOneToSix(result)){ok=false;break}}if(ok){msg="<code>dice()</code> gab bei 1000 Aufrufen nur nat\xFCrliche Zahlen zwischen <code>1</code> und <code>6</code> zur\xFCck."}else{msg="<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>"+JSON.stringify(result)+"</code> zur\xFCck. Dies ist keine nat\xFCrliche Zahl zwischen <code>1</code> und <code>6</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>dice()</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){return testWith(1)},function(){return testWith(2)},function(){return testWith(3)},function(){return testWith(4)},function(){return testWith(5)},function(){return testWith(6)}]})})(jshero.testutil,jshero.evaluator);
(function(testutil,evaluator){jshero.koans.add({id:"recursion",title:"Rekursion",lesson:"Funktionen k\xF6nnen sich auch selbst aufrufen. Das nennt man <a href='https://de.wikipedia.org/wiki/Rekursive_Programmierung'>Rekursion</a>.\nDas bekannteste Beispiel ist die Berechnung der Fakult\xE4t:\n\n<pre><code>var fakultaet = function(n) {\n  if (n === 0) {\n    return 1;\n  }\n  return fakultaet(n - 1) * n;\n};</code></pre>\n\nDie <a href='https://de.wikipedia.org/wiki/Fakult%C3%A4t_(Mathematik)'>Fakult\xE4t</a> einer nat\xFCrlichen Zahl ist das Produkt aller\nnat\xFCrlichen Zahlen (ohne Null) kleiner oder gleich dieser Zahl. Sie wird durch ein nachgestelltes Ausrufezeichen abgek\xFCrzt:\nn! = 1 * 2 * 3 ... (n-1) * n. Man sieht, dass man f\xFCr die Berechnung der Fakult\xE4t von n die Fakult\xE4t von n-1 benutzen kann: n! = (n-1)! * n.\nDas Beispielprogramm ist die Umsetzung dieser Formel. Um die Fakult\xE4t von n zu berechnen, muss man die Fakult\xE4t von n-1 berechnen und\ndas Ergebnis mit n multiplizieren. So ruft sich die Funktion <code>fakultaet</code> immer wieder selbst mit einem um 1 verminderten Wert auf.\nNun ben\xF6tigt man noch eine Abbruchbedingung, damit die Rekursion nicht unendlich weiterl\xE4uft. Diese Abbruchbedingung ist mit der\n<code>if</code>-Bedingung formuliert. Ist n bei 0 angekommen, ruft sich <code>fakultaet</code> nicht mehr selbst auf,\nsondern das Ergebnis, n\xE4mlich 0! = 1, wird direkt zur\xFCckgegeben.",task:"Schreibe eine Funktion <code>reverse</code>, die die Reihenfolge der Zeichen in einem String umkehrt.\n<code>reverse('Nebel')</code> sollte <code>'lebeN'</code> zur\xFCckgeben. Die Funktion sollte rekursiv sein.",tests:[function(){return testutil.assert_isFunction("reverse")},function(){return testutil.assert_functionHasNumOfParameter("reverse",1)},function(){return testutil.assert_functionReturns("reverse('')","")},function(){return testutil.assert_functionReturns("reverse('X')","X")},function(){return testutil.assert_functionReturns("reverse('az')","za")},function(){return testutil.assert_functionReturns("reverse('Nebel')","lebeN")}]})})(jshero.testutil,jshero.evaluator);
(function(testutil){jshero.koans.add({id:"regex1",title:"Regex: Zeichenliterale",lesson:"<a href='https://de.wikipedia.org/wiki/Regul%C3%A4rer_Ausdruck'>Regul\xE4re Ausdr\xFCcke</a>,\nkurz Regex (engl.: regular expression), sind Muster zum Beschreiben von Zeichenketten.\nSie bilden eine kleine, eigenst\xE4ndige Sprache, die Teil von JavaScript\nund vielen weiteren Sprachen (Python, Perl, ...) und Programmen (LibreOffice, Emacs, ...) ist.\nRegul\xE4re Ausdr\xFCcke sind leistungsstark, aber auch sehr kryptisch.\n<br><br>\nIn JavaScript werden regul\xE4re Ausdr\xFCcke zwischen Schr\xE4gstrichen notiert:\n\n<pre><code>var pruefeAufOF = /OF/;</code></pre>\n\nHier ist <code>OF</code> der regul\xE4rer Ausdruck. Es ist ein sogenanntes Zeichenliteral und steht f\xFCr sich selbst.\nMit ihm kann man testen, ob ein anderer String die Zeichenfolge <code>OF</code> enth\xE4lt:\n\n<pre><code>var t1 = /OF/.test('OF-C 79');\nvar t2 = /OF/.test('B-OF 61')\nvar t3 = /OF/.test('HB-F 42');\nvar t4 = /OF/.test('Ofen');</code></pre>\n\n<code>test()</code> ist eine Regex-Methode. Sie gibt <code>true</code> zur\xFCck, wenn\nder ihr \xFCbergebene String das durch den Regex beschriebene Muster enth\xE4lt.\nIn unserem Fall ist das Muster die Zeichenfolge <code>OF</code>. <code>'OF-C 79'</code> und\n<code>'B-OF 61'</code> enthalten <code>OF</code>, also erhalten <code>t1</code> und <code>t2</code>\nden Wert <code>true</code>. Der String <code>'HB-F 42'</code> enth\xE4lt nicht <code>OF</code>.\n<code>t3</code> ist <code>false</code>.\n<br>\nRegul\xE4re Ausdr\xFCcke unterscheiden zwischen Gro\xDF- und Kleinschreibung.\n<code>'Ofen'</code> enth\xE4lt zwar <code>Of</code>, aber nicht <code>OF</code>.\n<code>t4</code> ist <code>false</code>.",task:"Schreibe eine Funktion <code>enthaeltRose</code>, die pr\xFCft, ob ein String den Teilstring\n<code>'Rose'</code> enth\xE4lt. <code>enthaeltRose('eine Rose')</code> sollte <code>true</code> und\n<code>enthaeltRose('ein Blatt')</code> sollte <code>false</code> ergeben.",hint:"<pre><code>Benutze den Regex /Rose/.</pre></code>",solution:"<pre><code>var enthaeltRose = function(s) {\n  return /Rose/.test(s);\n};</pre></code>",tests:[function(){return testutil.assert_isFunction("enthaeltRose")},function(){return testutil.assert_functionHasNumOfParameter("enthaeltRose",1)},function(){return testutil.assert_functionReturns("enthaeltRose('eine Rose')",true)},function(){return testutil.assert_functionReturns("enthaeltRose('zwei Rosen')",true)},function(){return testutil.assert_functionReturns("enthaeltRose('ein Blatt')",false)},function(){return testutil.assert_functionReturns("enthaeltRose('zwei Bl\xE4tter')",false)}]})})(jshero.testutil);
jshero.koans.add({id:"regex2",title:"Regex: Beliebiges Zeichen",lesson:"Neben einfachen Zeichenliteralen kennen regul\xE4re Ausdr\xFCcke eine\nReihe von Zeichen mit besonderer Bedeutung, sogenannte Metazeichen.\nEin solches Metazeichen ist der Punkt. Er steht f\xFCr genau ein beliebiges Zeichen ausgenommen den Zeilenumbruch: \n\n<pre><code>var t1 = /M.ier/.test('Maier');\nvar t2 = /M.ier/.test('Meierei');\nvar t3 = /M.ier/.test('Baier');\nvar t4 = /M.ier/.test('Mier');\nvar t5 = /M.ier/.test('M-ier');</code></pre>\n\nDer regul\xE4rer Ausdruck <code>/M.ier/</code> steht f\xFCr alle Zeichenketten, die mit\n<code>M</code> beginnen, ein beliebiges zweites Zeichen besitzen und anschlie\xDFend mit\n<code>ier</code> enden. Damit k\xF6nnen wir testen, ob ein String <code>Maier</code> oder\n<code>Meier</code> enth\xE4lt. Das ist in den ersten beiden Beispielzeilen der Fall.\n<code>t1</code> und <code>t2</code> sind <code>true</code>. Der String <code>'Baier'</code> enth\xE4lt\nkein Pattern, dass mit <code>M</code> beginnt. <code>t3</code> ist <code>false</code>.\nAuch <code>t4</code> ist <code>false</code>, da zwischen <code>M</code> und <code>ier</code>\ngenau ein Zeichen liegen muss. Das ist hier nicht der Fall. Da der Punkt f\xFCr jedes beliebige Zeichen\nsteht, trifft <code>'M-ier'</code> auch auf unser Pattern zu. <code>t5</code> ist <code>true</code>.\n<br><br>\nDer Punkt kann auch mehrmals in einem Pattern verwendet werden.\n<code>/H..s/</code> steht f\xFCr alle Zeichenketten, die mit <code>H</code> beginnen, anschlie\xDFend\nzwei beliebige Zeichen besitzen und mit <code>s</code> enden. <code>Hans</code> und <code>Haus</code>\ntreffen auf dieses Pattern zu, <code>His</code> und <code>Heros</code> nicht.",task:"Schreibe eine Funktion <code>pruefe</code>, die feststellt, ob ein String zwei in\ndoppelte Anf\xFChrungszeichen eingeschlossene Zeichen besitzt.  \n<code>pruefe('\"Wo\"')</code> sollte <code>true</code> und\n<code>pruefe('\"Was\"')</code> sollte <code>false</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("pruefe")},function(){return jshero.testutil.assert_functionHasNumOfParameter("pruefe",1)},function(){return jshero.testutil.assert_functionReturns("pruefe('\"Ja\"')",true)},function(){return jshero.testutil.assert_functionReturns("pruefe('-\"Oh\"-')",true)},function(){return jshero.testutil.assert_functionReturns("pruefe('\"A\"')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('\"Was\"')",false)}]});
jshero.koans.add({id:"regex3",title:"Regex: Zeichenauswahl",lesson:"Die letzte Lektion f\xFChrte als Metazeichen den Punkt ein.\nEr steht f\xFCr ein beliebiges Zeichen. So steht <code>/M.ier/</code> sowohl f\xFCr <code>Maier</code>\nals auch f\xFCr <code>Meier</code>. Er steht aber auch f\xFCr <code>Mxier</code>.\nM\xF6chte man letzteres ausschlie\xDFen, so muss man die Zeichenauswahl auf <code>a</code>\nund <code>e</code> begrenzen. Dazu schreibt man die gew\xFCnschte Auswahl in eckige Klammern:\n\n<pre><code>var var t1 = /M[ae]ier/.test('Maier');\nvar t2 = /M[ae]ier/.test('Meier');\nvar t3 = /M[ae]ier/.test('Mxier');\nvar t4 = /M[ae]ier/.test('Maeier');</code></pre>\n\nDer Ausdruck in eckigen Klammern steht f\xFCr genau ein Zeichen aus diesem Ausdruck.\n<code>/[ae]/</code> steht also f\xFCr ein Zeichen, das ein <code>a</code> oder ein <code>e</code> ist.\n<code>/M[ae]ier/</code> steht dann f\xFCr <code>Maier</code> oder <code>Meier</code>.\nDie Variablen <code>t1</code> sowie <code>t2</code> sind <code>true</code> und <code>t3</code>\nist <code>false</code>. Da <code>/[ae]/</code> f\xFCr genau ein Zeichen steht, ist <code>t4</code>\nauch <code>false</code>.<br><br>\nDie Auswahl kann beliebig viele Zeichen enthalten. <code>/[abc]/</code> steht f\xFCr a, b oder c\nund <code>/[123456]/</code> steht f\xFCr eine Ziffer von 1 bis 6.",task:"Schreibe eine Funktion <code>pruefe</code>, die feststellt, ob ein String den Namen\nMeier in einer der 4 Schreibweisen Maier, Meier, Mayer oder Meyer enth\xE4lt.\n<code>pruefe('Frau Mayer')</code> sollte <code>true</code> und\n<code>pruefe('Herr Mezer')</code> sollte <code>false</code> ergeben.",hint:"<pre><code>var pruefe = function(s) {\n// Verwende die Zeichenauswahl\n// zweimal.\n};</code></pre>",solution:"<pre><code>var pruefe = function(s) {\n  return /M[ae][iy]er/.test(s);\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("pruefe")},function(){return jshero.testutil.assert_functionHasNumOfParameter("pruefe",1)},function(){return jshero.testutil.assert_functionReturns("pruefe('Maier')",true)},function(){return jshero.testutil.assert_functionReturns("pruefe('Meier')",true)},function(){return jshero.testutil.assert_functionReturns("pruefe('Mayer')",true)},function(){return jshero.testutil.assert_functionReturns("pruefe('Meyer')",true)},function(){return jshero.testutil.assert_functionReturns("pruefe('Mazer')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('Moyer')",false)}]});
jshero.koans.add({id:"regex4",title:"Regex: Bereiche",lesson:"M\xF6chte man mit der Zeichenauswahl alle Ziffern zulassen, so kann man\ndaf\xFCr <code>/[0123456789]/</code> verwenden. Das ist aber recht umst\xE4ndlich. \nMit einem Bindestrich kann man gr\xF6\xDFere, zusammenh\xE4ngende Zeichenbereiche leicht darstellen:\n\n<pre><code>var pruefeZiffer = /[0-9]/;\nvar pruefe1Bis6 = /[1-6]/;\nvar pruefeABisZ = /[A-Z]/;\nvar pruefeaBisz = /[a-z]/; \nvar pruefeDeutschesAlphabet = /[a-z\xE4\xF6\xFC\xDF]/;\nvar pruefeABisz = /[A-Za-z]/;\nvar pruefeMBisT = /[M-T]/;</code></pre>\n\n<code>/[0-9]/</code> steht wie der Regex oben f\xFCr genau eine Ziffer.\nDen Ziffernbereich kann man, wie <code>/[1-6]/</code> zeigt, leicht auf eine gew\xFCnschte Auswahl\n(z.B. Schulnote) einschr\xE4nken. Der Bindestrich funktioniert aber nicht nur f\xFCr Ziffern,\nsondern auch f\xFCr Buchstaben. Dabei muss man zwischen Klein- und\nGro\xDFbuchstaben unterscheiden. <code>/[A-Z]/</code> steht f\xFCr einen der 26 Gro\xDFbuchstaben und\n<code>/[a-z]/</code> f\xFCr einen Kleinbuchstaben. Wichtig ist, dass hier\n\xE4, \xF6, \xFC und \xDF nicht mit erfasst werden. M\xF6chte man das, so muss man diese Buchstaben gesondert\nauff\xFChren. Dazu schreibt man die Umlaute und das Eszett wie bei einer gew\xF6hnlichen Auswahl\neinfach vor oder hinter den Bereich (<code>/[a-z\xE4\xF6\xFC\xDF]/</code>). Ebenso kann man zwei Bereiche\nhintereinander auff\xFChren. <code>/[A-Za-z]/</code> steht f\xFCr genau einen Klein- oder Gro\xDFbuchstaben.\nDen Buchstabenbereich kann man wie bei Ziffern beliebig einschr\xE4nken (<code>/[M-T]/</code>).",task:"Schreibe eine Funktion <code>pruefe</code>, die testet, ob ein String eine\nZeichenfolge wie 'Klasse 2b' enth\xE4lt. Dabei sind Klassen von 1 bis 6 und a bis d\nzul\xE4ssig. <code>pruefe('Die Klasse 1a')</code> sollte <code>true</code> ergeben.",hint:"<pre><code>var pruefe = function(s) {\n// Verwende Literale\n// und Bereiche.  \n};</code></pre>",solution:"<pre><code>var pruefe = function(s) {\n  return /Klasse [1-6][a-d]/.test(s);\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("pruefe")},function(){return jshero.testutil.assert_functionHasNumOfParameter("pruefe",1)},function(){return jshero.testutil.assert_functionReturns("pruefe('Klasse 1a')",true)},function(){return jshero.testutil.assert_functionReturns("pruefe('Klasse 6d')",true)},function(){return jshero.testutil.assert_functionReturns("pruefe('Klasse 0a')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('Klasse 1e')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('Klasse 7d')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('Kasse 1a')",false)}]});
(function(testutil){jshero.koans.add({id:"regex5a",title:"Regex: Anfangs- und Endezeichen",lesson:"Pattern, die wir bisher betrachtet haben, konnten an jeder beliebigen Stelle im zu durchsuchenden String\nstehen. Mit <code>^</code> und <code>$</code> kann man festlegen, dass das Pattern am Anfang bzw. am Ende des zu\ndurchsuchenden Strings stehen soll. <code>/^Hans/</code> trifft auf alle Zeichenketten zu, die mit <code>Hans</code>\nbeginnen und <code>/\\d$/</code> trifft auf alle Zeichenketten zu, die mit einer Ziffer enden. Verwendet man sowohl\ndas Anfangs- als auch das Endezeichen, beschreibt das Pattern den zu untersuchenden String vollst\xE4ndig.\n<code>/^\\d[a-z]$/</code> trifft auf alle Zeichenketten zu, die aus genau einer Ziffer gefolgt von einem\nKleinbuchstaben bestehen.\n<br><br>\n<code>^</code> und <code>$</code> legen die Stelle fest, an der das Suchpattern stehen soll. Solche Zeichen nennt man\nAnker.",task:"Schreibe eine Funktion <code>isTime</code>, die pr\xFCft, ob ein String eine Zeitangabe der Form\nhh:mm:ss ist. hh steht dabei f\xFCr die Stunden, mm f\xFCr die Minuten und ss f\xFCr die Sekunden.\nEs sind alle Zeitangaben von 00:00:00 bis 99:59:59 zugelassen. Bei einstelligen Stunden, Minuten oder Sekunden ist eine\nf\xFChrende Null obligatorisch. <code>isTime('02:15:25')</code> sollte <code>true</code> und\n<code>isTime('x02:15:25x')</code> sollte <code>false</code> ergeben.",hint:"<pre><code>var isTime = function(s) {\n// Verwende ^, $ und\n// Bereiche.\n};</code></pre>",solution:"<pre><code>var isTime = function(s) {\n  return /^\\d\\d:[0-5]\\d:[0-5]\\d$/.test(s);      \n};</code></pre>",tests:[function(){return testutil.assert_isFunction("isTime")},function(){return testutil.assert_functionHasNumOfParameter("isTime",1)},function(){return testutil.assert_functionReturns("isTime('00:00:00')",true)},function(){return testutil.assert_functionReturns("isTime('99:59:59')",true)},function(){return testutil.assert_functionReturns("isTime('02:15:25')",true)},function(){return testutil.assert_functionReturns("isTime('000:00:00')",false)},function(){return testutil.assert_functionReturns("isTime('00:00:000')",false)},function(){return testutil.assert_functionReturns("isTime('00:60:00')",false)},function(){return testutil.assert_functionReturns("isTime('00:00:60')",false)},function(){return testutil.assert_functionReturns("isTime('0:00:00')",false)},function(){return testutil.assert_functionReturns("isTime('00:0:00')",false)},function(){return testutil.assert_functionReturns("isTime('00:00:0')",false)}]})})(jshero.testutil);
jshero.koans.add({id:"regex5neu",title:"Regex: Zeichenklassen",lesson:"F\xFCr einige besondere Zeichenbereiche gibt es Buchstaben als Abk\xFCrzung.\n<code>/\\d/</code> steht f\xFCr eine Ziffer (engl.: digit) und ist identisch mit\n<code>/[0-9]/</code>. Der Regex <code>/\\w/</code> steht f\xFCr ein alphanumerisches Zeichen oder\nden Unterstrich (engl.: word character). <code>/\\w/</code> ist identisch mit <code>/[0-9a-zA-Z_]/</code>.\nDer Abk\xFCrzung ist ein Backslash vorangestellt, damit sie nicht als normaler Buchstabe\ngelesen wird. Abk\xFCrzungen kann man auch innerhalb einer Zeichenauswahl verwenden.\n<code>/[\\da-z]/</code> steht f\xFCr eine Ziffer oder einen Kleinbuchstaben.<br><br>\nEin weitere n\xFCtzliche Zeichenklasse ist <code>\\s</code>. Sie steht f\xFCr ein sogenannten Leerraum-Zeichen\n(engl.: whitespace character). Sie umfasst das gew\xF6hnliche Leerzeichen, das Tabulator-Zeichen, den Zeilenumbruch\nund weitere \xE4hnliche Zeichen.<br><br>\nVerwendet man anstelle des Kleinbuchstaben den Gro\xDFbuchstaben, kann man die negierte Zeichenklasse darstellen.\n<code>\\D</code> steht f\xFCr alle Zeichen, die keine Ziffer sind, <code>\\W</code> f\xFCr alle Zeichen, die kein\nWord Character sind und <code>\\S</code> steht f\xFCr alle Zeichen, die kein Leerraum-Zeichen sind.",task:"Schreibe eine Funktion <code>test</code>, die pr\xFCft, ob ein String 5 aufeinanderfolgende\nZiffern enth\xE4lt. <code>test('28205')</code> sollte <code>true</code> ergeben.",hint:"<pre><code>var test = function(s) {\n// Verwende \\d f\xFCnfmal.\n};</code></pre>",solution:"<pre><code>var test = function(s) {\n  return /\\d\\d\\d\\d\\d/.test(s);\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("test")},function(){return jshero.testutil.assert_functionHasNumOfParameter("test",1)},function(){return jshero.testutil.assert_functionReturns("test('28205 Bremen')",true)},function(){return jshero.testutil.assert_functionReturns("test('06493 Neudorf')",true)},function(){return jshero.testutil.assert_functionReturns("test('123456')",true)},function(){return jshero.testutil.assert_functionReturns("test('1000 kg')",false)},function(){return jshero.testutil.assert_functionReturns("test('1000-1=999')",false)}]});
(function(testutil){jshero.koans.add({id:"regex6",title:"Regex: ?",lesson:"In vielen Pattern ist das Vorkommen eines Zeichens variabel. Autokennzeichen\nbestehen aus einer variablen Anzahl von Buchstaben und Ziffern. F\xFCr solche Pattern stehen eine Reihe\nsogenannter Quantoren bereit. Ein elementarer Quantor ist das <code>?</code>. Er bedeutet,\ndass der voranstehende Ausdruck kein- oder einmal vorkommt. <code>/ab?c/</code> steht\nf\xFCr <code>ac</code> (b kommt keinmal vor) oder f\xFCr <code>abc</code> (b kommt einmal vor).\n<code>/[1-9]?[0-9]/</code> steht f\xFCr eine ein- oder zweistellige Zahl.",task:"Schreibe eine Funktion <code>pruefe</code>, die feststellt, ob ein String den\n<a href='https://de.wikipedia.org/wiki/Meier_(Familienname)'>Familiennamen Meier</a> in einer\nder 8 Schreibweisen Maier, Meier, Mayer, Meyer, Mair, Meir, Mayr oder Meyr enth\xE4lt.\n<code>pruefe('Mayer')</code> und <code>pruefe('Mayr')</code> sollte <code>true</code>\nergeben.",hint:"<pre><code>var pruefe = function(s) {\n// Benutze e?\n};</code></pre>",solution:"<pre><code>var pruefe = function(s) {\n  return /M[ae][iy]e?r/.test(s);\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("pruefe")},function(){return testutil.assert_functionHasNumOfParameter("pruefe",1)},function(){return testutil.assert_functionReturns("pruefe('Maier')",true)},function(){return testutil.assert_functionReturns("pruefe('Mair')",true)},function(){return testutil.assert_functionReturns("pruefe('Mayer')",true)},function(){return testutil.assert_functionReturns("pruefe('Mayr')",true)},function(){return testutil.assert_functionReturns("pruefe('Meier')",true)},function(){return testutil.assert_functionReturns("pruefe('Meir')",true)},function(){return testutil.assert_functionReturns("pruefe('Meyer')",true)},function(){return testutil.assert_functionReturns("pruefe('Meyr')",true)},function(){return testutil.assert_functionReturns("pruefe('aye')",false)},function(){return testutil.assert_functionReturns("pruefe('Mai')",false)},function(){return testutil.assert_functionReturns("pruefe('Maior')",false)},function(){return testutil.assert_functionReturns("pruefe('Mayeer')",false)}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"regex7",title:"Regex: beliebige Wiederholung",lesson:"Zwei weitere wichtige Quantoren sind <code>*</code> und <code>+</code>. Beide bedeuten, dass\nder voranstehende Ausdruck beliebig oft vorkommen darf. Bei <code>*</code> darf er auch keinmal vorkommen.\nBei <code>+</code> muss er mindestens einmal vorkommen.\n<code>b\xE4h*</code> steht f\xFCr b\xE4, b\xE4h, b\xE4hh und so weiter. <code>[01]+</code> steht f\xFCr\neine beliebige <a href='https://de.wikipedia.org/wiki/Dualsystem'>bin\xE4re Zahl</a> wie zum Beispiel\n0, 1, 001, 10111 oder 11001100. Soll das Pattern die Wiederholung einer Zeichenfolge beschreiben, so muss man\nKlammern verwenden. <code>(ha)+</code> steht f\xFCr ha, haha, hahaha und so weiter.",task:"Schreibe eine Funktion <code>hasQuote</code>, die feststellt, ob ein String ein mit doppelten\nAnf\xFChrungszeichen gekennzeichnetes Zitat enth\xE4lt. Innerhalb des Zitats sind beliebige Zeichen\nzul\xE4ssig. Ein leeres Zitat ist auch zugelassen. Das Zitat soll nicht \xFCber mehrere Zeilen gehen.\nEin Zeilenumbruch innerhalb des Zitats ist also nicht zul\xE4ssig.\n<code>hasQuote('\"Ja!\"')</code> sollte <code>true</code> und\n<code>hasQuote('Nein')</code> sollte <code>false</code> ergeben.",hint:"<pre><code>var hasQuote = function(s) {\n// Benutze .*\n};</code></pre>",solution:"<pre><code>var hasQuote = function(s) {\n  return /\".*\"/.test(s);\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("hasQuote")},function(){return testutil.assert_functionHasNumOfParameter("hasQuote",1)},function(){return testutil.assert_functionReturns("hasQuote('\"\"')",true)},function(){return testutil.assert_functionReturns("hasQuote('\"Topp!\"')",true)},function(){return testutil.assert_functionReturns("hasQuote('Stimme: \"Ist gerettet!\"')",true)},function(){return testutil.assert_functionReturns("hasQuote('nein')",false)},function(){return testutil.assert_functionReturns("hasQuote('32\"')",false)}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"regex8",title:"Regex: {n, m}",lesson:"Mit einen Ausdruck der Form <code>{n}</code>, <code>{n,m}</code> oder <code>{n,}</code> kann man die\nAnzahl der Wiederholungen genauer festlegen. <code>{n}</code> steht f\xFCr genau n Wiederholungen, <code>{n,m}</code>\nf\xFCr mindestens n und h\xF6chstens m Wiederholungen und <code>{n,}</code> f\xFCr mindestens n Wiederholungen.\nSo steht <code>/\\d{5}/</code> f\xFCr genau 5 aufeinanderfolgende Ziffern, <code>/.{6,20}/</code> f\xFCr mindestens 6 und\nh\xF6chsten 20 beliebige Zeichen und <code>/[a-zA-Z]{5,}/</code> f\xFCr mindestens 5 aufeinanderfolgende Buchstaben.",task:"Schreibe eine Funktion <code>pruefe</code>, die feststellt, ob ein String ein deutsches\nKfz-Kennzeichen ist. Ein solches Kennzeichen soll dem Schema 'XXX YY NNNN' gen\xFCgen. Dabei steht XXX f\xFCr 1 bis 3\nbeliebige Gro\xDFbuchstaben, YY f\xFCr 1 bis 2 beliebige Gro\xDFbuchstaben und NNNN f\xFCr eine maximal 4stellige Zahl. F\xFChrende\nNullen sind bei der Zahl nicht zugelassen. <code>pruefe('OF C 709')</code> sollte <code>true</code> und\n<code>pruefe('OF 709')</code> sollte <code>false</code> ergeben.",hint:"<pre><code>var pruefe = function(s) {\n  return /^[A-Z]{1,3}...\n};</code></pre>",solution:"<pre><code>var pruefe = function(s) {\n  return /^[A-Z]{1,3} [A-Z]{1,2} [1-9][0-9]{0,3}$/.test(s);\n};</code></pre>",tests:[function(){return testutil.assert_isFunction("pruefe")},function(){return testutil.assert_functionHasNumOfParameter("pruefe",1)},function(){return testutil.assert_functionReturns("pruefe('F A 1')",true)},function(){return testutil.assert_functionReturns("pruefe('F A 9999')",true)},function(){return testutil.assert_functionReturns("pruefe('F AA 1')",true)},function(){return testutil.assert_functionReturns("pruefe('LUP A 1')",true)},function(){return testutil.assert_functionReturns("pruefe('F A 0')",false)},function(){return testutil.assert_functionReturns("pruefe('F A 01')",false)},function(){return testutil.assert_functionReturns("pruefe('F A 12345')",false)},function(){return testutil.assert_functionReturns("pruefe('F A')",false)},function(){return testutil.assert_functionReturns("pruefe('F 1')",false)},function(){return testutil.assert_functionReturns("pruefe('F AAA 1')",false)},function(){return testutil.assert_functionReturns("pruefe('FFFF A 1')",false)}]})})(jshero.testutil);
jshero.koans.add({id:"regexescape",title:"Regex: Escape",lesson:"Wie wir gesehen haben, besitzen regul\xE4re Ausdr\xFCcke eine Reihe von Zeichen mit besonderer Bedeutung.\nSo steht <code>.</code> nicht f\xFCr einen Punkt, sondern f\xFCr ein beliebiges Zeichen.\nM\xF6chte man nach einen Punkt suchen, so muss man die besondere Bedeutung gewisserma\xDFen\nausschalten. Das macht man mit einen vorangestellten Backslash: \n\n<pre><code>var t1 = /\\./.test('Z. B.');\nvar t2 = /\\./.test('ZB');</code></pre>\n\nDer erste Ausdruck ergibt <code>true</code>, der zweite <code>false</code>.\nOhne den Backslash w\xFCrden beide Ausdr\xFCcke <code>true</code> ergeben.\nEin solches 'Ausschalten' nennt man maskieren oder escapen.\n\nM\xF6chte man nach dem Backslash suchen, so muss man diesen ebenfalls maskieren:\n\n<pre><code>var t = /\\\\/.test('A \\ B');\n// t ist true</code></pre>\n\nInsgesamt gibt es 15 Zeichen, die man maskieren muss, wenn man nach ihnen suchen m\xF6chte:\n<code>* + ? . ( ) [ ] { } \\ / | ^ $</code>",task:"Schreibe eine Funktion <code>pruefe</code>, die feststellt, ob ein String den Teilstring\n<code>'(x)'</code> enh\xE4lt. <code>pruefe('f(x)')</code> sollte <code>true</code> und\n<code>pruefe('f(n)')</code> sollte <code>false</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("pruefe")},function(){return jshero.testutil.assert_functionHasNumOfParameter("pruefe",1)},function(){return jshero.testutil.assert_functionReturns("pruefe('f(x)')",true)},function(){return jshero.testutil.assert_functionReturns("pruefe('g(x)')",true)},function(){return jshero.testutil.assert_functionReturns("pruefe('x')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('f(n)')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('f()')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('(x')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('x)')",false)}]});
jshero.koans.add({id:"regexexec",title:"Regex: exec",lesson:"Neben der Methode <code>test</code> besitzen regul\xE4re Ausdr\xFCcke noch die Methode <code>exec</code>.\nW\xE4hrend <code>test</code> feststellt, ob ein Regex in einem String gefunden wird, gibt <code>exec</code>\nauch den gefundenen String und alle gefundenen Gruppen zur\xFCck. Das geschiet in Form eines Arrays.\nDieses Array hat dar\xFCber hinaus die beiden Eigenschaften <code>index</code> und <code>input</code>.\n<code>index</code> enth\xE4lt den 0-basierten Index des gefundenen Strings und <code>input</code>\nden originalen String.<br> \n\n<pre><code>var resultat = /(\\d+):(\\d+)/.exec(\"Kiel-Flensburg 23:25\");\nvar endstand = resultat[0]; // \"23:25\"\nvar toreKiel = resultat[1]; // \"23\"\nvar toreFlensburg = resultat[2]; // \"25\"\nvar index = resultat.index; // 15</code></pre>\n\nWird der regul\xE4re Ausdruck nicht gefunden, gibt <code>exec</code> <code>null</code> zur\xFCck.",task:"Schreibe eine Funktion <code>parseDate</code>, die einen String mit einem Datum entgegennimmt und die dieses\nDatum als Date mit UTC 0:00 Uhr zur\xFCckgibt. Das Datum liegt im deutschen Format dd.mm.yyyy vor. F\xFChrende Nullen sind\noptional. Das Datum kann mitten im String stehen. Enth\xE4lt der String kein g\xFCltiges Datum, soll <code>null</code>\nzur\xFCckgegeben werden.<br>\n<code>parseDate(\"Geburt: 12.07.2001\")</code> sollte ein Date-Objekt mit dem Zeitpunkt 12.07.2001 0:00 UTC zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("parseDate")},function(){return jshero.testutil.assert_functionHasNumOfParameter("parseDate",1)},function(){return jshero.testutil.assert_functionReturnsType("parseDate(\"23.10.2019\")","Date")},function(){return jshero.testutil.assert_functionReturns("parseDate(\"23.10.2019\")",new Date(Date.UTC(2019,9,23)),{"utc":true})},function(){return jshero.testutil.assert_functionReturns("parseDate(\"2.5.1912\")",new Date(Date.UTC(1912,4,2)),{"utc":true})},function(){return jshero.testutil.assert_functionReturns("parseDate(\"...31.12.2000...\")",new Date(Date.UTC(2000,11,31)),{"utc":true})},function(){return jshero.testutil.assert_functionReturns("parseDate(\"..ab.12.2000...\")",null)},function(){return jshero.testutil.assert_functionReturns("parseDate(\"32.12.2000\")",null)},function(){return jshero.testutil.assert_functionReturns("parseDate(\"01.13.2000\")",null)}]});
jshero.koans.add({id:"regexgroup",title:"Regex: Gruppen",lesson:"Klammern hatten wir schon kennengelernt. Sie begrenzen die Anwendung eines Operators auf den eingeklammerten\nBereich. Klammern haben aber noch eine weitere wichtige Funktion. Eingeklammerte Bereiche definieren eine Gruppe.\nDiese Gruppen werden von 1 bis 9 durchnummeriert (mehr Gruppen kann man nicht definieren).\nMit <code>\\1</code> bis <code>\\9</code> kann man innerhalb des Regex auf eine Gruppe zugreifen.\nDamit kann man nach Wiederholungen suchen.<br>\n<code>/([a-z])\\1/</code> findet doppelte Kleinbuchstaben und <code>/(\\d)(\\d).*\\1\\2/</code>\nfindet doppelte zweistellige Zahlen.\n\n<pre><code>var t1 = /([a-z])\\1/.test('Affe'); // true\nvar t2 = /(\\d)(\\d).*\\1\\2/.test(12 mal 12'); // true</code></pre>",task:"Schreibe eine Funktion <code>test</code>, die feststellt, ob ein String ein doppeltes Wort enth\xE4lt.\nEin Wort soll aus mindestens einem Buchstaben bestehen. Zugrunde liegt das englische Alphabet.\nKlein- oder Gro\xDFschreibung soll keine Rolle spielen. <code>test('Apfel Birne Apfel')</code> sollte true und\n<code>test('Apfel Birne')</code> sollte <code>false</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("test")},function(){return jshero.testutil.assert_functionHasNumOfParameter("test",1)},function(){return jshero.testutil.assert_functionReturns("test('Apfel Birne Apfel')",true)},function(){return jshero.testutil.assert_functionReturns("test('Apfel Birne')",false)},function(){return jshero.testutil.assert_functionReturns("test('ApfelApfel')",false)},function(){return jshero.testutil.assert_functionReturns("test('Apfel Apfel')",true)},function(){return jshero.testutil.assert_functionReturns("test('Apfel Apfelmus')",false)},function(){return jshero.testutil.assert_functionReturns("test('ein rein')",false)}]});
(function(testutil){jshero.koans.add({id:"regexi",title:"Regex: case-insensitive",lesson:"Regul\xE4re Ausdr\xFCcke kann man durch Flags erg\xE4nzen. Eines dieser Flags ist <code>i</code>.\nIst es gesetzt, unterscheidet das Pattern nicht zwischen Gro\xDF- und Kleinschreibung. Der Regex ist case-insensitive.\nFlags werden dem Regex einfach angeh\xE4ngt:\n\n<pre><code>var t1 = /es/i.test(\"Was es\"); // true\nvar t2 = /es/i.test(\"Es war\"); // true\nvar t3 = /es/i.test(\"ES\"); // true</code></pre>",task:"Schreibe eine Funktion <code>test</code>, die feststellt, ob ein String das Wort <code>JavaScript</code>\noder <code>JS</code> enth\xE4lt. Dabei soll Gro\xDF- oder Kleinschreibung keine Rolle spielen.",tests:[function(){return testutil.assert_isFunction("test")},function(){return testutil.assert_functionHasNumOfParameter("test",1)},function(){return testutil.assert_functionReturns("test('JAVASCRIPT')",true)},function(){return testutil.assert_functionReturns("test('hello javascript')",true)},function(){return testutil.assert_functionReturns("test('JavaScript Hero')",true)},function(){return testutil.assert_functionReturns("test('JS')",true)},function(){return testutil.assert_functionReturns("test('hello js')",true)},function(){return testutil.assert_functionReturns("test('JS Hero')",true)},function(){return testutil.assert_functionReturns("test('HelloJavaScript')",false)},function(){return testutil.assert_functionReturns("test('JavaScriptHero')",false)},function(){return testutil.assert_functionReturns("test('Java')",false)},function(){return testutil.assert_functionReturns("test('JSF')",false)},function(){return testutil.assert_functionReturns("test('JJS')",false)}]})})(jshero.testutil);
jshero.koans.add({id:"regexnot",title:"Regex: Negation",lesson:"M\xF6chte man alle Zeichen bis auf einige Ausnahmen zulassen, kann man mit <code>^</code> die Zeichenauswahl\nnegieren. <code>^</code> ist als Negation nur innerhalb einer Zeichenauswahl g\xFCltig. Es muss an erster Stelle der\nZeichenauswahl stehen und negiert die komplette Auswahl. <code>[^ab]</code> steht f\xFCr alle Zeichen au\xDFer einem \n<code>a</code> oder <code>b</code> und <code>[^0-9]</code> steht f\xFCr alle Zeichen au\xDFer einer Ziffer.",task:"Schreibe eine Funktion <code>test</code>, die pr\xFCft, ob ein String nur Zeichen des englischen\nAlphabets enth\xE4lt. <code>test('Blue')</code> sollte <code>true</code> und <code>test('Blue sea')</code> sollte\n<code>false</code> ergeben (das Leerzeichen geh\xF6rt nicht zum Alphabet).",tests:[function(){return jshero.testutil.assert_isFunction("test")},function(){return jshero.testutil.assert_functionHasNumOfParameter("test",1)},function(){return jshero.testutil.assert_functionReturns("test('Red')",true)},function(){return jshero.testutil.assert_functionReturns("test('OFC')",true)},function(){return jshero.testutil.assert_functionReturns("test('Red wine')",false)},function(){return jshero.testutil.assert_functionReturns("test('CO2')",false)},function(){return jshero.testutil.assert_functionReturns("test('&Foo')",false)},function(){return jshero.testutil.assert_functionReturns("test('#Foo')",false)},function(){return jshero.testutil.assert_functionReturns("test('Fritz?')",false)},function(){return jshero.testutil.assert_functionReturns("test('a-z')",false)}]});
jshero.koans.add({id:"regexor",title:"Regex: Alternativen",lesson:"M\xF6chte man nach Alternativen suchen, kann man daf\xFCr den <code>|</code> Operator verwenden.\n<code>/Tom|Jerry/</code> sucht nach <code>Tom</code> oder <code>Jerry</code>. Der <code>|</code> Operator\ngilt f\xFCr den kompletten Regex. <code>/\\bTom|Jerry\\b/</code> sucht nach W\xF6rtern, die mit <code>Tom</code>\nbeginnen oder mit <code>Jerry</code> enden. <code>Tomme</code> wird so auch gefunden.\nM\xF6chte man, dass beide Wortgrenzen f\xFCr beide Namen gelten, kann man Klammern verwenden.\n<code>/\\b(Tom|Jerry)\\b/</code> sucht nach den W\xF6rtern <code>Tom</code> oder <code>Jerry</code>. Der \n<code>|</code> Operator gilt jetzt nur f\xFCr die Klammer. <code>Tomme</code> wird nicht mehr gefunden.",task:"Schreibe eine Funktion <code>isTime</code>, die feststellt, ob ein String eine Zeitangabe der Form\n<code>hh:mm</code> ist. F\xFCr <code>hh</code> sind alle Werte von <code>00</code> bis <code>23</code> und f\xFCr\n<code>mm</code> alle Werte von <code>00</code> bis <code>59</code> zugelassen.\n<code>isTime('23:27')</code> sollte <code>true</code> und <code>isTime('24:12')</code> sollte\n<code>false</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("isTime")},function(){return jshero.testutil.assert_functionHasNumOfParameter("isTime",1)},function(){return jshero.testutil.assert_functionReturns("isTime('00:00')",true)},function(){return jshero.testutil.assert_functionReturns("isTime('01:01')",true)},function(){return jshero.testutil.assert_functionReturns("isTime('09:19')",true)},function(){return jshero.testutil.assert_functionReturns("isTime('12:27')",true)},function(){return jshero.testutil.assert_functionReturns("isTime('18:47')",true)},function(){return jshero.testutil.assert_functionReturns("isTime('23:59')",true)},function(){return jshero.testutil.assert_functionReturns("isTime('24:00')",false)},function(){return jshero.testutil.assert_functionReturns("isTime('02:60')",false)},function(){return jshero.testutil.assert_functionReturns("isTime('-00:00')",false)},function(){return jshero.testutil.assert_functionReturns("isTime('00:00-')",false)},function(){return jshero.testutil.assert_functionReturns("isTime('1:00')",false)},function(){return jshero.testutil.assert_functionReturns("isTime('00:0')",false)},function(){return jshero.testutil.assert_functionReturns("isTime('00-00')",false)}]});
(function(testutil){jshero.koans.add({id:"regexword",title:"Regex: Wortgrenzen",lesson:"Ein weiterer Anker ist <code>\\b</code>. Er steht f\xFCr eine Wortgrenze. <code>/\\bJa/</code> findet\nalle W\xF6rter, die mit <code>Ja</code> beginnen und <code>/tion\\b/</code> alle W\xF6rter, die mit <code>tion</code> enden.\nVerwendet man <code>\\b</code> sowohl am Anfang als auch am Ende, so kann man nach ganzen W\xF6rten suchen.\n\n<pre><code>var t1 = /\\bdenke/.test('Wir denken'); // true\nvar t2 = /\\bdenke/.test('Bedenke'); // false\nvar t3 = /lauf\\b/.test('der Wettlauf hat'); // true\nvar t4 = /lauf\\b/.test('laufen'); // false\nvar t5 = /\\bso\\b/.test('Aber so ist'); // true</code></pre>\n\nWichtig ist, welche Zeichen als Wortgrenze gelten. In den obigen Beispielen war es das Leerzeichen.\nHinzu kommen alle Satzzeichen wie Punkt, Komma, Ausrufezeichen usw.\nAber auch der Bindestrich gilt als Wortgrenze. <code>/Anna\\b/</code> findet sich in <code>Anna-Ida</code>.\nTats\xE4chlich gelten alle Zeichen, die nicht zur Zeichenklasse <code>\\w</code> geh\xF6ren, als Wortgrenze.\nEs z\xE4hlen also alle nicht-alphanumerischen Zeichen ohne den Unterstrich als Wortgrenze.\nDas bezieht sich allerdings auf das englische Alphabet.\nAlle deutschen Umlaute gelten somit als Wortgrenze. Hier muss man aufpassen.\n<code>/bei\\b/</code> findet sich in <code>bei\xDFen</code>, da <code>\xDF</code> als Wortgrenze angesehen wird.",task:"Schreibe eine Funktion <code>hatLauf</code>, die pr\xFCft, ob ein String ein Wort enth\xE4lt, dass mit\n<code>lauf</code> beginnt. Dabei soll es keine Rolle spielen, ob <code>lauf</code> mit gro\xDFem oder kleinem\n<code>l</code> beginnt.",tests:[function(){return testutil.assert_isFunction("hatLauf")},function(){return testutil.assert_functionHasNumOfParameter("hatLauf",1)},function(){return testutil.assert_functionReturns("hatLauf('Lauf!')",true)},function(){return testutil.assert_functionReturns("hatLauf('Wir laufen da lang!')",true)},function(){return testutil.assert_functionReturns("hatLauf('weglaufen')",false)},function(){return testutil.assert_functionReturns("hatLauf('lau')",false)}]})})(jshero.testutil);
jshero.koans.add({id:"replace",title:"String: replace()",lesson:"Die Methode <code>replace</code> ersetzt einen Teilstring durch einen anderen:\n\n<pre><code>var str = 'Hallo Marcel!';\nvar newstr = str.replace('Marcel', 'Robert');</code></pre>\n\n'Marcel' wird durch 'Robert' ersetzt. <code>newstr</code> hat also den Wert <code>'Hallo Robert!'</code>.\nDer urspr\xFCngliche String bleibt unver\xE4ndert. Nur das erste Vorkommen wird ersetzt:\n\n<pre><code>var newname = 'Peter'.replace('e', 'a');</code></pre>\n\n<code>newname</code> enth\xE4lt den Wert <code>'Pater'</code> und nicht <code>'Patar'</code>.\nEin Spezialfall ergibt sich, wenn der ersetzende String der Leerstring ist:\n\n<pre><code>var nurso = 'sowie so'.replace('wie', '');</code></pre>\n\nDer zu ersetzende String wird entfernt. <code>nurso</code> enth\xE4lt den Wert <code>'so so'</code>.\nKommt der zu ersetzende String nicht vor, so wird der urspr\xFCngliche String zur\xFCckgegeben.",task:"Schreibe eine Funktion <code>convert</code>, die einen Datumsstring in englischer Schreibweise (20-05-2017 oder\n20/05/2017) in deutsche Schreibweise (20.05.2017) umwandet.<br><br>Beispiel: Sowohl\n<code>convert('20-05-2017')</code> als auch <code>convert('20/05/2017')</code> sollten <code>'20.05.2017'</code> ergeben.",hint:"<pre><code>var convert = function(s1, s2) {\n// Verwende replace viermal.\n};</code></pre>",solution:"<pre><code>var convert = function(dateEn) {\n  var dateDe = dateEn.replace('-', '.');\n  dateDe = dateDe.replace('-', '.');\n  dateDe = dateDe.replace('/', '.');\n  dateDe = dateDe.replace('/', '.');\n  return dateDe;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("convert")},function(){return jshero.testutil.assert_functionHasNumOfParameter("convert",1)},function(){return jshero.testutil.assert_functionReturns("convert('10-07-1871')","10.07.1871")},function(){return jshero.testutil.assert_functionReturns("convert('8/11/1922')","8.11.1922")}]});
(function(testutil){jshero.koans.add({id:"roman1",title:"R\xF6mische Zahlen I",lesson:"Die folgende Aufgabe ist anspruchsvoll. Versuche eine iterative (Scheife) und eine rekursive L\xF6sung zu finden.",task:"Schreibe eine Funktion <code>roman</code>, die eine\n<a href='https://de.wikipedia.org/wiki/R%C3%B6mische_Zahlschrift'>r\xF6mische Zahl</a> (bis 1000) in eine\n<a href='https://de.wikipedia.org/wiki/Arabische_Zahlschrift'>arabische</a> umwandelt.\n<code>roman('CDLXXXIII')</code> sollte <code>483</code> ergeben.",tests:[function(){return testutil.assert_isFunction("roman")},function(){return testutil.assert_functionHasNumOfParameter("roman",1)},function(){return testutil.assert_functionReturns("roman('I')",1)},function(){return testutil.assert_functionReturns("roman('II')",2)},function(){return testutil.assert_functionReturns("roman('III')",3)},function(){return testutil.assert_functionReturns("roman('IV')",4)},function(){return testutil.assert_functionReturns("roman('V')",5)},function(){return testutil.assert_functionReturns("roman('VI')",6)},function(){return testutil.assert_functionReturns("roman('X')",10)},function(){return testutil.assert_functionReturns("roman('CDLXXXIII')",483)},function(){return testutil.assert_functionReturns("roman('DCLXVI')",666)},function(){return testutil.assert_functionReturns("roman('CMXCIX')",999)},function(){return testutil.assert_functionReturns("roman('M')",1000)}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"roman2",title:"R\xF6mische Zahlen II",lesson:"Nun wollen wir es andersherum probieren. Versuche auch hier eine iterative und eine rekursive L\xF6sung zu finden.",task:"Schreibe eine Funktion <code>roman</code>, die eine arabische Zahl (bis 1000) in eine r\xF6mische Zahl umwandelt.\n<br><br>Beispiel: <code>roman(483)</code> sollte <code>'CDLXXXIII'</code> ergeben.",tests:[function(){return testutil.assert_isFunction("roman")},function(){return testutil.assert_functionHasNumOfParameter("roman",1)},function(){return testutil.assert_functionReturns("roman(1)","I")},function(){return testutil.assert_functionReturns("roman(2)","II")},function(){return testutil.assert_functionReturns("roman(3)","III")},function(){return testutil.assert_functionReturns("roman(4)","IV")},function(){return testutil.assert_functionReturns("roman(5)","V")},function(){return testutil.assert_functionReturns("roman(6)","VI")},function(){return testutil.assert_functionReturns("roman(10)","X")},function(){return testutil.assert_functionReturns("roman(483)","CDLXXXIII")},function(){return testutil.assert_functionReturns("roman(666)","DCLXVI")},function(){return testutil.assert_functionReturns("roman(999)","CMXCIX")},function(){return testutil.assert_functionReturns("roman(1000)","M")}]})})(jshero.testutil);
jshero.koans.add({id:"round",title:"Runden",lesson:"M\xF6chte man eine Dezimalzahl auf- oder abrunden, stehen einem die Funktionen <code>Math.round()</code>,\n<code>Math.floor()</code> (engl.: Boden) und <code>Math.ceil()</code> (engl: Decke) zur Verf\xFCgung.\n\n<pre><code>var a = Math.round(5.49);\nvar b = Math.round(4.5);\nvar c = Math.floor(5.99);\nvar d = Math.ceil(4.01);</code></pre>\n\n<code>Math.round()</code> rundet kaufm\xE4nnisch. Zahlen mit der ersten Dezimalstelle kleiner gleich 4 werden abgerundet, alle anderen aufgerundet.\n<code>Math.floor()</code> rundet immer ab und <code>Math.ceil()</code> rundet immer auf. Die Variablen <code>a</code> bis <code>d</code>\nerhalten also alle den Wert <code>5</code>.",task:"Schreibe eine Funktion <code>round100</code>, die eine Dezimalzahl kaufm\xE4nnisch auf die Hunderterstelle\nrundet.<br><br>Beispiel: <code>round100(1749)</code> sollte <code>1700</code> und <code>round100(856.123)</code>\nsollte <code>900</code> ergeben.",hint:"Verwende neben <code>Math.round()</code> noch Multiplikation und Division.",solution:"<pre><code>var round100 = function(x) {\n  return Math.round(x / 100) * 100;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("round100")},function(){return jshero.testutil.assert_functionHasNumOfParameter("round100",1)},function(){return jshero.testutil.assert_functionReturns("round100(49.999)",0)},function(){return jshero.testutil.assert_functionReturns("round100(50)",100)},function(){return jshero.testutil.assert_functionReturns("round100(349)",300)},function(){return jshero.testutil.assert_functionReturns("round100(350)",400)},function(){return jshero.testutil.assert_functionReturns("round100(4649)",4600)},function(){return jshero.testutil.assert_functionReturns("round100(4650)",4700)}]});
jshero.koans.add({id:"slice",title:"Array: slice()",lesson:"Mit <code>slice</code> kopiert man aus einem Array ein Teilarray:\n\n<pre><code>var abcd = ['a', 'b', 'c', 'd'];\nvar ab = abcd.slice(0, 2);\nvar bc = abcd.slice(1, 3);\nvar bcd = abcd.slice(1, 4);</code></pre>\n\nDer erste Parameter gibt den Startindex (einschlie\xDFlich), der zweite den Endindex (ausschlie\xDFlich) an.\nDas urspr\xFCngliche Array wird nicht ver\xE4ndert.",task:"Schreibe eine Funktion <code>halve</code>, die aus einem Array die erste H\xE4lfte kopiert.\nBei einer ungeraden Anzahl von Array-Elementen soll das mittlere Element zu der ersten H\xE4lfte geh\xF6ren.<br><br>Beispiel:\n<code>halve([1,&nbsp;2,&nbsp;3,&nbsp;4])</code> sollte <code>[1,&nbsp;2]</code> zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("halve")},function(){return jshero.testutil.assert_functionHasNumOfParameter("halve",1)},function(){return jshero.testutil.assert_functionReturns("halve([1, 2])",[1])},function(){return jshero.testutil.assert_functionReturns("halve([1, 2, 3])",[1,2])},function(){return jshero.testutil.assert_functionReturns("halve([1, 2, 3, 4])",[1,2])},function(){return jshero.testutil.assert_functionReturns("halve([1, 2, 3, 4, 5])",[1,2,3])}]});
jshero.koans.add({id:"string",title:"Strings",lesson:"Wir haben gesehen, dass eine Variable ein Beh\xE4lter f\xFCr einen Wert ist. Werte besitzen dabei einen Typ.\nSo kann ein Wert eine Zahl wie <code>7.12</code> sein. Der Typ von <code>7.12</code> ist Zahl. Oder ein Wert kann\nein Text wie <code>'Hallo Welt!'</code> sein. Der Typ von <code>'Hallo Welt!'</code> ist Text. Diesen Typ bezeichnet\nman auch als Zeichenkette oder String. Dabei kann man einfache oder doppelte Anf\xFChrungszeichen verwenden.\nSo ist <code>'Hallo Welt!'</code> derselbe String wie <code>\"Hallo Welt!\"</code>.<br>Mit Strings kann man arbeiten.\nMan kann sie zum Beispiel verketten. Dies macht man mit dem <code>+</code> Zeichen. <code>'Blau' + 'meier'</code>\nergibt den String <code>'Blaumeier'</code>.<br>Die folgende Funktion h\xE4ngt an dem \xFCbergebenen Parameter einen Text\nan und gibt den zusammengesetzten Text zur\xFCck:\n\n<pre><code>var lobe = function(name) {\n  return name + ' ist toll!';\n};</code></pre>\n\nSo liefert <code>lobe('JavaScript')</code> den Wert <code>'JavaScript ist toll!'</code>.",task:"Schreibe eine Funktion <code>begruesse</code>, die einen Parameter entgegennimmt und die\n<code>'Hallo &lt;Parameter&gt;!'</code> zur\xFCckgibt.<br><br>\nBeispiel: \xDCbergibt man der Funktion <code>begruesse</code> den Wert <code>'Ada'</code>,\nso sollte die Funktion <code>'Hallo Ada!'</code> zur\xFCckgeben.",hint:"<pre><code>var begruesse = function(name) {\n  return ...\n};</code></pre>",solution:"<pre><code>var begruesse = function(name) {\n  return 'Hallo ' + name + '!';\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("begruesse")},function(){return jshero.testutil.assert_functionHasNumOfParameter("begruesse",1)},function(){return jshero.testutil.assert_functionReturns("begruesse('Maria')","Hallo Maria!")},function(){return jshero.testutil.assert_functionReturns("begruesse('Franz')","Hallo Franz!")},function(){return jshero.testutil.assert_functionReturns("begruesse('Ada')","Hallo Ada!")}]});
jshero.koans.add({id:"stringcharat",title:"String: charAt()",lesson:"Um aus einem String das Zeichen an einer bestimmten Stelle zu erhalten, verwendet man die Methode\n<code>charAt(index)</code>. Der Paramter <code>index</code> gibt die Stelle des Zeichens innerhalb der Zeichenkette an.\nDabei hat das erste Zeichen einer Zeichenkette den Index 0:\n\n<pre><code>var n1 = 'Maria'.charAt(0);\nvar n2 = 'Maria'.charAt(1);\nvar n3 = 'Maria'.charAt(5);\nvar n4 = 'Maria'.charAt();</code></pre>\n\n<code>n1</code> hat den Wert <code>'M'</code> und <code>n2</code> hat den Wert <code>'a'</code>. Ist der Index gr\xF6\xDFer\nals der Index des letzten Zeichens, wird der leere String zur\xFCckgegeben. <code>n3</code> hat also den Wert <code>''</code>.\nWird kein Parameter \xFCbergeben, so wird das Zeichen mit dem Index <code>0</code> zur\xFCckgegeben. Man sagt: der Default-Wert\nf\xFCr <code>index</code> ist <code>0</code>. Der Wert von <code>n4</code> ist also auch <code>'M'</code>.",task:"Schreibe eine Funktion <code>abkuerzung</code>, die zwei Strings als Parameter entgegennimmt und als R\xFCckgabe die Anfangsbuchstaben\ndieser Strings zur\xFCckgibt.<br><br>Beispiel: <code>abkuerzung('Hansestadt', 'Bremen')</code> sollte <code>'HB'</code> zur\xFCckliefern.",hint:"<pre><code>var abkuerzung = function(s1, s2) {\n  ...\n};</code/></pre>",solution:"<pre><code>var abkuerzung = function(s1, s2) {\n  return s1.charAt(0) + s2.charAt(0);\n};</code/></pre>",tests:[function(){return jshero.testutil.assert_isFunction("abkuerzung")},function(){return jshero.testutil.assert_functionHasNumOfParameter("abkuerzung",2)},function(){return jshero.testutil.assert_functionReturns("abkuerzung('Hansestadt', 'Bremen')","HB")},function(){return jshero.testutil.assert_functionReturns("abkuerzung('Java', 'Script')","JS")}]});
jshero.koans.add({id:"stringindexof",title:"String: indexOf()",lesson:"Um die Position eines Strings innerhalb eines anderen Strings zu bestimmen, verwendet man die Methode <code>indexOf</code>:\n\n<pre><code>var n1 = 'Bit'.indexOf('it');\nvar n2 = 'Bit'.indexOf('js');\nvar n3 = 'Bit'.indexOf('IT');</code></pre>\n\n<code>n1</code> ist <code>1</code>, da <code>'it'</code> in <code>'Bit'</code> an der 1. Stelle beginnt.\nWie \xFCblich beginnt die Z\xE4hlung mit 0.\nKommt das Suchwort im aufrufenden String nicht vor, wird <code>-1</code> zur\xFCckgegeben. <code>n2</code> ist also <code>-1</code>.\nDie Methode <code>indexOf()</code> unterscheidet zwischen Gro\xDF- und Kleinschreibung. <code>n3</code> ist also auch <code>-1</code>.",task:"Schreibe eine Funktion <code>indexOfIgnoreCase</code>, die 2 Strings entgegennimmt und wie die Methode\n<code>indexOf</code> die Position des zweiten Strings im ersten String bestimmt. Im Unterschied zur Methode\n<code>indexOf</code> soll die Gro\xDF- oder Kleinschreibung keine Rolle spielen.<br><br>Beispiel:\nSowohl <code>indexOfIgnoreCase('JS', 'JS')</code> als auch <code>indexOfIgnoreCase('JS', 'js')</code> sollten\n<code>0</code> ergeben.",hint:"<pre><code>var indexOfIgnoreCase = function(s1, s2) {\n// Wandle s1 und s2 zuerst\n// in Kleinbuchstaben um.\n// Verwende dann die\n// indexOf-Methode. \n};</code></pre>",solution:"<pre><code>var indexOfIgnoreCase = function(s1, s2) {\n  var s1Klein = s1.toLowerCase();\n  var s2Klein = s2.toLowerCase();\n  return s1Klein.indexOf(s2Klein);\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("indexOfIgnoreCase")},function(){return jshero.testutil.assert_functionHasNumOfParameter("indexOfIgnoreCase",2)},function(){return jshero.testutil.assert_functionReturns("indexOfIgnoreCase('JS', 'js')",0)},function(){return jshero.testutil.assert_functionReturns("indexOfIgnoreCase('JavaScript', 'Script')",4)},function(){return jshero.testutil.assert_functionReturns("indexOfIgnoreCase('Fred Feuerstein', 'FEUER')",5)},function(){return jshero.testutil.assert_functionReturns("indexOfIgnoreCase('WILMA FEUERSTEIN', 'feuer')",6)}]});
jshero.koans.add({id:"stringindexof2",title:"String: indexOf(), 2. Parameter",lesson:"Der Methode <code>indexOf</code> kann man als zweiten Parameter noch die Stelle mitgeben,\nab der der Suchstring im aufrufenden String gesucht werden soll.\n\n<pre><code>var n1 = \"Fred Feuerstein\".indexOf(\"e\", 2);\nvar n2 = \"Fred Feuerstein\".indexOf(\"e\", 3);\nvar n3 = \"Fred Feuerstein\".indexOf(\"e\", 7);</code></pre>\n\nDas erste <code>\"e\"</code> befindet sich in <code>\"Fred Feuerstein\"</code> an 2. Stelle. Es wird bei einer Suche ab der 2. Stelle gefunden. <code>n1</code>\nist also 2. Das zweite <code>\"e\"</code> in <code>\"Fred Feuerstein\"</code> befindet sich an der 6. Stelle. Es wird bei der Suche ab der 3. Stelle gefunden.\n<code>n2</code> ist <code>6</code>. Mit der dritten Codezeile wird das dritte <code>\"e\"</code> in <code>\"Fred Feuerstein\"</code> gefunden.\n<code>n3</code> ist <code>8</code>.",task:"Schreibe eine Funktion <code>secondIndexOf</code>, die 2 Strings entgegennimmt und die zweite Position des\nzweiten Strings im ersten String bestimmt. Kommt der Suchstring nicht zweimal vor, so soll <code>-1</code> zur\xFCckgegeben werden.\n<br><br>Beispiel: <code>secondIndexOf(\"Ida-Ida\", \"Ida\")</code> soll <code>4</code> zur\xFCckgeben.\n<br><br>Tipp: Falls Du Hilfe brauchst, lies dir auch die Beschreibung in\n<a href=\"https://wiki.selfhtml.org/wiki/JavaScript/Objekte/String/indexOf\">SELFHTML</a> durch.",hint:"<pre><code>var secondIndexOf = function(s1, s2) {\n// Verwende indexOf zweimal.\n// Zuerst ohne, dann mit\n// zweitem Parameter. \n};</code></pre>",solution:"<pre><code>var secondIndexOf = function(s1, s2) {\n  var firstIndex = s1.indexOf(s2);\n  return s1.indexOf(s2, firstIndex + 1);\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("secondIndexOf")},function(){return jshero.testutil.assert_functionHasNumOfParameter("secondIndexOf",2)},function(){return jshero.testutil.assert_functionReturns("secondIndexOf(\"AA\", \"A\")",1)},function(){return jshero.testutil.assert_functionReturns("secondIndexOf(\"Ida-Ida\", \"Ida\")",4)},function(){return jshero.testutil.assert_functionReturns("secondIndexOf(\"a rose is a rose\", \"rose\")",12)},function(){return jshero.testutil.assert_functionReturns("secondIndexOf(\"There is no there there.\", \"there\")",18)},function(){return jshero.testutil.assert_functionReturns("secondIndexOf(\"There is no there there.\", \"There\")",-1)}]});
jshero.koans.add({id:"stringlength",title:"String: length",lesson:"Strings besitzen die Eigenschaft <code>length</code>. Diese Eigenschaft liefert die Anzahl der Zeichen eines Strings.\nDazu muss man dem String  oder der Variablen, die den String enth\xE4lt, <code>.length</code> anh\xE4ngen:\n\n<pre><code>var anzahl = 'Franz'.length;</code/></pre>\n\n<code>'Franz'</code> hat 5 Zeichen. Also erh\xE4lt <code>anzahl</code> den Wert <code>5</code>.\n\n<pre><code>var stadt = 'Prag';\nanzahl = stadt.length;</code/></pre>\n\n<code>'Prag'</code> hat 4 Zeichen. <code>anzahl</code> hat jetzt den Wert <code>4</code>.\n\n<pre><code>anzahl = ''.length;</code/></pre>\n\nDer Leerstring besitzt keine Zeichen. Der Wert von <code>anzahl</code> ist jetzt <code>0</code>.",task:"Schreibe eine Funktion <code>laenge</code>, die bei \xDCbergabe eines Strings die Anzahl der Zeichen dieses\nStrings zur\xFCckgibt.<br><br>Beispiel: <code>laenge('Franz')</code> sollte <code>5</code> zur\xFCckgeben.",hint:"<pre><code>var laenge = function(s) {\n...\n};</code/></pre>",solution:"<pre><code>var laenge = function(s) {\n  return s.length;\n};</code/></pre>",tests:[function(){return jshero.testutil.assert_isFunction("laenge")},function(){return jshero.testutil.assert_functionHasNumOfParameter("laenge",1)},function(){return jshero.testutil.assert_functionReturns("laenge('Hallo Welt!')",11)},function(){return jshero.testutil.assert_functionReturns("laenge('')",0)}]});
jshero.koans.add({id:"stringsplit",title:"String: split()",lesson:"Die Methode <code>split</code> zerlegt einen String anhand eines Trennstrings in Teilstrings.\nDie Teilstrings werden als Array zur\xFCckgegeben. Der urspr\xFCngliche String wird nicht ver\xE4ndert.\n\n<pre><code>var date = '31-10-2017';\nvar parts = date.split('-');\nvar day = parts[0]; // '31'\nvar month = parts[1]; // '10'\nvar year = parts[2]; // '2017'</code></pre>\n\nDer Trennstring ist hier der Bindestrich. Er zerlegt den Datumsstring in drei Teile. Diese drei Teile werden als\nArray der Variablen <code>parts</code> zugewiesen. Anschlie\xDFend werden die einzelnen Teile aus dem Array ausgelesen\nund gesonderten Variablen zugewiesen. Die Variable <code>date</code> hat weiterhin den Wert <code>'31-10-2017'</code>.",task:"Schreibe eine Funktion <code>add</code>, die einen String mit einer Additionsaufgabe entgegennimmt und\ndie das Ergebnis der Addition als Zahl zur\xFCckgibt. Es sollen endlich viele nat\xFCrliche Zahlen addiert werden.\nDie Additionsaufgabe ist ein String der Form '1+19+...+281'. So soll <code>add('7+12+100')</code> die Zahl\n<code>119</code> zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("add")},function(){return jshero.testutil.assert_functionHasNumOfParameter("add",1)},function(){return jshero.testutil.assert_functionReturns("add('1+2')",3)},function(){return jshero.testutil.assert_functionReturns("add('12+5+1+10')",28)},function(){return jshero.testutil.assert_functionReturns("add('50000+4000+300+20+1')",54321)},function(){return jshero.testutil.assert_functionReturns("add('13+2+4+100+3')",122)}]});
jshero.koans.add({id:"stringsubstr",title:"String: substr()",lesson:"Die Methode <code>substr</code> extrahiert aus einen String einen Teilstring:\n\n<pre><code>var see = 'see and stop'.substr(0, 3);\nvar and = 'see and stop'.substr(4, 3);\nvar stop = 'see and stop'.substr(8);</code></pre>\n\nDer erste Parameter gibt an, von welcher Stelle an der Substring extrahiert werden soll.\nDer zweite Parameter gibt an, wieviel Zeichen ab der festgelegten Stelle extrahiert werden sollen.\nIst der zweite Paramter nicht angegeben, so wird immer bis zum Ende des urspr\xFCglichen Strings extrahiert.",task:"Schreibe eine Funktion <code>firstWord</code>, die einen String entgegennimmt und das erste Wort\nin diesem String zur\xFCckgibt. Das erste Wort sind dabei alle Zeichen bis zum ersten Leerzeichen.<br><br>Beispiel:\n<code>firstWord('Wo ist hier')</code> sollte <code>'Wo'</code> zur\xFCckgeben.",hint:"<pre><code>var firstWord = function(s) {\n// Bestimme mit indexOf\n// die Position des\n// ersten Leerzeichens.\n// Verwende dann die\n// substr-Methode.\n};</code></pre>",solution:"<pre><code>var firstWord = function(s) {\n  var firstBlank = s.indexOf(' ');\n  return s.substr(0, firstBlank);\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("firstWord")},function(){return jshero.testutil.assert_functionHasNumOfParameter("firstWord",1)},function(){return jshero.testutil.assert_functionReturns("firstWord('Wo ist hier')","Wo")},function(){return jshero.testutil.assert_functionReturns("firstWord('Irres Licht')","Irres")}]});
jshero.koans.add({id:"stringupper",title:"String: toUpperCase()",lesson:"Neben der Eigenschaft <code>length</code> besitzen Strings noch eine Reihe von Methoden.\nDas sind Funktionen, die direkt auf dem String angewendet werden. Wie die Eigenschaft <code>length</code>\nwerden diese Methoden mit einem Punkt direkt dem String oder einer Variablen, die einen String enth\xE4lt, angeh\xE4ngt.\nDa Methoden Funktionen sind, folgen in runden Klammern eingeschlossen die Argumente.\nZwei dieser String-Methoden sind die parameterlosen Methoden <code>toUpperCase</code> und <code>toLowerCase</code>.\nSie geben den String, auf dem sie angewendet werden, in Gro\xDF- bzw. Kleinbuchstaben zur\xFCck. Wichtig ist,\ndass der eigentliche String unver\xE4ndert bleibt. Die R\xFCckgabe dieser Methoden ist der in Gro\xDF- bzw. Kleinbuchstaben\numgewandelte String.\n<pre><code>var stadt = 'Prag';\nvar ausgabe = stadt.toUpperCase();</code/></pre>\n<code>ausgabe</code> erh\xE4lt den Wert <code>'PRAG'</code>. <code>stadt</code> hat weiterhin den Wert <code>'Prag'</code>.\n<pre><code>ausgabe = stadt.toLowerCase();</code/></pre>\nJetzt hat <code>ausgabe</code> den Wert <code>'prag'</code>.\n<pre><code>ausgabe = 'Flug 714'.toUpperCase();</code/></pre>\nHier wird <code>toUpperCase()</code> direkt auf einen String angewendet. Der Wert von <code>ausgabe</code> ist\n<code>'FLUG 714'</code>. Zahlen und auch Sonderzeichen werden nicht ver\xE4ndert.",task:"Schreibe eine Funktion <code>toCase</code>, die bei \xDCbergabe eines Strings diesen aneinandergeh\xE4ngt\nin Klein- und in Gro\xDFschreibung zur\xFCckgibt. Das Trennzeichen zwischen der Klein- und Gro\xDFschreibung soll\n<code>-</code> sein.<br><br>Beispiel: <code>toCase('Ida')</code> sollte <code>'ida-IDA'</code> zur\xFCckgeben.",hint:"<pre><code>var toCase = function(text) {\n  return ... + '-' + ...;\n};</code/></pre>",solution:"<pre><code>var toCase = function(text) {\n  return text.toLowerCase() + '-' + text.toUpperCase();\n};</code/></pre>",tests:[function(){return jshero.testutil.assert_isFunction("toCase")},function(){return jshero.testutil.assert_functionHasNumOfParameter("toCase",1)},function(){return jshero.testutil.assert_functionReturns("toCase('Ida')","ida-IDA")},function(){return jshero.testutil.assert_functionReturns("toCase('Paris')","paris-PARIS")}]});
(function(testutil,evaluator){jshero.koans.add({id:"subfunction",title:"Funktionen rufen Funktionen auf",lesson:"Funktionen k\xF6nnen weitere Funktionen aufrufen:\n<pre><code>var brutto = function(netto) {\n  var steuersatz = 19;\n  var steuer = netto * steuersatz / 100;\n  return netto + steuer;\n};\n\nvar addiereMitMehrwertsteuer = function(nettoX, nettoY) {\n  var bruttoX = brutto(nettoX);\n  var bruttoY = brutto(nettoY);\n  return bruttoX + bruttoY;\n};</code></pre>\n\n<code>addiereMitMehrwertsteuer</code> nimmt 2 Nettobetr\xE4ge entgegen und gibt die Summe der Bruttobetr\xE4ge zur\xFCck.\n<code>brutto</code> berechnet aus einem Nettobetrag den Bruttobetrag. Dabei wird eine Mehrwertsteuer von 19% zugrunde\ngelegt. Anstatt den Bruttobetrag selbst zu berechnen, ruft <code>addiereMitMehrwertsteuer</code> die Funktion\n<code>brutto</code> auf. Das hat zwei Vorteile: Der Code ist besser lesbar und die Bruttoberechnung wird zentral\nan einer Stelle durchgef\xFChrt.",task:"Schreibe eine Funktion <code>sum</code>, die ein Array gef\xFCllt mit Zahlen entgegennimmt und die Summe dieser\nZahlen zur\xFCckgibt. Schreibe eine Funktion <code>mean</code>, die ein Array gef\xFCllt mit Zahlen entgegennimmt und den\nDurchschnitt dieser Zahlen zur\xFCckgibt. Die Funktion <code>mean</code> sollte die Funktion <code>sum</code> benutzen.",tests:[function(){return testutil.assert_isFunction("sum")},function(){return testutil.assert_functionHasNumOfParameter("sum",1)},function(){return testutil.assert_functionReturns("sum([0])",0)},function(){return testutil.assert_functionReturns("sum([1, 2])",3)},function(){return testutil.assert_functionReturns("sum([1, 4, 10, 85])",100)},function(){return testutil.assert_functionReturns("sum([-2, -4, 17, 34])",45)},function(){return testutil.assert_isFunction("mean")},function(){return testutil.assert_functionHasNumOfParameter("mean",1)},function(){return testutil.assert_functionReturns("mean([0])",0)},function(){return testutil.assert_functionReturns("mean([1, 2])",1.5)},function(){return testutil.assert_functionReturns("mean([1, 4, 10, 85])",25)},function(){return testutil.assert_functionReturns("mean([-2, -4, 17, 34])",11.25)}]})})(jshero.testutil,jshero.evaluator);
jshero.koans.add({id:"trim",title:"String: trim()",lesson:"Die Methode <code>trim</code> entfernt Leerzeichen an beiden Enden eines Strings.\nDer an den Enden um Leerzeichen bereinigte String wird zur\xFCckgegeben.\nDer urspr\xFCgliche String bleibt unver\xE4ndert.\n\n<pre><code>var eingabe = ' Rosa Parks ';\nvar name = eingabe.trim();</code></pre>\n\n<code>name</code> enth\xE4lt den String <code>'Rosa Parks'</code>. \nWie angedeutet werden h\xE4ufig Benutzereingaben vor der Verarbeitung getrimmt.",task:"Schreibe eine Funktion <code>firstChar</code>, die bei \xDCbergabe eines Strings das erste Zeichen,\ndas kein Leerzeichen ist, zur\xFCckgibt.<br><br>Beispiel: <code>firstChar(' Rosa')</code> sollte <code>'R'</code>\nzur\xFCckgeben.",hint:"<pre><code>var firstChar = function(text) {\n// Trimme zuerst text.\n// Verwende dann die\n// charAt-Methode.\n};</code></pre>",solution:"<pre><code>var firstChar = function(text) {\n  var textGetrimmt = text.trim();\n  return textGetrimmt.charAt(0);\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("firstChar")},function(){return jshero.testutil.assert_functionHasNumOfParameter("firstChar",1)},function(){return jshero.testutil.assert_functionReturns("firstChar('Rosa')","R")},function(){return jshero.testutil.assert_functionReturns("firstChar(' Louise')","L")},function(){return jshero.testutil.assert_functionReturns("firstChar('  Parks')","P")}]});
(function(testutil){jshero.koans.add({id:"undefined",title:"undefined",lesson:"Bisher hatten wir Variablen bei der Deklaration immer auch initialisiert.\n\n<pre><code>// Deklaration und Initialisierung\nvar x = 1;</code></pre>\n\nMan kann eine Variable aber auch deklarieren und ihr sp\xE4ter einen Wert zuweisen.\n\n<pre><code>var x; // Deklaration\nx = 1; // Initialisierung</code></pre>\n\nVariablen, die nicht initialisiert wurden, haben den Wert <code>undefined</code> (engl.: nicht definiert).<br><br>\nNicht initialisierte Variablen k\xF6nnen auch bei Funktionsaufrufen vorkommen. Ruft man eine Funktion, die einen Parameter\nerwartet, ohne Argument auf, dann erh\xE4lt der Funktionsparameter den Wert <code>undefined</code>.\n\n<pre><code>var echo = function(x) {\n  return x;\n};\n\n// Aufruf ohne Argument\nvar y = echo();</code></pre>\n\n<code>echo</code> wird ohne Argument aufgerufen. Dem Parameter <code>x</code> wird so kein Wert zugewiesen,\ner erh\xE4lt den Wert <code>undefined</code>.\nDa <code>echo</code> den Parameter <code>x</code> einfach zur\xFCckgibt,\nerh\xE4lt auch <code>y</code> den Wert <code>undefined</code>.<br><br>\nEine Funktion, die einen Parameter erwartet, kann immer auch ohne Argument aufgerufen werden.\nMan sollte sich beim Schreiben von Funktionen immer \xFCberlegen, was in diesem Fall passieren soll.\nGute Praxis ist es, in einem solchen Fall dem Parameter einen Default-Wert (engl.: Vorgabe) zuzuweisen.\nDas hatten wir schon bei der String-Methode <code><a href=\"stringcharat.html\">charAt(index)</a></code> kennen gelernt.\nNormalerweise gibt diese Methode das Zeichen an der Stelle <code>index</code>\nzur\xFCck. Rufen wir <code>charAt</code> ohne Argument auf, erh\xE4lt <code>index</code> den Default <code>0</code>.\nEs wird das Zeichen an der Stelle <code>0</code> zur\xFCckgegeben.<br><br>\nUm eine deklarierte Varaible auf <code>undefined</code> zu \xFCberpr\xFCfen, verwendet man wie \xFCblich die\n<a href='equals.html'>strikte&nbsp;Gleichkeit</a>.\nDie Methode <code>charAt</code> k\xF6nnte also folgenden Code-Ausschnitt enthalten:\n\n<pre><code>if (index === undefined) {\n  index = 0;\n}</code></pre>",task:"Schreibe eine Funktion <code>hallo</code>, die einen String als Parameter entgegennimmt und <code>'Hallo &lt;Parameter&gt;!'</code> zur\xFCckgibt.\n<code>hallo('Akg\xFCn')</code> sollte <code>'Hallo Akg\xFCn!'</code> zur\xFCckgeben.\nWird <code>hallo</code> ohne Argument aufgerufen, so soll <code>'Hallo Welt!'</code> zur\xFCckgegeben werden.",tests:[function(){return testutil.assert_isFunction("hallo")},function(){return testutil.assert_functionHasNumOfParameter("hallo",1)},function(){return testutil.assert_functionReturns("hallo('Melek')","Hallo Melek!")},function(){return testutil.assert_functionReturns("hallo('Badu')","Hallo Badu!")},function(){return testutil.assert_functionReturns("hallo()","Hallo Welt!")}]})})(jshero.testutil);
jshero.koans.add({id:"utc",title:"Weltzeit",lesson:"Wenn man mit Datum und Uhrzeit arbeitet, muss man zwischen\n<a href='https://de.wikipedia.org/wiki/Koordinierte_Weltzeit'>koordinierter Weltzeit</a> (UTC, engl. Coordinated Universal Time) und\n<a href='https://de.wikipedia.org/wiki/Zonenzeit'>Zonenzeit</a> unterscheiden.\nDie koordinierte Weltzeit stellt weltweit eine einheitliche Zeitangabe her.\nDie Zonenzeit ist die in einer Zeitzone geltende Zeit.\nVon der koordinierten Weltzeit werden die verschiedenen Zonenzeiten abgeleitet.\nSo ergibt sich die <a href='https://de.wikipedia.org/wiki/Mitteleurop%C3%A4ische_Zeit'>Mitteleurop\xE4ische Zeit (MEZ)</a>\naus der koordinierten Weltzeit durch Addition von einer Stunde (kurz UTC+1). Die Mitteleurop\xE4ische Sommerzeit (MESZ) entspricht\nUTC+2. UTC selbst ist die Zonenzeit der Westeurop\xE4ischen Zeit (WEZ).<br><br>\nWas wir bisher \xFCber das Date-Objekt gelernt haben, bezog sich im Wesentlichen auf die Zonenzeit. So liefert der Ausdruck\n<code>new Date(2018, 4, 5)</code> ein Date-Objekt, das dem Zeitpunkt 5.5.2018, 0:00 Uhr in lokaler Zeit entspricht.\nMacht man diesen Aufruf in Deutschland, erh\xE4lt man den Zeitpunkt 5.5.2018, 0:00 UTC+2 (Sommerzeit!). In Japan liefert derselbe Aufruf\nden Zeitpunkt 5.5.2018, 0:00 UTC+9. Zwischen beiden Zeitpunkten liegt eine Differenz von 7 Stunden.\nM\xF6chte man weltweit einen einheitlichen Zeitpunkt erzeugen, so muss man die koordinierte Weltzeit verwenden:\n<pre><code>var millis = Date.UTC(2018, 4, 5);\nvar datum = new Date(millis);</code></pre>\nMit <code>Date.UTC</code> erh\xE4lt man zun\xE4chst die vergangenen Millisekunden seit dem 1.1.1970, 0:00 UTC.\nMit dieser Zahl und <code>new Date()</code> erzeugt man anschlie\xDFend das gew\xFCnschte Date-Objekt\n(siehe <a href='date.html'>Datum und Uhrzeit</a>). Die Variable <code>datum</code> repr\xE4sentiert den\n5.5.2018, 0:00 UTC.",task:"Schreibe eine Funktion <code>nikolausUTC</code>, die eine Jahreangabe als Zahl entgegennimmt und die ein Date-Objekt mit dem 6. Dezember\ndes \xFCbergebenen Jahres, 0:00 UTC, zur\xFCckgibt. <code>nikolaus(2017)</code> sollte ein Date-Objekt mit dem Zeitpunkt 6.12.2017, 0:00 UTC zur\xFCckgeben.",tests:[function(){return jshero.testutil.assert_isFunction("nikolausUTC")},function(){return jshero.testutil.assert_functionHasNumOfParameter("nikolausUTC",1)},function(){return jshero.testutil.assert_functionReturnsType("nikolausUTC(2017)","Date")},function(){return jshero.testutil.assert_functionReturns("nikolausUTC(2017)",new Date(Date.UTC(2017,11,6)),{"utc":true})},function(){return jshero.testutil.assert_functionReturnsType("nikolausUTC(1960)","Date")},function(){return jshero.testutil.assert_functionReturns("nikolausUTC(1960)",new Date(Date.UTC(1960,11,6)),{"utc":true})}]});
(function(testutil){jshero.koans.add({id:"var",title:"Variablen",lesson:"<a href='https://de.wikipedia.org/wiki/JavaScript'>JavaScript</a>-Programme bestehen\naus einer Reihe von Anweisungen. Jede Anweisung f\xFChrt eine elementare Operation durch.\nDurch das Ausf\xFChren vieler Anweisungen kann man schlie\xDFlich komplexe Aufgaben l\xF6sen.\nJede Anweisung schreibt man in eine Zeile und schlie\xDFt sie mit einem Semikolon ab.<br><br>\nEine elementare Anweisung ist die Deklaration und Initialisierung einer Variablen.\nIn der Programmierung ist eine Variable ein Beh\xE4lter f\xFCr einen Wert.\nMit der Anweisung\n\n<pre><code>var stadt = 'Prag';</code></pre>\n\ndeklariert man eine Variable mit dem Namen <code>stadt</code> und initialisiert sie mit dem Wert <code>'Prag'</code>.\nMit dem Schl\xFCsselwort <code>var</code> wird die Variable deklariert.\nMit dem Gleichheitszeichen, dem Zuweisungsoperator, weist man der Variablen einen Wert zu.<br><br>\nBeachte: JavaScript unterscheidet zwischen Gro\xDF- und Kleinschreibung. <code>stadt</code> und <code>Stadt</code> sind\nzwei verschiedene Variablen. Man sagt auch: JavaScript ist case sensitive.",task:"Deklariere eine Variable <code>vorname</code> und initialisiere sie mit dem Wert <code>'Franz'</code>.",hint:"<pre><code>var vorname = ...</code></pre>",solution:"<pre><code>var vorname = 'Franz';</code></pre>",tests:[function(){return testutil.assert_variableDefined("vorname")},function(){return testutil.assert_variableHasValue("vorname","Franz")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"var2",title:"Mehrere Variablen",lesson:"M\xF6chte man mehrere Variablen deklarieren und initialisieren, so kann man das in zwei Programmzeilen tun:\n\n<pre><code>var stadt = 'Prag';\nvar land = 'Tschechien';</code></pre>\n\nIn jeder Zeile steht eine Anweisung. Jede Anweisung sollte mit einem Semikolon abgeschlossen werden.",task:"Deklariere eine Variable <code>blume</code> und weise ihr den Wert <code>'Rose'</code> zu.\nDeklariere eine zweite Variable <code>tier</code> und weise ihr den Wert <code>'K\xE4fer'</code> zu.",tests:[function(){return testutil.assert_variableDefined("blume")},function(){return testutil.assert_variableHasValue("blume","Rose")},function(){return testutil.assert_variableDefined("tier")},function(){return testutil.assert_variableHasValue("tier","K\xE4fer")}]})})(jshero.testutil);
jshero.koans.add({id:"while",title:"while-Schleife",lesson:"Die <code>while</code>-Schleife besitzt nur eine Schleifen-Bedingung.\nDer Schleifen-Code wird ausgef\xFChrt, solange die Bedingung <code>true</code> ergibt.\nErgibt die Bedingung <code>false</code>, wird die Schleife beendet und die Codeausf\xFChrung\nwird nach der Schleife fortgesetzt.\n\n<pre><code>var dreiX = '';\nwhile (dreiX.length < 3) {\n  dreiX = dreiX + 'x';\n}</code></pre>\n\nSolange <code>dreiX</code> weniger als 3 Zeichen besitzt, wird es um <code>'x'</code> erg\xE4nzt.\nHat <code>dreiX</code> die L\xE4nge 3, wird die Schleife beendet.\n<code>dreiX</code> hat dann den Wert <code>'xxx'</code>.",task:"Schreibe eine Funktion <code>abstand</code>, die eine nat\xFCrliche Zahl n als Parameter\nentgegennimmt und die einen String bestehend aus n Leerzeichen zur\xFCckgibt.\n<code>abstand(1)</code> sollte <code>' '</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("abstand")},function(){return jshero.testutil.assert_functionHasNumOfParameter("abstand",1)},function(){return jshero.testutil.assert_functionReturns("abstand(0)","")},function(){return jshero.testutil.assert_functionReturns("abstand(1)"," ")},function(){return jshero.testutil.assert_functionReturns("abstand(2)","  ")},function(){return jshero.testutil.assert_functionReturns("abstand(3)","   ")}]});
jshero.koans.add({id:"xor",title:"XOR",lesson:"Die logischen Operatoren kennen, \xE4hnlich der Punkt- vor Strich-Rechnung, eine Reihenfolge:\nNICHT zuerst, anschlie\xDFend UND, zuletzt ODER. M\xF6chte man diese Reihenfolge \xE4ndern, verwendet man Klammern:\n\n<pre><code>var x1 = true || false && false;\nvar x2 = (true || false) && false;\nvar x3 = !false && false;\nvar x4 = !(false && false);</code></pre>\n\nIn der ersten Zeile wird zuerst UND ausgewertet. <code>x1</code> wird <code>true</code>.\nIn der zweiten Zeile wird zuerst ODER ausgewertet. <code>x2</code> wird <code>false</code>.\nIn der dritten Zeile wird zuerst NICHT ausgewertet. <code>x3</code> wird <code>false</code>.\nUnd in der vierten Zeile wird zuerst UND ausgewertet. <code>x4</code> wird <code>true</code>.<br><br>\nIn der folgenden Aufgabe sollst du ein weiteres wichtiges Gatter, das XOR-Gatter (engl.: eXclusive OR - exklusives oder),\nprogrammieren.",task:"Schreibe eine Funktion <code>xor</code>, die zwei boolesche Werte als Parameter entgegennimmt.\nDie R\xFCckgabe der Funktion soll <code>true</code> sein, wenn beide Paramter verschieden sind.\nIn den anderen F\xE4llen soll die R\xFCckgabe <code>false</code> sein.<br><br>D.h.: <code>xor(true, false)</code> und\n<code>xor(false, true)</code> sollen <code>true</code> liefern, <code>xor(true, true)</code> und\n<code>xor(false, false)</code> sollen <code>false</code> zur\xFCckgeben.",hint:"Schreibe einen Ausdruck, der nur dann <code>true</code> ergibt, wenn der erste Parameter <code>true</code> und\nder zweite <code>false</code> ist. Schreibe dann einen Ausdruck, der nur dann <code>true</code> ergibt, wenn der erste\nParameter <code>false</code> und der zweite <code>true</code> ist. Verkn\xFCpfe beide Ausdr\xFCcke angemessen.\nKlammern sind bei der L\xF6sung nicht n\xF6tig.",solution:"<pre><code>var xor = function(a, b) {\n  return a && !b || !a && b;\n};</code></pre>",tests:[function(){return jshero.testutil.assert_isFunction("xor")},function(){return jshero.testutil.assert_functionHasNumOfParameter("xor",2)},function(){return jshero.testutil.assert_functionReturns("xor(true, true)",false)},function(){return jshero.testutil.assert_functionReturns("xor(true, false)",true)},function(){return jshero.testutil.assert_functionReturns("xor(false, true)",true)},function(){return jshero.testutil.assert_functionReturns("xor(false, false)",false)}]});
jshero.koans.initReorder(["var","jsx01","var2","jsx02","jsx03","function","function2","functioncall","jsx04","parameter","jsx05","parameter2a","string","jsx06","jsx06b","log1","log2","log","jsx07","stringlength","stringupper","stringcharat","trim","stringindexof","stringindexof2","stringsubstr","replace","number","increment","fahrenheit","modulo","mean","math","minmax","pi","round","random","parseint","numbertostring","bool","nor","xor","equals","equals2","even","notequals","greaterthan","if","if2","else","elseif","array","array2","array3","arraylength","arraysort","arraypush","arrayindexof","concat","slice","join","dimarray","comment","for1","fakultaet","for2","while","dowhile","ggt","break","bubblesort","doubleloop","arguments","undefined","null","nan","stringsplit","date","date2","date3","utc","gettime","subfunction","recursion","roman1","roman2","object1","object2","object3","object4","method1","regex1","regex2","regex3","regex4","regexnot","regex5neu","regexescape","regex5a","regexword","regexor","regexi","regex6","regex7","regex8","regexgroup","regexexec","further"]);

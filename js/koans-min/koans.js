jshero.koans.add({id:'arguments',title:'Das arguments-Objekt',lesson:'Das <code>arguments</code>-Objekt ist eine in jeder Funktion verf\xFCgbare Variable. '+'Es ist ein Array \xE4hnliches Objekt, das die \xFCbergebenen Argumente einer Funktion der Reihe nach enth\xE4lt. '+'<pre><code>'+'var add = function() {<br>'+'  var arg0 = arguments[0];<br>'+'  var arg1 = arguments[1];<br>'+'  return arg0 + arg1;<br>'+'};<br><br>'+'var sum = add(1, 2);'+'</code></pre>'+'Hier wird <code>add</code> mit den Argumenten <code>1</code> und <code>2</code> aufgerufen. <code>arguments[0]</code> enth\xE4lt also den Wert <code>1</code>, '+'<code>arguments[1]</code> den Wert <code>2</code>. '+'Mit dem <code>arguments</code>-Objekt kann man ohne Parameter auf die \xFCbergebenen Argumente zugreifen. '+'Das ist z.B. dann praktisch, wenn man eine Funktion schreiben m\xF6chte, die eine beliebige Anzahl von Argumenten verarbeiten soll.'+'<pre><code>'+'var add = function() {<br>'+'  var sum = 0;<br>'+'  for (var i = 0; i < arguments.length; i++) {<br>'+'    sum = sum + arguments[i];<br>'+'  }<br>'+'  return sum;<br>'+'};<br><br>'+'var s1 = add(2, 4);<br>'+'var s2 = add(2, 3, 5, 7);<br>'+'</code></pre>'+'Hier iterieren wir \xFCber alle \xFCbergebenen Argumente und summieren sie auf. <code>arguments.length</code> liefert dabei die Anzahl der \xFCbergebenen Argumente. '+'Nun k\xF6nnen wir <code>add</code> mit einer beliebigen Anzahl von Argumenten aufrufen.',task:'Schreibe eine Funktion <code>maximum</code>, die beliebig viele Zahlen entgegennimmt und das Maximum dieser Zahlen liefert. '+'<code>maximum(12, 68, 3, 52)</code> sollte <code>68</code> ergeben.',beforeTests:function(){if(typeof maximum!=='undefined'){maximum=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('maximum')},function(){return jshero.testutil.assert_functionReturns('maximum()','')},function(){return jshero.testutil.assert_functionReturns('maximum(1)',1)},function(){return jshero.testutil.assert_functionReturns('maximum(15, 2)',15)},function(){return jshero.testutil.assert_functionReturns('maximum(1, 15)',15)},function(){return jshero.testutil.assert_functionReturns('maximum(1, 7, 3, 9, 2)',9)}]});
jshero.koans.add({id:'array',title:'Arrays anlegen',lesson:'Arrays sind Objekte zur Speicherung vieler, meist \xE4hnlicher Werte. Diese sogenannten Elemente werden '+'in einem Array der Reihe nach abgelegt. Arrays erzeugt man am besten mit eckigen Klammern.'+'<pre><code>var sprachen = ["C", "C++", "Java", "JavaScript"];<br>'+'var primzahlen = [2, 3, 5, 7, 11];<br>'+'var leeresArray = [];<br>'+'var a = "Douglas";<br>'+'var b = 12;<br>'+'var c = true;<br>'+'var allesMoegliche = [a, b, c];</code></pre>'+'Die Elemente eines Arrays k\xF6nnen, wie das letzte Beispiel zeigt, alle einen anderen Datentyp besitzen.',task:'Schreibe eine Funktion <code>toArray</code>, die 2 Paramter entgegennimmt und diese als Array zur\xFCckgibt. '+'<code>toArray(5, 9)</code> sollte das Array <code>[5, 9]</code> ergeben.',beforeTests:function(){if(typeof toArray!=='undefined'){toArray=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('toArray')},function(){return jshero.testutil.assert_functionHasNumOfParameter('toArray',2)},function(){var ok,msg,e;try{var result=toArray(1,2);ok=Array.isArray(result);if(ok){msg='<code>toArray(1, 2)</code> gibt ein Array zur\xFCck.'}else{msg='<code>toArray(1, 2)</code> gibt kein Array zur\xFCck.'}}catch(exc){ok=false;msg=jshero.i18n.get('errorAtCallOf')+' <code>toArray(1, 2)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){return jshero.testutil.assert_functionReturns('toArray(1, 2)',[1,2])},function(){return jshero.testutil.assert_functionReturns('toArray("H\xE4nsel", "Gretel")',['H\xE4nsel','Gretel'])},function(){return jshero.testutil.assert_functionReturns('toArray(1, "Maus")',[1,'Maus'])}]});
jshero.koans.add({id:'array2',title:'Array-Elemente lesen',lesson:'Die Elemente eines Arrays werden mit einem Index beginnend mit 0 ausgelesen. '+'<pre><code>var sprachen = ["C", "C++", "Java", "JavaScript"];<br>'+'var c = sprachen[0];<br>'+'var cPlusPlus = sprachen[1];<br>'+'var java = sprachen[2];<br>'+'var javaScript = sprachen[3];',task:'Schreibe eine Funktion <code>getFirstElement</code>, die ein Array entgegennimmt und die das erste Element des Arrays zur\xFCckgibt. '+'<code>getFirstElement([1, 2])</code> sollte <code>1</code> zur\xFCckgeben.',beforeTests:function(){if(typeof getFirstElement!=='undefined'){getFirstElement=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('getFirstElement')},function(){return jshero.testutil.assert_functionHasNumOfParameter('getFirstElement',1)},function(){return jshero.testutil.assert_functionReturns('getFirstElement([1, 2])',1)},function(){return jshero.testutil.assert_functionReturns('getFirstElement(["H\xE4nsel", "Gretel"])','H\xE4nsel')},function(){return jshero.testutil.assert_functionReturns('getFirstElement(["Maus", 1])','Maus')}]});
jshero.koans.add({id:'array3',title:'Array-Elemente schreiben',lesson:'Ebenso wie man Array-Elemente \xFCber einen Index auslesen kann, kann man sie \xFCber diesen Index setzen. '+'Dabei spielt es keine Rolle, ob das Array vorher gef\xFCllt oder leer war.'+'<pre><code>var sprachen = [];<br>'+'sprachen[0] = "C";<br>'+'sprachen[1] = "C++";<br>'+'sprachen[2] = "Java";<br>'+'sprachen[3] = "JavaScript";</code></pre>'+'Hier wird ein leeres Array nacheinander mit den aufgef\xFChrten Werten gef\xFCllt.',task:'Schreibe eine Funktion <code>setFirstElement</code>, die ein Array und eine beliebige Variable entgegennimmt. '+'Die Variable soll als erstes Element in das Array geschrieben werden. Das Array soll dann zur\xFCckgegeben werden. '+'<code>setFirstElement([1, 2], 3)</code> sollte <code>[3, 2]</code> zur\xFCckgeben.',beforeTests:function(){if(typeof setFirstElement!=='undefined'){setFirstElement=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('setFirstElement')},function(){return jshero.testutil.assert_functionHasNumOfParameter('setFirstElement',2)},function(){return jshero.testutil.assert_functionReturns('setFirstElement([1, 2], 3)',[3,2])},function(){return jshero.testutil.assert_functionReturns('setFirstElement(["Hein", "Gretel"], "H\xE4nsel")',['H\xE4nsel','Gretel'])},function(){return jshero.testutil.assert_functionReturns('setFirstElement([1, "Maus"], "kleine")',['kleine','Maus'])}]});
jshero.koans.add({id:'arraylength',title:'Array: length',lesson:'Die Eigenschaft <code>length</code> hatten wird schon bei Strings kennengelernt. Dort gab sie die Anzahl '+'der Zeichen eines Strings zur\xFCck. Bei Arrays gibt sie die Anzahl der Elemente zur\xFCck. '+'<pre><code>var sprachen = [];<br>'+'var l0 = sprachen.length;<br>'+'sprachen[0] = "C";<br>'+'var l1 = sprachen.length;<br>'+'sprachen[1] = "C++";<br>'+'var l2 = sprachen.length;</code></pre>'+'Das leere Array zu Anfang enth\xE4llt keine Elemente. <code>l0</code> ist also <code>0</code>. '+'Nun f\xFCllen wir das Array nach und nach. <code>l1</code> und <code>l2</code> haben dann die Werte <code>1</code> und <code>2</code>. '+'Beachte: Die L\xE4nge eines Arrays ist immer um 1 gr\xF6\xDFer als der h\xF6chste Index des Arrays.',task:'Schreibe eine Funktion <code>getLastElement</code>, die ein Array entgegennimmt und die das letzte Element des Arrays zur\xFCckgibt. '+'<code>getLastElement([1, 2])</code> sollte <code>2</code> zur\xFCckgeben.',beforeTests:function(){if(typeof getLastElement!=='undefined'){getLastElement=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('getLastElement')},function(){return jshero.testutil.assert_functionHasNumOfParameter('getLastElement',1)},function(){return jshero.testutil.assert_functionReturns('getLastElement([1, 2])',2)},function(){return jshero.testutil.assert_functionReturns('getLastElement(["H\xE4nsel", "Gretel"])','Gretel')},function(){return jshero.testutil.assert_functionReturns('getLastElement(["a", "b", "c"])','c')},function(){var testArray=new Array;var testArrayString='[';var size=15;for(var i=0;i<size-1;i++){testArray[i]=Math.random();testArrayString+=testArray[i]+', '}testArray[size-1]=Math.random();testArrayString+=testArray[size-1]+']';return jshero.testutil.assert_functionReturns('getLastElement('+testArrayString+')',testArray[size-1])},function(){return jshero.testutil.assert_functionReturns('getLastElement(["Maus", 1])',1)}]});
(function(array){jshero.koans.add({id:'arraypush',title:'Array: shift() und push()',lesson:'Arrays besitzen eine Reihe von Methoden. Zwei dieser Methoden sind <code>shift</code> und <code>push</code>. '+'Zur Erinnerung: Methoden sind Funktionen, die auf einem Objekt, hier einem Array, ausgef\xFChrt werden. Methoden werden mit einem Punkt '+'an das Objekt angeh\xE4ngt. Wie bei Funktionen \xFCblich folgt dem Methodennamen die runden Klammern, ggf. gef\xFCllt mit Parametern. '+'<code>shift</code> hat keine Parameter und verschiebt die Elemente eines Arrays nach links. '+'Das 1te Element wird zum 0ten, das 2te zum 1ten, das 3te zum 2ten, usw. '+'Das 0te Element wird aus dem Array entfernt und zur\xFCckgegeben. Nach dem <code>shift</code> hat das Array ein Element weniger.'+'<pre><code>var sprachen = ["C", "Java", "JavaScript"];<br>'+'var naechsteSprache = sprachen.shift();</code></pre>'+'Das Array <code>sprachen</code> wird mit 3 Programmiersprachen angelegt. Nach dem <code>shift</code> enth\xE4lt <code>sprachen</code> '+'nur noch 2 Elemente, n\xE4mlich <code>["Java", "JavaScript"]</code>. Der Wert <code>"C"</code> ist in der Variablen '+'<code>naechsteSprache</code> gelandet.<br>'+'Mit der h\xE4ufig verwendeten Methode <code>push</code> f\xFCgt man dem Array ein neues Element hinzu. '+'Das neue Element wird als Parameter \xFCbergeben und an das Ende des Arrays geh\xE4ngt.'+'<pre><code>var sprachen = [];<br>'+'sprachen.push("C");<br>'+'sprachen.push("Java");<br>'+'sprachen.push("JavaScript");</code></pre>'+'Hier wird ein leeres Array nacheinander mit den aufgef\xFChrten Werten gef\xFCllt. Am Ende erhalten wir das Array '+'<code>["C", "Java", "JavaScript"]</code>. Wir hatten gesehen, dass man ein Array auch per Index f\xFCllen kann. '+'<code>sprachen[sprachen.length] = "PHP"</code> ist dasselbe wie <code>sprachen.push("PHP")</code>. Doch schon '+'an der L\xE4nge des Codes sieht man, dass die Variante mit <code>push</code> eleganter ist.',task:'Schreibe eine Funktion <code>rotiere</code>, die die Elemente eines Arrays rotiert. Alle Elemente des Arrays sollen um eine '+'Position nach links verschoben werden. Das 0te Element soll ans Ende des Arrays gestellt werden. Das rotierte Array soll zur\xFCckgegeben werden. '+'<code>rotiere(["a", "b", "c"])</code> sollte <code>["b", "c", "a"]</code> ergeben.',beforeTests:function(){if(typeof rotiere!=='undefined'){rotiere=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('rotiere')},function(){return jshero.testutil.assert_functionHasNumOfParameter('rotiere',1)},function(){return jshero.testutil.assert_functionReturns('rotiere([1, 2])',[2,1])},function(){return jshero.testutil.assert_functionReturns('rotiere(["a", "b", "c"])',['b','c','a'])},function(){return jshero.testutil.assert_functionReturns('rotiere([1, "b", "c", 37])',['b','c',37,1])}]})})(jshero.array);
jshero.koans.add({id:'arraysort',title:'Arrays sortieren',lesson:'Wir k\xF6nnen jetzt Arrays mit vorgegebener L\xE4nge sortieren.',task:'Schreibe eine Funktion <code>sortiere</code>, die ein mit 3 Zahlen gef\xFClltes Array entgegennimmt und die diese 3 Zahlen aufsteigend sortiert als Array  zur\xFCckgibt. '+'<code>sortiere([2,&nbsp;3,&nbsp;1])</code> sollte <code>[1,&nbsp;2,&nbsp;3]</code> ergeben.',beforeTests:function(){if(typeof sortiere!=='undefined'){sortiere=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('sortiere')},function(){return jshero.testutil.assert_functionHasNumOfParameter('sortiere',1)},function(){return jshero.testutil.assert_functionReturns('sortiere([3, 1, 2])',[1,2,3])},function(){return jshero.testutil.assert_functionReturns('sortiere([3, 2, 1])',[1,2,3])},function(){return jshero.testutil.assert_functionReturns('sortiere(["c", "a", "b"])',['a','b','c'])}]});
jshero.koans.add({id:"bool",title:"Wahrheitswerte",lesson:"Der dritte wichtige Datentyp neben Strings und Zahlen sind Wahrheitswerte. Sie werden auch boolesche Werte genannt. Boolesche Werte kennen nur zwei Zust\xE4nde: "+"<code>true</code> und <code>false</code>. Mit booleschen Werten kann man \xE4hnlich \"rechnen\" wie mit Zahlen. JavaScript kennt drei boolesche Operatoren: "+"<code>&&</code> (und), <code>||</code> (oder) und <code>!</code> (nicht). Das Ergebnis dieser Operationen ist wieder ein boolescher Wert. "+"<code>&&</code> verkn\xFCpft zwei boolesche Werte. Sind beide Werte <code>true</code>, ist das Ergebnis auch <code>true</code>. In allen anderen F\xE4llen "+"ist es <code>false</code>. Bei <code>||</code> ist das Ergebnis <code>false</code>, wenn beide Eingangswerte auch <code>false</code> sind. In  allen "+"anderen F\xE4llen ist das Ergebnis <code>true</code>. <code>!</code> wird nur auf einen booleschen Wert angewendet und invertiert diesen Wert: aus "+"<code>true</code> wird <code>false</code> und aus <code>false</code> wird <code>true</code>."+"<pre><code>var x1 = true && false;<br>var x2 = !x1;<br>var x3 = x1 || x2;</code></pre>"+"<code>x1</code> ist <code>false</code>,  <code>x2</code> ist <code>true</code> und <code>x3</code> ist ebenfalls <code>true</code>.",task:"Schreibe eine Funktion <code>nand</code>, die zwei boolesche Werte als Parameter entgegennimmt. Die R\xFCckgabe der Funktion soll <code>false</code> sein, "+"wenn beide Paramter <code>true</code> sind. In den anderen F\xE4llen soll die R\xFCckgabe <code>true</code> sein. <code>nand(true, true)</code> "+"soll <code>false</code> liefern, <code>nand(true, false)</code>, <code>nand(false, true)</code> und <code>nand(false, false)</code> sollen <code>true</code> zur\xFCckgeben.",beforeTests:function(){if(typeof nand!=="undefined"){nand=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("nand")},function(){return jshero.testutil.assert_functionHasNumOfParameter("nand",2)},function(){return jshero.testutil.assert_functionReturns("nand(true, true)",false)},function(){return jshero.testutil.assert_functionReturns("nand(true, false)",true)},function(){return jshero.testutil.assert_functionReturns("nand(false, true)",true)},function(){return jshero.testutil.assert_functionReturns("nand(false, false)",true)}]});
jshero.koans.add({id:'break',title:'break und continue',lesson:'Mit <code>break</code> wird eine Schleife beendet. Das Programm wird nach der Schleife fortgesetzt. '+'<pre><code>var satz = "So ist das.";<br>'+'var i;<br>'+'for (i = 0; i < satz.length; i++) {<br>'+'  if (satz.charAt(i) === " ") {<br>'+'    break;<br>'+'  }<br>'+'}<br>'+'var laengeErstesWort = i;</code></pre>'+'Ist das Zeichen mit dem Index <code>i</code> in <code>satz</code> das Leerzeichen, ist die <code>if</code>-Bedingung erf\xFCllt '+'und der <code>break</code>-Befehl wird ausgef\xFChrt. Die Schleife wird beendet und die Codeausf\xFChrung wird '+'nach der Schleife fortgesetzt. In unserem Beispiel ist das Zeichen mit dem Index <code>2</code> das Leerzeichen. Sobald die Schleifenvariable <code>i</code> '+'den Wert <code>2</code> erreicht hat, wird die Schleife beendet. <code>laengeErstesWort</code> bekommt dann den Wert <code>2</code> zugewiesen.<br><br>'+'Mit <code>continue</code> wird der aktuelle Schleifendurchlauf beendet. Die Programmausf\xFChrung springt zum Schleifenkopf.'+'<pre><code>var summe = 0;<br>'+'for (var i = 0; i < 10; i++) {<br>'+'  if (i % 2 === 0) {<br>'+'    continue;<br>'+'  }<br>'+'  summe = summe + i;<br>'+'}<br></code></pre>'+'Ist <code>i</code> eine ungerade Zahl, so gilt: i modulo 2 = 1. Die <code>if</code> - Bedingung ist nicht erf\xFCllt. '+'Die Codeausf\xFChrung wird nach dem <code>if</code> fortgesetzt und <code>i</code> wird zu <code>summe</code> hinzugez\xE4hlt. '+'Ist <code>i</code> eine gerade Zahl, so gilt: i modulo 2 = 0. Die <code>if</code> - Bedingung ist erf\xFCllt und <code>continue</code> wird ausgef\xFChrt. '+'Die Code-Ausf\xFChrung springt direkt zum Schleifenkopf. <code>i</code> wird nicht zu <code>summe</code> hinzugez\xE4hlt. '+'So werden alle ungeraden Zahlen kleiner 10 aufaddiert.<br>'+'<code>break</code> und <code>continue</code> kann man in allen Schleifen (for, while, do...while) verwenden.',task:'Schreibe eine Funktion <code>isPrime</code>. Sie soll pr\xFCfen, ob eine \xFCbergebene Zahl eine Primzahl ist oder nicht. Ist die '+'Zahl prim, so soll <code>true</code> zur\xFCckgegeben werden, im anderen Fall <code>false</code>. '+'Der Aufruf <code>isPrime(2)</code> soll <code>true</code> zur\xFCckgeben, <code>isPrime(4)</code> soll <code>false</code> ergeben. '+'Eine Primzahl ist eine nat\xFCrliche Zahl, die gr\xF6\xDFer als 1 und nur durch sich selbst und durch 1 teilbar ist.',beforeTests:function(){if(typeof isPrime!=='undefined'){isPrime=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('isPrime')},function(){return jshero.testutil.assert_functionHasNumOfParameter('isPrime',1)},function(){return jshero.testutil.assert_functionReturns('isPrime(1)',false)},function(){return jshero.testutil.assert_functionReturns('isPrime(2)',true)},function(){return jshero.testutil.assert_functionReturns('isPrime(3)',true)},function(){return jshero.testutil.assert_functionReturns('isPrime(4)',false)},function(){return jshero.testutil.assert_functionReturns('isPrime(11)',true)},function(){return jshero.testutil.assert_functionReturns('isPrime(351)',false)},function(){return jshero.testutil.assert_functionReturns('isPrime(281)',true)}]});
(function(ArrayUtil){jshero.koans.add({id:'bubblesort',title:'Bubblesort',lesson:'H\xE4ufig m\xF6chte man Daten der Gr\xF6\xDFe nach sortieren. Hierf\xFCr gibt es verschiedene Sortierverfahren. Ein bekanntes, '+'einfaches, aber auch langsames Verfahren ist <a href="https://de.wikipedia.org/wiki/Bubblesort" target="_blank">Bubblesort</a>. Liegen die zu sortierenden Daten in einem Array der L\xE4nge n vor '+'und sollen die Daten aufsteigend sortiert werden, so wird in einer sogenannten Bubble-Phase das Array vom 1 &apos;ten bis zum n-1 &apos;ten Element durchlaufen. '+'Dabei wird in jedem Schritt das aktuelle Element an der Stelle i mit dem nachfolgenden Element an der Stelle i+1 verglichen. Ist das Element an der Stelle i gr\xF6\xDFer als das '+'Element an der Stelle i+1, so vertauscht man beide Elemente. Hat man so eine Bubble-Phase durchlaufen, ist das gr\xF6\xDFte Element am Ende des Arrays angekommen. '+'Wiederholt man nun eine Bubble-Phase, so steht auch das zweitgr\xF6\xDFte Element an der richtigen Stelle. Hat man n-1 Bubble-Phasen durchlaufen, ist das komplette Array sortiert. '+'Um ein Array mit 4 Zahlen zu sortieren, ben\xF6tigt man also drei Bubble-Phasen:'+'<pre><code>'+'Erste Bubble-Phase:<br>'+'[4, 2, 3, 1] -> [2, 4, 3, 1] Das erste Element wird mit dem zweiten verglichen. Sie werden vertauscht, da 4>2 ist.<br>'+'[2, 4, 3, 1] -> [2, 3, 4, 1] Das zweite Element wird mit dem dritten verglichen. Sie werden vertauscht, da 4>3 ist.<br>'+'[2, 3, 4, 1] -> [2, 3, 1, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden vertauscht, da 4>1 ist.<br>'+'Das gr\xF6\xDFte Element ist an die richtige Stelle geblubbert.<br><br>'+'Zweite Bubble-Phase:<br>'+'[2, 3, 1, 4] -> [2, 3, 1, 4] Das erste Element wird mit dem zweiten verglichen. Sie werden nicht vertauscht, da 2<3 ist.<br>'+'[2, 3, 1, 4] -> [2, 1, 3, 4] Das zweite Element wird mit dem dritten verglichen. Sie werden vertauscht, da 3>1 ist.<br>'+'[2, 1, 3, 4] -> [2, 1, 3, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden nicht vertauscht, da 3<4 ist.<br>'+'Das zweitgr\xF6\xDFte Element ist an die richtige Stelle geblubbert.<br><br>'+'Dritte Bubble-Phase:<br>'+'[2, 1, 3, 4] -> [1, 2, 3, 4] Das erste Element wird mit dem zweiten verglichen. Sie werden vertauscht, da 2>1 ist.<br>'+'[1, 2, 3, 4] -> [1, 2, 3, 4] Das zweite Element wird mit dem dritten verglichen. Sie werden nicht vertauscht, da 2<3 ist.<br>'+'[1, 2, 3, 4] -> [1, 2, 3, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden vertauscht, da 3<4 ist.<br>'+'Das drittgr\xF6\xDFte Element ist an die richtige Stelle geblubbert.<br>'+'Damit ist automatisch auch das kleinste Element an der richtigen Stelle.<br>'+'Das Array ist aufsteigend sortiert.'+'</code></pre>',task:'Schreibe eine Funktion <code>sort</code>, die ein mit Zahlen gef\xFClltes Array entgegennimmt und die diese Zahlen aufsteigend sortiert als Array zur\xFCckgibt. '+'Wird ein leeres Array \xFCbergeben, so soll auch ein leeres Array zur\xFCckgegeben werden. <code>sort([4,&nbsp;2,&nbsp;3,&nbsp;1])</code> sollte <code>[1,&nbsp;2,&nbsp;3,&nbsp;4]</code> ergeben.',beforeTests:function(){if(typeof sort!=='undefined'){sort=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('sort')},function(){return jshero.testutil.assert_functionHasNumOfParameter('sort',1)},function(){return jshero.testutil.assert_functionReturns('sort([])',[])},function(){return jshero.testutil.assert_functionReturns('sort([1])',[1])},function(){return jshero.testutil.assert_functionReturns('sort([3, 1])',[1,3])},function(){return jshero.testutil.assert_functionReturns('sort([3, 1, 2])',[1,2,3])},function(){return jshero.testutil.assert_functionReturns('sort([3, 2, 1])',[1,2,3])},function(){return jshero.testutil.assert_functionReturns('sort([5, 4, 3, 2, 1])',[1,2,3,4,5])},function(){return jshero.testutil.assert_functionReturns('sort(["c", "a", "b"])',['a','b','c'])}]})})(jshero.array);
jshero.koans.add({id:'comment',title:'Kommentare',lesson:'Neben dem eigentlichen Code kann man Kommentare schreiben. Kommentare dienen dazu, Programme zu erkl\xE4ren. Sie helfen uns Menschen, Programme zu verstehen und zu verwenden. '+'Computer, die Programme ausf\xFChren, ignorieren Kommentare. In JavaScript gibt zwei M\xF6glichkeiten, Kommentare zu schreiben: '+'Zeilen-Kommentare werden mit <code>//</code> eingeleitet und gelten immer bis zum Ende der Zeile. Block-Kommentare werden mit <code>/*</code> eingeleitet und mit <code>*/</code> beendet. '+'Alles dazwischen ist Kommentar. Hier ein paar Beispiele:'+'<pre><code>'+'// Das ist ein Zeilenkommentar.<br><br>'+'// Dieser Zeilenkommentar geht<br>'+'// \xFCber 2 Zeilen.<br><br>'+'/* Das ist ein Blockkommentar. */<br><br>'+'/* Dieser Blockkommentar geht<br>'+'\xFCber mehrere Zeilen. */<br><br>'+'/**<br>'+' * Auch dies ist ein Blockkommentar.<br>'+' * Die zus\xE4tzlichen Sterne zwischen<br>'+' * dem Beginn und dem Ende des<br>'+' * Blockkommentars dienen nur zur<br>'+' * Verzierung. So sieht ein l\xE4ngerer <br>'+' * Blockkommentar \xFCbersichtlicher aus.<br>'+' */</code></pre>'+'Block-Kommentare schreibt man gerne \xFCber Funktionen, Zeilen-Kommentare in den Code-Fluss.'+'<pre><code>'+'/**<br>'+' * Pr\xFCft, ob eine String kein Zeichen<br>'+' * au\xDFer Leerzeichen enth\xE4lt.<br>'+' */<br>'+'var isEmpty = function(string) {<br>'+'  // Die Methode trim() entfernt Leerzeichen<br>'+'  // am Anfang und am Ende einer Zeichenfolge.<br>'+'  var trimmedString = string.trim();<br>'+'  return trimmedString.length === 0;<br>'+'};</code></pre>'+'Da Kommentare mit den hier verwendeten Tests nicht \xFCberpr\xFCfen werden k\xF6nnen, eine Aufgabe, bei der man vieles von dem bisher Gelernten anwenden muss.',task:'Schreibe eine Funktion <code>median</code>, die ein Array von aufsteigend sortierten Zahlen entgegennimmt und die den Median dieser Zahlen zur\xFCckgibt. '+'<code>median([1, 2, 10])</code> sollte <code>2</code> ergeben; <code>median([1, 2, 10, 100])</code> sollte <code>6</code> ergeben. '+'Der Median einer sortierten Zahlenreihe ist der Wert, der an der mittleren Stelle steht. Ist die Anzahl der Werte gerade, so ist der Median der Mittelwert '+'der beiden mittleren Zahlen.',beforeTests:function(){if(typeof median!=='undefined'){median=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('median')},function(){return jshero.testutil.assert_functionHasNumOfParameter('median',1)},function(){return jshero.testutil.assert_functionReturns('median([1])',1)},function(){return jshero.testutil.assert_functionReturns('median([1, 2])',1.5)},function(){return jshero.testutil.assert_functionReturns('median([1, 2, 10])',2)},function(){return jshero.testutil.assert_functionReturns('median([1, 1, 2, 10, 100, 101])',6)}]});
(function(dateUtil){jshero.koans.add({id:'date',title:'Datum und Uhrzeit',lesson:'Um mit Datum und Uhrzeit zu arbeiten, verwendet man <code>Date</code>-Objekte. Ein <code>Date</code>-Objekt repr\xE4sentiert '+'einen Zeitpunkt, also ein Datum zusammen mit einer Uhrzeit. Die Uhrzeit wird dabei auf die Millisekunde genau festgelegt. '+'Ein Date-Objekt erzeugt man mit <code>new Date()</code>. Es gibt 4 m\xF6gliche Aufrufe: '+'<pre><code>// aktueller Zeitpunkt<br>var d1 = new Date();</code></pre>'+'Ohne Parameter erzeugt <code>new Date()</code> ein Date-Objekt, das dem Zeitpunkt seines Aufrufs entspricht. Wird obiges Beispiel '+'am 1. Mai 2017 um 8:15 Uhr aufgerufen, so enth\xE4lt <code>d1</code> eben diesen Zeitpunkt.<br>'+'<pre><code>// Aufruf mit Jahr, Monat, Tag, Stunde,<br>// Stunde, Minute, Sekunde, Millisekunde<br>var d2 = new Date(2017, 2, 8, 16, 31, 10, 117);</code></pre>'+'M\xF6chte man ein Date-Objekt zu einem bestimmten Zeitpunkt erstellen, verwendet man am besten die zweite M\xF6glichkeit. '+'Hier \xFCbergibt man als Parameter das Jahr, den Monat, den Tag, die Stunde, die Minute, die Sekunde und die Millisekunde. '+'Das Jahr muss in voller L\xE4nge \xFCbergeben werden. <code>17</code> ergibt das Jahr 17 n. Chr. und <code>2017</code> das Jahr 2017 n. Chr. '+'Bei dem Monat muss man aufpassen. JavaScript nummeriert die Monate von 0 (Januar) bis 11 (Dezember). Alle weiteren Zahlen entsprechen der \xFCblichen '+'Bedeutung. <code>d2</code> repr\xE4sentiert also den Zeitpunkt 8.3.2017, 16:31:10 Uhr und 117 Millisekunden.<br>'+'Die Parameter Millisekunde, Sekunde, Minute, Stunde und Tag sind - in dieser Reihenfolge - optional. Man kann sie weglassen. '+'Gibt man sie nicht an, werden die Zeitangaben automatisch auf 0 gesetzt. Der Tag wird auf den Monatsersten gesetzt. '+'Das ist besonders praktisch, wenn man nur mit einem Datum arbeiten m\xF6chte. '+'Dann l\xE4\xDFt man einfach alle Zeitangaben weg. <code>new&nbsp;Date(2017, 5, 2)</code> ist der 2.6.2017, 0:00 Uhr.<br>'+'<pre><code>// Millisekunden seit dem 1.1.1970<br>var d3 = new Date(86400000);</code></pre>'+'Bei der dritten Variante \xFCbergibt man die vergangenen Millisekunden seit dem 1.1.1970, 0:00 Uhr. Der Bezugspunkt 1.1.1970 f\xFCr Datumsangaben ist seit den '+'Tagen von Unix und der Programmiersprache C in der IT \xFCblich geworden. Ein Tag hat 24 * 60 * 60 * 1000 = 86400000 Millisekunden. <code>d3</code> ist '+'also der 2.1.1970, 0:00 Uhr.<br>'+'<pre><code>// \xDCbergabe eines Datumsstrings<br>var d4 = new Date("2017-3-8T16:31:10.117");</code></pre>'+'Bei der vierten Variante wird ein Datumsstring in einem bestimmten Format, d.h. in einer bestimmten Schreibweise, \xFCbergeben. '+'<code>d4</code> entspricht ebenfalls dem Zeitpunkt 8.3.2017, 16:31:10 Uhr und 117 Millisekunden. Diese Varainte ist jedoch nicht zu empfehlen, '+'da verschiedene Browser leichte Unterschiede bei der Bestimmung des Datums aufweisen.',task:'Schreibe eine Funktion <code>nikolaus</code>, die eine Jahreangabe als Zahl entgegennimmt und  die ein Date-Objekt mit dem 6. Dezember '+'des \xFCbergebenen Jahres, 0:00 Uhr, zur\xFCckgibt. <code>nikolaus(2017)</code> sollte ein Date-Objekt mit dem Zeitpunkt 6.12.2017, 0:00 Uhr zur\xFCckgeben.',beforeTests:function(){if(typeof nikolaus!=='undefined'){nikolaus=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('nikolaus')},function(){return jshero.testutil.assert_functionHasNumOfParameter('nikolaus',1)},function(){return jshero.testutil.assert_functionReturnsType('nikolaus(2017)','Date')},function(){return jshero.testutil.assert_functionReturns('nikolaus(2017)',new Date(2017,11,6))},function(){return jshero.testutil.assert_functionReturnsType('nikolaus(1960)','Date')},function(){return jshero.testutil.assert_functionReturns('nikolaus(1960)',new Date(1960,11,6))}]})})(jshero.date);
jshero.koans.add({id:'date2',title:'Datum und Uhrzeit ausgeben',lesson:'Zur Ausgabe der Daten eines Date-Objekts gibt es sieben sogenannte Getter-Methoden:'+'<pre><code>'+'var startFastnacht = new Date(2017, 10, 11, 11, 11);<br>'+'var jahr = startFastnacht.getFullYear();<br>'+'var monat = startFastnacht.getMonth();<br>'+'var tag = startFastnacht.getDate();<br>'+'var stunde = startFastnacht.getHours();<br>'+'var minute = startFastnacht.getMinutes();<br>'+'var sekunde = startFastnacht.getSeconds();<br>'+'var millisekunde = startFastnacht.getMilliseconds();<br>'+'</code></pre>'+'Man erh\xE4lt die erwarteten Werte: <code>2017</code> f\xFCr das Jahr, <code>10</code> f\xFCr den Monat, <code>11</code> f\xFCr den Tag, die Stunde und die Minute, '+'sowie <code>0</code> f\xFCr die Sekunde und die Millisekunde. '+'Die Monatsz\xE4hlung beginnt wie beim Erzeugen eines Date-Objektes mit <code>0</code>. <code>10</code> steht f\xFCr den November.',task:'Schreibe eine Funktion <code>toGerman</code>, die ein Date-Objekt entgegennimmt und dessen Datum im Format "d.M.YYYY" zur\xFCckgibt. '+'Mit <code>date = new Date(2017, 2, 8)</code> sollte <code>toGerman(date)</code> den String <code>"8.3.2017"</code> zur\xFCckgeben.',beforeTests:function(){if(typeof toGerman!=='undefined'){toGerman=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('toGerman')},function(){return jshero.testutil.assert_functionHasNumOfParameter('toGerman',1)},function(){return jshero.testutil.assert_functionReturns('toGerman(new Date(2017, 2, 8))','8.3.2017')},function(){return jshero.testutil.assert_functionReturns('toGerman(new Date(1724, 3, 22))','22.4.1724')}]});
(function(dateUtil){jshero.koans.add({id:'date3',title:'Datum und Uhrzeit \xE4ndern',lesson:'Passend zu den sieben Getter-Methoden besitzt das Date-Objekt sieben Setter-Methoden: '+'<code>setFullYear</code>, <code>setMounth</code>, <code>setDate</code>, <code>setHours</code>, <code>setMinutes</code>, <code>setSeconds</code> und <code>setMilliseconds</code>. '+'Mit diesen 7 Methoden kann man den entsprechenden Date-Eintrag setzen:'+'<pre><code>'+'var today = new Date();<br>'+'today.setHours(0);<br>'+'today.setMinutes(0);<br>'+'today.setSeconds(0);<br>'+'today.setMilliseconds(0);<br>'+'</code></pre>'+'<code>today</code> enth\xE4lt zun\xE4chst den Zeitpunkt seiner Erstellung. Anschlie\xDFend wird mit den vier Setter-Aufrufen die Zeit auf 0:00:00.000 Uhr gesetzt. '+'So enth\xE4lt <code>today</code> das aktuelle Tagesdatum mit zur\xFCckgesetzter Uhrzeit.<br><br>'+'\xDCberschreitet oder unterschreitet man bei einer dieser Methoden den zul\xE4ssigen Wertebereich, dann rechnen diese Methoden den \xDCber- oder Untertrag automatisch um:<br>'+'<pre><code>'+'var someDay = new Date(2020, 3, 1);<br>'+'someDay.setDate(32);<br>'+'someDay.setDate(0);<br>'+'</code></pre>'+'Zun\xE4chst repr\xE4sentiert <code>someDay</code> den 1.4.2020. Nun wird der Tag auf den 32. gesetzt. Da der April 30 Tage hat, entspricht das dem 2.5.2020. Wird nun der Tag '+'auf 0 gesetzt, erh\xE4lt man den 30.4.2020.',task:'Schreibe eine Funktion <code>yesterday</code>, die ein Date-Objekt entgegennimmt, dessen Datum um einen Tag zur\xFCcksetzt und dann dieses Date-Objekt zur\xFCckgibt. '+'Die Uhrzeit soll dabei nicht ver\xE4ndert werden. Mit <code>date = new Date(1965, 8, 14)</code> sollte <code>yesterday(date)</code> ein Date-Objekt zur\xFCckgeben, das den 13.9.1965 repr\xE4sentiert.',beforeTests:function(){if(typeof yesterday!=='undefined'){yesterday=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('yesterday')},function(){return jshero.testutil.assert_functionHasNumOfParameter('yesterday',1)},function(){return jshero.testutil.assert_functionReturnsType('yesterday(new Date(1965, 8, 14))','Date')},function(){return jshero.testutil.assert_functionReturns('yesterday(new Date(1965, 8, 14))',new Date(1965,8,13))},function(){return jshero.testutil.assert_functionReturnsType('yesterday(new Date(2000, 0, 1, 12))','Date')},function(){return jshero.testutil.assert_functionReturns('yesterday(new Date(2000, 0, 1, 12))',new Date(1999,11,31,12))}]})})(jshero.date);
(function(){jshero.koans.add({id:'dowhile',title:'do...while-Schleife',lesson:'Die <code>do...while</code>-Schleife funktioniert \xE4hnlich wie die <code>while</code>-Schleife. '+'Der Schleifen-Code wird ausgef\xFChrt, solange die Schleifenbedingung <code>true</code> ergibt. '+'Einziger Unterschied ist, dass die Schleifenbedingung nach dem Schleifen-Code \xFCberpr\xFCft wird. '+'Dadurch ist sichergestellt, dass der Schleifen-Code mindestens einmal durchlaufen wird.'+'<pre><code>var restDurch6;<br>'+'var restDurch8;<br>'+'var kgV = 0;<br>'+'do {<br>'+'  kgV++;<br>'+'  restDurch6 = kgV % 6;<br>'+'  restDurch8 = kgV % 8;<br>'+'} while (restDurch6 !== 0 || restDurch8 !== 0)</code></pre>'+'Dieser Codeabschnitt berechnet das kleinste gemeinsame Vielfache (kgV) von 6 und 8. '+'Das kgV ist die kleinste Zahl, die sowohl ein Vielfaches von 6 als auch ein Vielfaches von 8 ist. '+'Die Vielfachen von 6 sind 6, 12, 18, 24, 30, ... und die Vielfachen von 8 sind 8, 16, 24, 32, ... . '+'Damit ist das kgV von 6 und 8 die Zahl 24.<br>'+'Unser Codebeispiel pr\xFCft beginnend mit <code>1</code>, ob <code>kgV</code> sowohl durch <code>6</code> als auch durch <code>8</code> teilbar ist. '+'Die Teilbarkeit wird mithilfe des Modulo-Operators \xFCberpr\xFCft. Eine Zahl ist durch 6 bzw. 8 teilbar, '+'wenn sie Modulo 6 bzw. Modulo 8 den Wert 0 liefert. Die Modulo-Berechnung findet im Schleifen-Code statt. '+'In der Schleifenbedingung wird dann \xFCberpr\xFCft, ob beide Modulo-Berechnungen <code>0</code> ergeben. Ist eine von beiden '+'Modulo-Berechnungen nicht <code>0</code>, ist die Schleifenbedingung <code>true</code> und der Schleifen-Code wird mit einem um 1 erh\xF6hten <code>kgV</code> '+'erneut durchlaufen. Ergeben beide Modulo-Berechnungen <code>0</code>, ist die Schleifenbedingung <code>false</code> und die Schleife wird beendet. '+'<code>kgV</code> hat dann den gew\xFCnschten Wert (n\xE4mlich 24), da es die erste Zahl ist, die sowohl durch 6 als auch durch 8 teilbar ist.',task:'Schreibe eine Funktion <code>kgV</code>, die zwei nat\xFCrliche Zahlen als Parameter entgegennimmt und deren kgV berechnet. '+'<code>kgV(6, 8)</code> sollte <code>24</code> zur\xFCckgeben.',beforeTests:function(){if(typeof kgV!=='undefined'){kgV=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('kgV')},function(){return jshero.testutil.assert_functionHasNumOfParameter('kgV',2)},function(){return jshero.testutil.assert_functionReturns('kgV(6, 8)',24)},function(){return jshero.testutil.assert_functionReturns('kgV(5, 7)',35)},function(){return jshero.testutil.assert_functionReturns('kgV(7, 5)',35)},function(){return jshero.testutil.assert_functionReturns('kgV(15, 45)',45)}]})})();
jshero.koans.add({id:'else',title:'if ... else',lesson:'M\xF6chte man, dass ein Codeblock nur dann ausgef\xFChrt wird, wenn eine <code>if</code>-Bedingung nicht erf\xFCllt ist, verwendet man '+'zus\xE4tzlich zum <code>if</code> ein <code>else</code> (engl.: sonst).'+'<pre><code>var mitteilung;<br>if (betrag > 1000) {<br>  mitteilung = "Keine Auszahlung m\xF6glich!";<br>} else {<br>'+'  mitteilung = "Der Betrag wird ausgezahlt!";<br>}</code></pre>'+'Je nachdem, ob <code>betrag</code> gr\xF6\xDFer oder kleiner <code>1000</code> ist, wird entweder der <code>if</code>-Zweig oder '+'der <code>else</code>-Zweig ausgef\xFChrt.',task:'Schreibe eine Funktion <code>addiereMitZuschlag</code>, die zwei Betr\xE4ge mit Zuschlag addiert. F\xFCr jeden Betrag, der kleiner gleich <code>10</code> '+'ist, betr\xE4gt der Zuschlag <code>1</code>. F\xFCr jeden Betrag, der gr\xF6\xDFer <code>10</code> ist, betr\xE4gt der Zuschlag <code>2</code>. '+'<code>addiereMitZuschlag(10, 20)</code> sollte <code>33</code> ergeben.',beforeTests:function(){if(typeof addiereMitZuschlag!=='undefined'){addiereMitZuschlag=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('addiereMitZuschlag')},function(){return jshero.testutil.assert_functionHasNumOfParameter('addiereMitZuschlag',2)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(1, 1)',4)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(10, 9)',21)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(11, 10)',24)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(10, 11)',24)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(13, 20)',37)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(15, 27)',46)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(5, 25)',33)}]});
jshero.koans.add({id:'elseif',title:'else if',lesson:'M\xF6chte man mehrere F\xE4lle unterscheiden, kann man ein <code>if</code> mit beliebig vielen <code>else if</code> '+'erg\xE4nzen. Zum Schluss kann bei Bedarf noch ein einzelnes <code>else</code> stehen.'+'<pre><code>var mitteilung;<br>if (betrag > 1000) {<br>  mitteilung = "Zu gro\xDF. Keine Auszahlung m\xF6glich!";<br>'+'} else if (betrag < 10) {<br>  mitteilung = "Zu klein. Keine Auszahlung m\xF6glich!";<br>} else {<br>'+'  mitteilung = "Der Betrag wird ausgezahlt!";<br>}</code></pre>'+'Zuerst wird gepr\xFCft, ob <code>betrag</code> gr\xF6\xDFer <code>1000</code> ist. Ist das der Fall, wird die "Zu gro\xDF..."-Mitteilung '+'gesetzt und der Code am Ende des gesamten Blocks fortgesetzt. Ist das nicht der Fall, wird die <code>else if</code>-Bedingung '+'gepr\xFCft. Ist diese erf\xFCllt, wird die "Zu klein..."-Mitteilung gesetzt und der Code am Ende des gesamten Blocks fortgesetzt. '+'Erst wenn keine Bedingung erf\xFCllt ist, wird der abschlie\xDFenden <code>else</code>-Block ausgef\xFChrt.',task:'Schreibe eine Funktion <code>addiereMitZuschlag</code>, die zwei Betr\xE4ge mit Zuschlag addiert. F\xFCr jeden Betrag, der kleiner gleich <code>10</code> '+'ist, betr\xE4gt der Zuschlag <code>1</code>. F\xFCr jeden Betrag, der gr\xF6\xDFer <code>10</code> und kleiner gleich <code>20</code> ist, betr\xE4gt der Zuschlag <code>2</code>. '+'F\xFCr jeden Betrag, der gr\xF6\xDFer <code>20</code> ist, betr\xE4gt der Zuschlag 3. <code>addiereMitZuschlag(10, 30)</code> sollte <code>44</code> ergeben.',beforeTests:function(){if(typeof addiereMitZuschlag!=='undefined'){addiereMitZuschlag=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('addiereMitZuschlag')},function(){return jshero.testutil.assert_functionHasNumOfParameter('addiereMitZuschlag',2)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(1, 1)',4)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(10, 9)',21)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(11, 10)',24)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(10, 11)',24)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(13, 20)',37)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(20, 13)',37)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(15, 27)',47)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(27, 15)',47)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(25, 5)',34)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(5, 25)',34)}]});
jshero.koans.add({id:'equals',title:'Strikte Gleichheit',lesson:'Zwei Werte kann man auf strikte Gleichheit \xFCberpr\xFCfen. Das Ergebnis eines solchen Vergleichs ist entweder <code>true</code>, '+'die beiden Werte sind gleich, oder <code>false</code>, die beiden Werte sind ungleich. Der Operator f\xFCr strikte Gleichheit ist '+'<code>===</code>.'+'<pre><code>var sprache = "JavaScript";<br>var x = 10;<br>var v1 = sprache === "Java";<br>var v2 = x === 10;<br>'+'var v3 = x === "10";</code></pre><code>v1</code> bekommt das Ergebnis des Vergleichs der Variablen <code>sprache</code> '+'mit dem Wert <code>"Java"</code> zugewiesen. Da <code>sprache</code> zuvor den Wert <code>JavaScript</code> erhalten hat und '+'diese beiden Werte verschieden sind, hat <code>v1</code> den Wert <code>false</code>. <code>v2</code> ist <code>true</code>, '+'da der Wert von <code>x</code> gleich <code>10</code> ist. Bei der strikten Gleichheit kommt es auch darauf an, dass die '+'Datentypen der beiden verglichenen Werte gleich sind. <code>v3</code> ist <code>false</code>, da hier unterschiedliche Typen '+'verglichen werden. Auf der linken Seite des Vergleichs steht eine Zahl, auf der rechten Seite ein String.',task:'Schreibe eine Funktion <code>gleich</code>, die zwei Werte auf strikte Gleichheit \xFCberpr\xFCft. <code>gleich(1, 1)</code> soll '+'<code>true</code> zur\xFCckgeben, <code>gleich(1, 2)</code> soll <code>false</code> ergeben.',beforeTests:function(){if(typeof gleich!=='undefined'){gleich=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('gleich')},function(){return jshero.testutil.assert_functionHasNumOfParameter('gleich',2)},function(){return jshero.testutil.assert_functionReturns('gleich(1, 1)',true)},function(){return jshero.testutil.assert_functionReturns('gleich(1, "1")',false)},function(){return jshero.testutil.assert_functionReturns('gleich(1, 2)',false)},function(){return jshero.testutil.assert_functionReturns('gleich("klein", "klein")',true)},function(){return jshero.testutil.assert_functionReturns('gleich("Links", "Rechts")',false)}]});
jshero.koans.add({id:'equals2',title:'Drei gleiche Werte',lesson:'Die folgende Aufgabe soll das Zusammenspiel von strikter Gleichheit und booleschen Operatoren vertiefen.',task:'Schreibe eine Funktion <code>gleich</code>, die 3 Werte auf strikte Gleichheit \xFCberpr\xFCft. Die Funktion soll nur '+'dann <code>true</code> ergeben, wenn alle 3 Werte strikt gleich sind. <code>gleich(1, 1, 1)</code> soll '+'<code>true</code> zur\xFCckgeben, <code>gleich(1, 1, 2)</code> soll <code>false</code> ergeben.',beforeTests:function(){if(typeof gleich!=='undefined'){gleich=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('gleich')},function(){return jshero.testutil.assert_functionHasNumOfParameter('gleich',3)},function(){return jshero.testutil.assert_functionReturns('gleich(1, 1, 1)',true)},function(){return jshero.testutil.assert_functionReturns('gleich(1, 1, 2)',false)},function(){return jshero.testutil.assert_functionReturns('gleich("1", 1, 1)',false)},function(){return jshero.testutil.assert_functionReturns('gleich(1, "1", 1)',false)},function(){return jshero.testutil.assert_functionReturns('gleich(1, 1, "1")',false)},function(){return jshero.testutil.assert_functionReturns('gleich("klein", "klein", "klein")',true)},function(){return jshero.testutil.assert_functionReturns('gleich("klein", "klein", "gro\xDF")',false)}]});
jshero.koans.add({id:'even',title:'Gerade Zahlen',lesson:'Diese Aufgabe soll das Zusammenspiel von strikter Gleichheit und dem Modulo-Operator vertiefen.',task:'Schreibe eine Funktion <code>istGerade</code>, die angibt, ob eine \xFCbergebene Zahl gerade oder ungerade ist.\nIst die \xFCbergebene Zahl gerade, so soll die Funktion <code>true</code> zur\xFCckgeben, andernfalls <code>false</code>.\n<code>istGerade(6)</code> soll <code>true</code> ergeben und <code>istGerade(7)</code> soll <code>false</code> zur\xFCckgeben.',beforeTests:function(){if(typeof istGerade!=='undefined'){istGerade=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('istGerade')},function(){return jshero.testutil.assert_functionHasNumOfParameter('istGerade',1)},function(){return jshero.testutil.assert_functionReturns('istGerade(0)',true)},function(){return jshero.testutil.assert_functionReturns('istGerade(1)',false)},function(){return jshero.testutil.assert_functionReturns('istGerade(2)',true)},function(){return jshero.testutil.assert_functionReturns('istGerade(37)',false)},function(){return jshero.testutil.assert_functionReturns('istGerade(208)',true)}]});
jshero.koans.add({id:'for',title:'for-Schleife',lesson:'Mit Schleifen k\xF6nnen Code-Abschnitte mehrmals durchlaufen werden. JavaScript kennt mehrere Schleifenarten. Die einfachste ist die <code>for</code>-Schleife.'+'<pre><code>var summe = 0;<br>'+'for (var i = 1; i < 3; i++) {<br>'+'  summe = summe + i;<br>'+'}</code></pre>'+'Die <code>for</code>-Schleife besteht aus drei Steuer-Anweisungen und dem Schleifen-Code. Die drei Anweisungen folgen dem <code>for</code> in runden Klammern. '+'Sie werden durch Semikolons voneinander getrennt. Die erste Anweisung ist die Start-Anweisung. Sie wird einmal zu Beginn der Schleife ausgef\xFChrt. '+'Hier wird normalerweise eine Variable, die sogenannte Schleifenvariable, initialisiert. Die zweite Anweisung ist die Schleifen-Bedingung. '+'Sie wird vor jedem Schleifendurchlauf zu <code>true</code> oder <code>false</code> ausgewertet. Ist der Ausdruck <code>true</code>, wird der Schleifen-Code ausgef\xFChrt. '+'Ist er <code>false</code>, wird die Schleife beendet und die Programmausf\xFChrung wird nach der Schleife fortgesetzt. '+'Nach jedem Schleifen-Durchlauf wird die dritte Anweisung, die sogenannten End-Anweisung, ausgef\xFChrt. Hier wird normalerweise die Schleifenvariable erh\xF6ht. '+'Anschlie\xDFend beginnt ein neuer Schleifendurchlauf mit erneuter Auswertung der Schleifen-Bedingung. '+'Der Schleifen-Code folgt in Mengenklammern den drei Steueranweisungen.<br>'+'In unserem Beispiel hat <code>summe</code> zun\xE4chst den Wert <code>0</code>. In der Start-Anweisung wird <code>i</code> mit <code>1</code> initialisiert. '+'Die Schleifenbedingung <code>1 < 3</code> ist erf\xFCllt, also wird der Schleifen-Code ausgef\xFChrt. <code>summe</code> erh\xE4lt den Wert <code>0 + 1</code>, also <code>1</code>. '+'Nun wird in der End-Anweisung <code>i</code> um <code>1</code> erh\xF6ht (<code>i++</code> ist identisch mit <code>i = i + 1</code>). '+'Es erh\xE4llt also den Wert <code>2</code>. Der zweite Schleifendurchlauf startet mit Auswertung der Schleifenbedingung. Diese Bedingung (<code>2 < 3</code>) ist immer noch erf\xFCllt. '+'Der Schleifen-Code wird erneut ausgef\xFChrt und <code>summe</code> erh\xE4lt jetzt den Wert <code>1 + 2</code>, also <code>3</code>. '+'<code>i</code> wird abermals erh\xF6ht und hat nun den Wert <code>3</code>. '+'Die Schleifenbedingung <code>3 < 3</code> ist jetzt nicht mehr erf\xFCllt. Die Schleife wird beendet und die Programmausf\xFChrung wird nach der Schleife fortgesetzt. '+'Unser Codebeispiel hat also alle nat\xFCrlichen Zahlen echt kleiner 3 addiert.',task:'Schreibe eine Funktion <code>addiereBis</code>, die eine Zahl als Parameter entgegennimmt und die '+'alle nat\xFCrlichen Zahlen echt kleiner dem Paramter aufaddiert. Das Ergebnis der Addition soll zur\xFCckgegeben werden. '+'<code>addiereBis(4)</code> sollte <code>6</code> ergeben.',beforeTests:function(){if(typeof addiereBis!=='undefined'){addiereBis=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('addiereBis')},function(){return jshero.testutil.assert_functionHasNumOfParameter('addiereBis',1)},function(){return jshero.testutil.assert_functionReturns('addiereBis(2)',1)},function(){return jshero.testutil.assert_functionReturns('addiereBis(4)',6)},function(){return jshero.testutil.assert_functionReturns('addiereBis(15)',105)}]});
jshero.koans.add({id:'for2',title:'Schleifen und Arrays',lesson:'<code>for</code>-Schleifen eignen sich besonders gut zum Durchlaufen von Arrays.\nIm folgenden Beispiel werden die Elemente eines Arrays aufaddiert:\n\n<pre><code>var sum = 0;\nfor (var i = 1; i < myArray.length; i++) {\n  sum = sum + myArray[i];\n}</code></pre>',task:'Schreibe eine Funktion <code>mean</code>, die ein Array gef\xFCllt mit Zahlen entgegennimmt und den\nDurchschnitt dieser Zahlen zur\xFCckgibt. Tipp: Um den Durchschnitt von n Zahlen zu berechnen,\nmu\xDFt du die Zahlen aufaddieren und die erhaltene Summe durch n teilen.\n<code>mean([1, 2, 3])</code> sollte <code>(1+2+3)/3</code> = <code>2</code> ergeben.',beforeTests:function(){if(typeof mean!=='undefined'){mean=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('mean')},function(){return jshero.testutil.assert_functionHasNumOfParameter('mean',1)},function(){return jshero.testutil.assert_functionReturns('mean([0])',0)},function(){return jshero.testutil.assert_functionReturns('mean([1, 2])',1.5)},function(){return jshero.testutil.assert_functionReturns('mean([1, 2, 3])',2)},function(){return jshero.testutil.assert_functionReturns('mean([-2, -4, 17, 34])',11.25)}]});
jshero.koans.add({id:"function",title:"Funktionen",lesson:"Eine Funktion ist ein Block von Anweisungen, der beliebig oft ausgef\xFChrt werden kann. "+"Eine Funktion kann Parameter entgegennehmen und eine Funktion kann einen Wert zur\xFCckgeben. "+"Funktionen werden mit dem Schl\xFCsselwort <code>function</code> definiert. Darauf folgen in runden Klammern eingeschlossen die Parameter und "+"anschlie\xDFend, eingeschlossen in geschweiften Klammern, die Anweisungen. Mit dem Schl\xFCsselwort <code>return</code> "+"kann ein Wert zur\xFCckgegeben werden. Gleichzeitig beendet <code>return</code> die Funktion. Anweisungen nach einem <code>return</code> "+"werden nicht mehr ausgef\xFChrt. Funktionen kann man Variablen zuordnen. Mit "+"<pre><code>var farbe = function() {<br>  return \"gr\xFCn\";<br>};</code></pre> definieren wir eine Funktion, "+"die <code>\"gr\xFCn\"</code> zur\xFCckgibt. Die Funktion nimmt keine Paramter entgegen (die runde Klammer ist leer) und sie enth\xE4lt genau "+"eine Anweisung, die R\xFCckgabe. Die Funktion wird der Variablen <code>farbe</code> zugeordnet. \xDCber diese Variable wird die Funktion aufgerufen: <pre><code>var ergebnis = farbe();</code></pre>"+"Jetzt wird die Funktion ausgef\xFChrt. Ihre R\xFCckgabe wird der Variablen <code>ergebnis</code> zugewiesen. <code>ergebnis</code> hat "+"dann den Wert <code>\"gr\xFCn\"</code>.",task:"Deklariere eine Variable <code>hallo</code> und weise ihr eine Funktion zu, die <code>\"Hallo Welt!\"</code> zur\xFCckgibt.",beforeTests:function(){if(typeof hallo!=="undefined"){hallo=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("hallo")},function(){return jshero.testutil.assert_functionReturns("hallo()","Hallo Welt!")}]});
jshero.koans.add({id:"function2",title:"Mehrere Funktionen",lesson:"Wir definieren nun mehr als eine Funktion.\n\n  Wiederholung: So wird eine Funktion mit Namen <code>farbe</code> definiert, die den Wert <code>\"rot\"</code>\n  zur\xFCckgibt:\n\n<pre><code>var farbe = function() {\n  return \"rot\";\n};</code></pre>\n\n  ",task:"Definiere zwei Funktionen. Die erste Funktion <code>a</code> soll <code>\"Hallo a!\"</code>\n  zur\xFCckgeben. Die zweite Funktion <code>b</code> soll <code>\"Hallo b!\"</code> zur\xFCckgeben.\n  ",beforeTests:function(){a=undefined;b=undefined},tests:[function(){return jshero.testutil.assert_isFunction("a")},function(){return jshero.testutil.assert_isFunction("b")},function(){return jshero.testutil.assert_functionReturns("a()","Hallo a!")},function(){return jshero.testutil.assert_functionReturns("b()","Hallo b!")}]});
jshero.koans.add({id:"functioncall",title:"Funktionsaufrufe",lesson:"Wichtig ist der Unterschied zwischen der Definition und dem Aufruf einer Funktion.\n    Mit der Definition, z. B.\n\n<pre><code>var f = function() {\n  return \"hallo\";\n};</code></pre>\n\n    wird festgelegt, was die Funktion machen soll. Sie wird dabei nicht ausgef\xFChrt. Sie wird lediglich zur Ausf\xFChrung bereitgestellt.\n    Erst mit ihrem Aufruf\n\n<pre><code>var x = f();</code></pre>\n\n    wird die Funktion ausgef\xFChrt. Dann werden die Anweisungen im Funktionsblock der Reihe nach abgearbeitet.\n    Die R\xFCckgabe der Funktion wird in diesem Beispiel der Variablen <code>x</code> zugewiesen.\n    Definiert werden Funktionen mit dem Schl\xFCsselwort <code>function</code>.\n    Ist die Funktion einer Variablen zugewiesen, geschieht der Aufruf der Funktion \xFCber diese Variable.\n    Funktionen werden einmal definiert, um sie dann an verschiedenen Programmstellen durch ihren Aufruf mehrfach zu benutzen.",task:"1. Definiere eine Funktion <code>begruesse</code>, die den Wert <code>\"Moin!\"</code> zur\xFCckgibt.\n  <br/>\n    2. Deklariere eine Variable <code>begruessung</code>. Rufe die Funktion <code>begruesse</code> auf und weise der Variablen\n    <code>begruessung</code> die R\xFCckgabe dieses Aufrufs zu.",beforeTests:function(){begruesse=undefined;begruessung=undefined},tests:[function(){return jshero.testutil.assert_isFunction("begruesse")},function(){return jshero.testutil.assert_functionReturns("begruesse()","Moin!")},function(){return jshero.testutil.assert_variableDefined(begruessung,"begruessung")},function(){return jshero.testutil.assert_variableHasValue(begruessung,"begruessung","Moin!")}]});
jshero.koans.add({id:"further",title:"Fortsetzung folgt ...",lesson:"JS Hero wird fortgesetzt. Weitere \xDCbungen folgen. Zum Abschluss noch eine Aufgabe aus dem Gebiet der Mathematik.",task:"Schreibe eine Funktion <code>quersumme</code>, die die Quersumme einer nat\xFCrlichen Zahl berechnet. "+"Die Quersumme einer Zahl ist dabei die Summe ihrer Ziffern. <code>quersumme(198)</code> sollte <code>18</code> ergeben.",beforeTests:function(){if(typeof quersumme!=="undefined"){quersumme=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("quersumme")},function(){return jshero.testutil.assert_functionHasNumOfParameter("quersumme",1)},function(){return jshero.testutil.assert_functionReturns("quersumme(1)",1)},function(){return jshero.testutil.assert_functionReturns("quersumme(198)",18)},function(){return jshero.testutil.assert_functionReturns("quersumme(123456789)",45)}],sampleSolution:"<code>\n  var quersumme = function( zahl ) {\n     var sum = 0;\n     var rest = zahl;\n     while (rest > 0) {\n         var einer = rest % 10;\n         sum += einer;\n         rest = (rest - einer)/10;\n     }\n     return sum;\n  };\n  </code>\n  "});
(function(){jshero.koans.add({id:'ggt',title:'ggT',lesson:'Das Gegenst\xFCck zum kleinsten gemeinsamen Vielfachen ist der gr\xF6\xDFte gemeinsamer Teiler (ggT). '+'Der gr\xF6\xDFte gemeinsame Teiler zweier Zahlen a und b ist die gr\xF6\xDFte Zahl, durch die sich sowohl a als auch b teilen l\xE4\xDFt.',task:'Schreibe eine Funktion <code>ggT</code>, die zwei nat\xFCrliche Zahlen als Parameter entgegennimmt und deren ggT berechnet. '+'<code>ggT(6, 15)</code> sollte <code>3</code> zur\xFCckgeben.',beforeTests:function(){if(typeof ggT!=='undefined'){ggT=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('ggT')},function(){return jshero.testutil.assert_functionHasNumOfParameter('ggT',2)},function(){return jshero.testutil.assert_functionReturns('ggT(6, 15)',3)},function(){return jshero.testutil.assert_functionReturns('ggT(2, 4)',2)},function(){return jshero.testutil.assert_functionReturns('ggT(9, 3)',3)},function(){return jshero.testutil.assert_functionReturns('ggT(5, 7)',1)},function(){return jshero.testutil.assert_functionReturns('ggT(7, 5)',1)},function(){return jshero.testutil.assert_functionReturns('ggT(15, 45)',15)},function(){return jshero.testutil.assert_functionReturns('ggT(15, 45)',15)}]})})();
jshero.koans.add({id:'greaterthan',title:'Zahlen vergleichen',lesson:'Zahlen kann man mit den aus der Mathematik bekannten Zeichen\n<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code> und <code>&gt;=</code>\nauf gr\xF6\xDFer, gr\xF6\xDFer gleich, kleiner und kleiner gleich vergleichen.\nIm folgenden Beispiel liefern alle Ausdr\xFCcke den Wert <code>true</code>:\n<pre><code>var v1 = 5 > 4;\nvar v2 = 5 >= 5;\nvar v3 = 5 < 6;\nvar v4 = 5 <= 5;</code></pre>',task:'Schreibe eine Funktion <code>istDreistellig</code>, die pr\xFCft, ob eine Zahl gr\xF6\xDFer gleich 100 und kleiner 1000 ist.\n<code>istDreistellig(500)</code> sollte <code>true</code> zur\xFCckgeben, <code>istDreistellig(50)</code> sollte <code>false</code> ergeben.',beforeTests:function(){istDreistellig=undefined},tests:[function(){return jshero.testutil.assert_isFunction('istDreistellig')},function(){return jshero.testutil.assert_functionHasNumOfParameter('istDreistellig',1)},function(){return jshero.testutil.assert_functionReturns('istDreistellig(100)',true)},function(){return jshero.testutil.assert_functionReturns('istDreistellig(999)',true)},function(){return jshero.testutil.assert_functionReturns('istDreistellig(99)',false)},function(){return jshero.testutil.assert_functionReturns('istDreistellig(1000)',false)}]});
jshero.koans.add({id:'if',title:'if',lesson:'H\xE4ufig soll Code nur dann ausgef\xFChrt werden, wenn eine bestimmte Bedingung erf\xFCllt ist. '+'Dazu verwendet man die <code>if</code>-Anweisung.'+'<pre><code>var gewinn = 0;<br>if (wuerfelzahl === 6) {<br>  gewinn = 100;<br>}</code></pre>'+'Diese Anweisung besteht aus dem Schl\xFCsselwort <code>if</code> (engl: wenn) gefolgt von runden Klammern. In den runden Klammern steht ein '+'Ausdruck - die Bedingung -, der zu <code>true</code> oder <code>false</code> ausgewertet wird. Ergibt die Bedingung <code>true</code>, '+'werden alle Anweisungen in dem durch die geschweiften Klammern begrenzten Block ausgef\xFChrt. Ergibt die Bedingung <code>false</code>, '+'wird der durch die geschweiften Klammern begrenzte Block \xFCbersprungen. '+'Hat in unserem Beispiel die Variable <code>wuerfelzahl</code> den Wert <code>6</code>, so wird <code>gewinn</code> auf '+'<code>100</code> gesetzt. Hat <code>wuerfelzahl</code> nicht den Wert <code>6</code>, bleibt <code>gewinn</code> bei <code>0</code>.',task:'Schreibe eine Funktion <code>gleich</code>, die 2 Werte auf strikte Gleichheit \xFCberpr\xFCft. Sind die beiden Werte gleich, so soll '+'der String <code>"GLEICH"</code> zur\xFCckgegeben werden. Sind sie ungleich, so soll man <code>"UNGLEICH"</code> erhalten.',beforeTests:function(){if(typeof gleich!=='undefined'){gleich=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('gleich')},function(){return jshero.testutil.assert_functionHasNumOfParameter('gleich',2)},function(){return jshero.testutil.assert_functionReturns('gleich(1, 1)','GLEICH')},function(){return jshero.testutil.assert_functionReturns('gleich(1, "1")','UNGLEICH')},function(){return jshero.testutil.assert_functionReturns('gleich(1, 2)','UNGLEICH')},function(){return jshero.testutil.assert_functionReturns('gleich("klein", "klein")','GLEICH')},function(){return jshero.testutil.assert_functionReturns('gleich("Links", "Rechts")','UNGLEICH')}]});
jshero.koans.add({id:"log",title:"Loggen",lesson:"Wenn man Programme schreibt, laufen die Dinge manchmal nicht so wie man will. Es kommt einfach nicht das "+"gew\xFCnschte Ergebnis heraus und man wei\xDF nicht warum. Eine M\xF6glichkeit hier weiter "+"zu kommen ist das Loggen. Man l\xE4\xDFt sich den Wert von Variablen w\xE4hrend der Programmausf\xFChrung ausgeben. In JavaScript macht man "+"das mit der Funktion <code>console.log</code>."+"<pre><code>"+"var mitteilung = \"Hallo\";<br>"+"console.log(mitteilung);<br>"+"mitteilung = mitteilung + \" Franz!\";<br>"+"console.log(mitteilung);<br>"+"</code></pre>"+"Wir geben den Wert von <code>mitteilung</code> zweimal mit <code>console.log</code> aus. Beim ersten Log wird der initiale Werte von "+"<code>mitteilung</code> ausgegeben. Beim zweiten Log sehen wir, welchen Wert <code>mitteilung</code> nach der \xC4nderung hat. "+"So k\xF6nnen wir feststellen, welchen Wert Variablen an bestimmen Stellen des Programmsablaufs besitzen und wie sich dieser Wert im Ablauf \xE4ndert. "+"In unserem Beispiel erhalten wir nacheinander die Ausgaben <code>\"Hallo\"</code> und <code>\"Hallo Franz!\"</code>.<br><br>"+"Wo man das Log zu sehen bekommt, h\xE4ngt von der JavaScript-Umgebung ab. Node.js wird in einer klassischen Konsole gestartet. Dort wird auch das Log ausgegeben. "+"In Browsern sieht man die Log-Ausgabe im normalen Betrieb nicht. Doch jeder Browser besitzt sogenannte Entwickler-Werkzeuge. Das sind m\xE4chtige Tools zur Unterst\xFCtzung "+"von Webentwicklern. Eines dieser Tools ist die Konsole. Dort wird das Log ausgegeben. Wie man die Entwickler-Werkzeuge \xF6ffnet h\xE4ngt vom jeweiligen Browser ab. "+"Bei vielen Desktop-Browsern (z.B. Firefox) wird sie mit der Taste F12 ge\xF6ffnet. Die Konsole kannst du dann als Reiter ausw\xE4hlen. "+"Benutzt du JavaScript Hero im Browser auf einem PC oder Laptop, dann kannst du das sofort ausprobieren. \xD6ffne die Entwickler-Konsole (im Firefox mit F12), schreibe unten in das L\xF6sungsfeld "+"<code>console.log(\"Hallo Konsole!\")</code> und f\xFChre die Tests aus. In der Entwickler-Konsole erscheint \"Hallo Konsole!\".<br><br>"+"Da es sinnvoll ist, das Log direkt in der Testausgabe zu sehen, besitzt JavaScript Hero eine eigene Log-Funktion: <code>jshero.log</code>. "+"Diese Funktion loggt so wie oben <code>console.log</code>. Die Ausgabe wird allerdings nicht in die Entwickler-Konsole, sondern in die Testausgabe geschrieben. "+"So sieht man genau, was bei welchem Testaufruf geloggt wird. <code>jshero.log</code> kannst du in jeder Lektion verwenden! Der Vollst\xE4ndigkeit halber seien zwei Unterschiede zwischen dem "+"Loggen mit <code>console.log</code> und <code>jshero.log</code> genannt: (i)&nbsp;<code>console.log</code> kann mehrere Paramter gleichzeitig loggen "+"und es loggt Objekte (diese werden wir sp\xE4ter kennen lernen) in ihrer Objekt-Notation. (ii)&nbsp;<code>jshero.log</code> loggt nicht beim Einlesen deines L\xF6sungs-Codes. "+"Es ist nur beim Aufruf deiner L\xF6sungsfunktion aktiv. Dadurch werden Log-Aufrufe au\xDFerhalb deiner L\xF6sungsfunktion mit <code>jshero.log</code> nicht geloggt, w\xE4hrend sie "+"mit <code>console.log</code> geloggt werden.",task:"Schreibe eine Funktion <code>rufe</code>, die einen String als Parameter entgegennimmt und diesen String verdoppelt zur\xFCckgibt. "+"Gleichzeitig soll der Eingangsparameter und die R\xFCckgabe mit <code>jshero.log</code> geloggt werden. Der Aufruf <code>rufe(\"Werder\")</code> "+"sollte <code>\"WerderWerder\"</code> zur\xFCckgeben und es sollte nacheinander <code>\"Werder\"</code> und <code>\"WerderWerder\"</code> geloggt werden.",beforeTests:function(){if(typeof rufe!=="undefined"){rufe=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("rufe")},function(){return jshero.testutil.assert_functionHasNumOfParameter("rufe",1)},function(){return jshero.testutil.assert_functionReturns("rufe(\"Werder\")","WerderWerder")},function(){var ok,msg,e;try{rufe("Werder");var result=jshero.getLogs().length;if(result===2){ok=true;msg="<code>rufe(\"Werder\")</code> loggt mit <code>jshero.log</code> genau 2 mal."}else{ok=false;msg="<code>rufe(\"Werder\")</code> loggt mit <code>jshero.log</code> nicht 2 mal, sondern "+result+" mal."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>rufe(\"Werder\")</code>.";e=exc}return{msg:msg,ok:ok,e:e}},function(){var ok,msg,e;try{rufe("Werder");var result=jshero.getLogs()[0];if(result==="Werder"){ok=true;msg="<code>rufe(\"Werder\")</code> loggt als erstes die \xDCbergabe <code>\"Werder\"</code>."}else{ok=false;msg="<code>rufe(\"Werder\")</code> loggt als erstes nicht die \xDCbergabe <code>\"Werder\"</code>, sondern es wird <code>"+JSON.stringify(result)+"</code> geloggt."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>rufe(\"Werder\")</code>.";e=exc}return{msg:msg,ok:ok,e:e}},function(){var ok,msg,e;try{rufe("Werder");var result=jshero.getLogs()[1];if(result==="WerderWerder"){ok=true;msg="<code>rufe(\"Werder\")</code> loggt als zweites die R\xFCckgabe <code>\"WerderWerder\"</code>."}else{ok=false;msg="<code>rufe(\"Werder\")</code> loggt als zweites nicht die R\xFCckgabe <code>\"WerderWerder\"</code>, sondern es wird <code>"+JSON.stringify(result)+"</code> geloggt."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>rufe(\"Werder\")</code>.";e=exc}return{msg:msg,ok:ok,e:e}},function(){return jshero.testutil.assert_functionReturns("rufe(\"Kickers\")","KickersKickers")},function(){var ok,msg,e;try{rufe("Kickers");var result=jshero.getLogs()[0];if(result==="Kickers"){ok=true;msg="<code>rufe(\"Kickers\")</code> loggt als erstes die \xDCbergabe <code>\"Kickers\"</code>."}else{ok=false;msg="<code>rufe(\"Kickers\")</code> loggt als erstes nicht die \xDCbergabe <code>\"Kickers\"</code>, sondern es wird <code>"+JSON.stringify(result)+"</code> geloggt."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>rufe(\"Kickers\")</code>.";e=exc}return{msg:msg,ok:ok,e:e}},function(){var ok,msg,e;try{rufe("Kickers");var result=jshero.getLogs()[1];if(result==="KickersKickers"){ok=true;msg="<code>rufe(\"Kickers\")</code> loggt als zweites die R\xFCckgabe <code>\"KickersKickers\"</code>."}else{ok=false;msg="<code>rufe(\"Kickers\")</code> loggt als zweites nicht die R\xFCckgabe <code>\"KickersKickers\"</code>, sondern es wird <code>"+JSON.stringify(result)+"</code> geloggt."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>rufe(\"Werder\")</code>.";e=exc}return{msg:msg,ok:ok,e:e}}]});
jshero.koans.add({id:"math",title:"Math",lesson:"Viele mathematische Funktionen sind in dem Objekt <code>Math</code> zusammengefasst. "+"So gibt <code>Math.sqrt(x)</code> die Quadratwurzel (engl.: square root) zur\xFCck "+"und mit <code>Math.pow(x, y)</code> berechnet man die Potenz (engl.: power) x hoch y."+"<pre><code>var y1 = Math.sqrt(9);<br>var y2 = Math.pow(10, 3);</code></pre>"+"<code>y1</code> hat den Wert <code>3</code> und <code>y2</code> den Wert <code>1000</code> (10&sup3; = 10 * 10 * 10 = 1000). ",task:"Schreibe eine Funktion <code>hypotenuse</code>, die die L\xE4nge der Hypotenuse eines rechtwinkligen Dreiecks berechnet. "+"\xDCbergeben wird der Funktion als Parameter die L\xE4ngen der beiden Katheten. Tipp: In einem rechtwinkligen Dreieck gilt der Satz "+"des Pythagoras. Sind a, b die L\xE4ngen der beiden Katheten und c die L\xE4nge der Hypotenuse, so gilt: a&sup2; + b&sup2; = c&sup2;. "+"Da 3&sup2; + 4&sup2; = 5&sup2; gilt, sollte <code>hypotenuse(3, 4)</code> den Wert <code>5</code> liefern.",beforeTests:function(){if(typeof hypotenuse!=="undefined"){hypotenuse=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("hypotenuse")},function(){return jshero.testutil.assert_functionHasNumOfParameter("hypotenuse",2)},function(){return jshero.testutil.assert_functionReturns("hypotenuse(3, 4)",5)},function(){return jshero.testutil.assert_functionReturns("hypotenuse(5, 12)",13)},function(){return jshero.testutil.assert_functionReturns("hypotenuse(1, 1)",Math.sqrt(2))}]});
jshero.koans.add({id:"mean",title:"Klammern",lesson:"Ebenso wie in der Mathematik gilt in JavaScript die Punkt-vor-Strichrechnung. Multiplikation und Division werden vor Addition und Subtraktion "+"ausgef\xFChrt. M\xF6chte man zuerst die Strichrechnung ausf\xFChren, verwendet man genauso wie in der Mathematik Klammern."+"<pre><code>var x1 = 3 + 4 * 2;<br>var x2 = (3 + 4) * 2;</code></pre>"+"<code>x1</code> hat den Wert <code>11</code>, der Wert von <code>x2</code> ist <code>14</code>.",task:"Schreibe eine Funktion <code>mittelwert</code>, die zwei Zahlen als Parameter entgegennimmt und deren Mittelwert zur\xFCckgibt. "+"<code>mittelwert(1, 2)</code> sollte <code>1.5</code> ergeben.",beforeTests:function(){if(typeof mittelwert!=="undefined"){mittelwert=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("mittelwert")},function(){return jshero.testutil.assert_functionHasNumOfParameter("mittelwert",2)},function(){return jshero.testutil.assert_functionReturns("mittelwert(1, 2)",1.5)},function(){return jshero.testutil.assert_functionReturns("mittelwert(0, 0)",0)},function(){return jshero.testutil.assert_functionReturns("mittelwert(3, -1)",1)}]});
jshero.koans.add({id:"minmax",title:"Min und Max",lesson:"Das Minimum und Maximum einer Reihe von Zahlen bestimmt man mit\n<code>Math.min()</code> und <code>Math.max()</code>:\n\n<pre><code>var min = Math.min(5, 7);\nvar max = Math.max(3, 9, 2);</code></pre>\n\n<code>min</code> erh\xE4lt den Wert <code>5</code> und <code>max</code> den Wert <code>9</code>.\nDas Besondere: Beide Funktionen k\xF6nnen mit einer beliebigen Anzahl von Argumenten aufgerufen werden.",task:"Schreibe eine Funktion <code>bereichsmittel</code>, die das Bereichsmittel von 3 Zahlen berechnet.\nDas <a href=\"https://de.wikipedia.org/wiki/Mittelwert#Bereichsmittel\">Bereichsmittel</a>\neiner Reihe von Zahlen ist der Mittelwert der kleinsten und gr\xF6\xDFten Zahl.\n<code>bereichsmittel(3, 9, 1)</code> sollte <code>(9+1)/2</code> = <code>5</code> ergeben.",beforeTests:function(){if(typeof bereichsmittel!=="undefined"){bereichsmittel=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("bereichsmittel")},function(){return jshero.testutil.assert_functionHasNumOfParameter("bereichsmittel",3)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(3, 9, 1)",5)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(5, -5, 2)",0)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(8, 3, 0)",4)}]});
jshero.koans.add({id:"modulo",title:"Modulo",lesson:"Ein weiterer arithmetischer Operator ist Modulo. Er berechnet den Rest einer Division und wird mit dem Prozentzeichen <code>%</code> notiert."+"<pre><code>var x = 7 % 2;<br>"+"var y = 20 % 3;</code></pre>"+"7 geteilt durch 2 ergibt 3 Rest 1. <code>x</code> ist also <code>1</code>.<br>"+"20 geteilt durch 3 ergibt 6 Rest 2. <code>y</code> ist also <code>2</code>.",task:"Schreibe eine Funktion <code>einer</code>, die eine nat\xFCrliche Zahl entgegenimmt und die Ziffer der Einer-Stelle zur\xFCckgibt. "+"<code>einer(2674)</code> sollte <code>4</code> zur\xFCckgeben.",beforeTests:function(){if(typeof einer!=="undefined"){einer=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("einer")},function(){return jshero.testutil.assert_functionHasNumOfParameter("einer",1)},function(){return jshero.testutil.assert_functionReturns("einer(2674)",4)},function(){return jshero.testutil.assert_functionReturns("einer(210)",0)},function(){return jshero.testutil.assert_functionReturns("einer(17)",7)}]});
jshero.koans.add({id:"nan",title:"NaN",lesson:"<code>NaN</code> repr\xE4sentiert den Wert Not-A-Number (engl.: Keine-Zahl). Numerische Operationen oder Funktionen geben <code>NaN</code> zur\xFCck, "+"wenn sie keinen Wert berechnen k\xF6nnen. Wir hatten dies bei <code><a href=\"main.html?koan=parseint\">parseInt</a></code> kennengelernt. "+"<code>parseInt</code> gibt <code>NaN</code> zur\xFCck, wenn es keine Zahl parsen kann. Ein weiteres Beispiel ist die Berechnung der Wurzel aus einer negativen Zahl. "+"<pre><code>"+"var age = parseInt(\"Babylon\");<br>"+"var length = Math.sqrt(-1);"+"</code></pre>"+"Sowohl <code>age</code> als auch <code>length</code> haben den Wert <code>NaN</code>. "+"M\xF6chte man testen, ob <code>NaN</code> vorliegt, kann man leider nicht <code>===</code> verwenden. <code>age === NaN</code> ergibt auch dann <code>false</code>, "+"wenn <code>age</code> den Wert <code>NaN</code> besitzt. <code>NaN</code> ist der einzige Wert in JavaScript, der nicht mit sich selbst "+"gleich ist. Stattdessen verwendet man die Funktion <code>isNaN</code>."+"<pre><code>"+"var message;<br>"+"var age = parseInt(\"Babylon\");<br>"+"if ( isNaN(alter) ) {<br>"+"  message = \"Du hast keine Zahl eingegeben.\";<br>"+"}"+"</code></pre>",task:"Schreibe eine Funktion <code>parseFirstInt</code>, die einen String entgegennimmt und die die erste in dem String vorkommende ganze Zahl zur\xFCckgibt. "+"<code>parseFirstInt(\"Sonnebornstr. 27\")</code> sollte <code>27</code> zur\xFCckgeben. <code>parseFirstInt(\"Babylon\")</code> sollte <code>NaN</code> ergeben.",beforeTests:function(){if(typeof parseFirstInt!=="undefined"){parseFirstInt=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("parseFirstInt")},function(){return jshero.testutil.assert_functionHasNumOfParameter("parseFirstInt",1)},function(){return jshero.testutil.assert_functionReturns("parseFirstInt(\"Sonnebornstr. 27\")",27)},function(){return jshero.testutil.assert_functionReturns("parseFirstInt(\"28 Jahre\")",28)},function(){return jshero.testutil.assert_functionReturns("parseFirstInt(\"Andr\xE9 ist 22 Jahre alt.\")",22)},function(){var ok,msg,e;try{var result=parseFirstInt("Ohnezahl");ok=Number.isNaN(result);if(ok){msg="<code>parseFirstInt(\"Ohnezahl\")</code> ergibt <code>NaN</code>."}else{msg="<code>parseFirstInt(\"Ohnezahl\")</code> ergibt nicht <code>NaN</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>parseFirstInt(\"Ohnezahl\")</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'notequals',title:'Strikte Ungleichtheit',lesson:'Mit <code>!==</code> vergleicht man zwei Werte auf strikte Ungleichheit.\n\n<pre><code>var v1 = "lauf" !== "Lauf";\nvar v2 = 10 !== "10";</code></pre>\n\nBeide Vergleiche ergeben <code>true</code>. Der erste, weil sich die beiden\nStrings in der Gro\xDF- und Kleinschreibung unterscheiden.\nDer zweite, weil sich die beiden Werte von Typ her unterscheiden.',task:'Schreibe eine Funktion <code>ungleich</code>, die 3 Werte auf strikte Ungleichheit \xFCberpr\xFCft.\nDie Funktion soll nur dann <code>true</code> ergeben, wenn alle drei Parameter unterschiedlich sind.\n<code>ungleich(1, 2, 3)</code> soll <code>true</code> liefern, <code>ungleich(1, 1, 2)</code> soll\n<code>false</code> ergeben.',beforeTests:function(){if(typeof ungleich!=='undefined'){ungleich=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('ungleich')},function(){return jshero.testutil.assert_functionHasNumOfParameter('ungleich',3)},function(){return jshero.testutil.assert_functionReturns('ungleich(1, 2, 3)',true)},function(){return jshero.testutil.assert_functionReturns('ungleich(1, 2, 1)',false)},function(){return jshero.testutil.assert_functionReturns('ungleich(2, 1, 1)',false)},function(){return jshero.testutil.assert_functionReturns('ungleich("2", 2, 2)',false)},function(){return jshero.testutil.assert_functionReturns('ungleich("kLein", "klein", "kleiN")',true)},function(){return jshero.testutil.assert_functionReturns('ungleich("1", 1, true)',true)},function(){return jshero.testutil.assert_functionReturns('ungleich("klein", "klein", "kIein")',false)}]});
jshero.koans.add({id:"number",title:"Zahlen",lesson:"Zahlen werden in JavaScript durch einfache Ziffern dargestellt. Sie k\xF6nnen einen Dezimalpunkt und ein Minuszeichen besitzen."+"<pre><code>var x1 = 1;<br>var x2 = 1.0;<br>var x3 = 3.14;<br>var x4 = -1;</code></pre>"+"<code>1</code> und <code>1.0</code> sind dieselbe Zahl. "+"Mit Zahlen kann man rechnen. Die vier Grundrechenarten Addieren, Subtrahieren, Multiplizieren und Dividieren werden durch "+"<code>+ - *</code> und <code>/</code> dargestellt."+"<pre><code>var x1 = 6;<br>var x2 = 2;<br>var x3 = x1 + x2;<br>var x4 = x1 - x2;<br>var x5 = x1 * x2;<br>var x6 = x1 / x2;</code></pre>"+"Die Variablen <code>x3</code> bis <code>x6</code> haben so die Werte <code>8</code>, <code>4</code>, <code>12</code> und <code>3</code>.",task:"Schreibe eine Funktion <code>add</code>, die zwei Zahlen als Parameter entgegennimmt und deren Summe zur\xFCckgibt. "+"<code>add(1, 2)</code> sollte <code>3</code> ergeben.",beforeTests:function(){if(typeof add!=="undefined"){add=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("add")},function(){return jshero.testutil.assert_functionHasNumOfParameter("add",2)},function(){return jshero.testutil.assert_functionReturns("add(0, 0)",0)},function(){return jshero.testutil.assert_functionReturns("add(2, 3)",5)},function(){return jshero.testutil.assert_functionReturns("add(-1, 3)",2)}]});
jshero.koans.add({id:"numbertostring",title:"Number: toString()",lesson:"Die Number-Methode <code>toString</code> wandelt eine Zahl in den entsprechenden String um. Der Dezimalpunkt wird dabei als Punkt dargestellt. "+"Das kann man z.B. dazu verwenden, eine Zahl im deutschen Format, also mit Komma als Dezimalpunkt, auszugeben:"+"<code><pre>"+"var number = 7.25;<br>"+"var numberInEnglish = number.toString();<br>"+"var numberInGerman = numberInEnglish.replace(\".\", \",\");"+"</code></pre>"+"<code>numberInEnglish</code> enth\xE4lt den String <code>\"7.25\"</code>. Da wir jetzt unsere Zahl als String vorliegen haben, k\xF6nnen wir auf ihr die String-Methode "+"<code>replace</code> anwenden. <code>numberInGerman</code> enth\xE4lt so den String <code>\"7,25\"</code>.",task:"Schreibe eine Funktion <code>digitLength</code>, die eine nat\xFCrliche Zahl entgegennimmt und die Anzahl der Ziffern zur\xFCckgibt. "+"<code>digitLength(709)</code> sollte 3 zur\xFCckgeben.",beforeTests:function(){if(typeof digitLength!=="undefined"){digitLength=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("digitLength")},function(){return jshero.testutil.assert_functionHasNumOfParameter("digitLength",1)},function(){return jshero.testutil.assert_functionReturns("digitLength(1)",1)},function(){return jshero.testutil.assert_functionReturns("digitLength(709)",3)},function(){return jshero.testutil.assert_functionReturns("digitLength(100123)",5)}]});
jshero.koans.add({id:"parameter",title:"Parameter",lesson:"Jetzt lernen wir Funktionen mit Parametern kennen. Mit <pre><code>var gebe = function(eingabe) {<br>  return eingabe;<br>};</code></pre>"+"definieren wir eine Funktion, die den \xFCbergebenen Parameter <code>eingabe</code> einfach wieder zur\xFCckgibt. "+"Parameter sind Variablen. Sie stehen in der runden Klammer und ben\xF6tigen nicht das Schl\xFCsselwort <code>var</code> zu ihrer Deklaration. "+"Mit <pre><code>var ergebnis = gebe(\"Apfel\");</code></pre>"+"wird die Funktion mit dem Argument <code>\"Apfel\"</code> aufgerufen. Jetzt wird unsere zuvor definierte Funktion "+"ausgef\xFChrt. Dabei wird zun\xE4chst das Argument <code>\"Apfel\"</code> dem Parameter <code>eingabe</code> zugewiesen. <code>eingabe</code> hat jetzt den "+"Wert <code>\"Apfel\"</code>. In der einzigen Codezeile der Funktion wird nun die Variable <code>eingabe</code> mit der "+"<code>return</code>-Anweisung zur\xFCckgegeben. Diese R\xFCckgabe wird der Variablen <code>ergebnis</code> zugewiesen. <code>ergebnis</code> hat "+"dann auch den Wert <code>\"Apfel\"</code>.",task:"Schreibe eine Funktion <code>echo</code>, die ebenfalls den \xFCbergebenen Parameter wieder zur\xFCckgibt.",beforeTests:function(){if(typeof echo!=="undefined"){echo=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("echo")},function(){return jshero.testutil.assert_functionHasNumOfParameter("echo",1)},function(){return jshero.testutil.assert_functionReturns("echo(\"Hallo Welt!\")","Hallo Welt!")},function(){return jshero.testutil.assert_functionReturns("echo(\"Franz\")","Franz")}]});
jshero.koans.add({id:"parameter2",title:"Parameternamen",lesson:"Bitte achte darauf, dass du eventuelle Parameter deiner Funktion anders nennst als die Funktion selbst.\n  Die Funktion <code>f1</code> zum Beispiel\n\n<pre><code>var f1 = function(f1) {\n  return f1;\n};</code></pre>\n\n  macht das gleiche wie diese Funktion:\n\n<pre><code>var f2 = function(eingabe) {\n  return eingabe;\n};</code></pre>\n\n  Die zweite Funktionsdefinition ist aber besser, weil der Parameter <code>eingabe</code> hei\xDFt\n  und damit anders als die Funktion selbst.\n  ",task:"Schreibe eine Funktion <code>echo</code>, die einen Parameter hat und dessen Wert einfach zur\xFCckgibt.\n  Achte darauf, dass der Parameter anders hei\xDFt, als die Funktion selbst.\n  ",beforeTests:function(){echo=undefined},tests:[function(){return jshero.testutil.assert_isFunction("echo")},function(){return jshero.testutil.assert_functionHasNumOfParameter("echo",1)},function(){return jshero.testutil.assert_functionReturns("echo(\"Test\")","Test")},function(){return jshero.testutil.assert_functionReturns("echo(\"Hallo Welt!\")","Hallo Welt!")}]});
jshero.koans.add({id:"parseint",title:"parseInt",lesson:"H\xE4ufig m\xF6chte man eine Zahl, die als String vorliegt, in eine Zahl vom Typ Number umwandeln. "+"F\xFCr das Umwandeln von ganzen Zahlen (..., -2, -1, 0, 1, 2, ..) gibt es in JavaScript die Funktion <code>parseInt</code>. "+"Folgende Beispiele geben <code>19</code> oder <code>-19</code> zur\xFCck: "+"<pre><code>"+"var n1 = parseInt(\"19\", 10);<br>"+"var n2 = parseInt(\"+19\", 10);<br>"+"var n3 = parseInt(\"-19\", 10);<br>"+"var n4 = parseInt(\"19 Grad\", 10);<br>"+"var n5 = parseInt(\"19.1\", 10);<br>"+"var n6 = parseInt(\"019\", 10);<br>"+"var n7 = parseInt(\" 19\", 10);<br>"+"</code></pre>"+"Neben dem direkten Einlesen von ganzen Zahlen mit oder ohne Vorzeichen (n1, n2, n3) beherrscht <code>parseInt</code> auch einige komplexe F\xE4lle. Nicht-numerische Zeichen nach "+"der ganzen Zahl (n4, n5) sowie Nullen (n6) und Leerzeichen (n7) vor der Zahl werden ignoriert.<br><br>"+"In allen Beispielen ist der zweite an <code>parseInt</code> \xFCbergebene Parameter <code>10</code>. Dieser Paramter gibt an, zu welcher Basis die Zahl "+"interpretiert werden soll. <code>10</code> steht f\xFCr das \xFCbliche Dezimalsystem. L\xE4\xDFt man den zweiten Paramter weg, wird normalerweise das Dezimalsystem als Default verwendet. "+"Da es aber von dieser Regel Ausnahmen gibt und diese Ausnahmen in verschiedenen Browsern auch noch unterschiedlich gehandhabt werden, sollte man immer die Basis mit angeben!<br><br>"+"Kann <code>parseInt</code> keine Zahl einlesen, gibt sie den Wert <code>NaN</code> (engl.: Not a Number) zur\xFCck:"+"<pre><code>"+"var n1 = parseInt(\"Nur Text\", 10);<br>"+"var n2 = parseInt(\"Nr. 8\", 10);<br>"+"</code></pre>"+"Im ersten Fall ist \xFCberhaupt keine Zahl vorhanden. Im zweiten Fall gibt es nicht-numerische Zeichen vor der eigentlichen Zahl. Auch das ist nicht zul\xE4ssig und f\xFChrt zur R\xFCckgabe "+"<code>NaN</code>.",task:"Schreibe eine Funktion <code>add</code>, die einen String mit einer Additionsaufgabe entgegennimmt und die das Ergebnis der Addition als Zahl zur\xFCckgibt. "+"Es sollen zwei nat\xFCrliche Zahlen addiert werden. Die Additionsaufgabe ist ein String der Form \"zahl1+zahl2\". So soll <code>add(\"100+19\")</code> die Zahl <code>119</code> zur\xFCckgeben.",beforeTests:function(){if(typeof add!=="undefined"){add=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("add")},function(){return jshero.testutil.assert_functionHasNumOfParameter("add",1)},function(){return jshero.testutil.assert_functionReturns("add(\"1+2\")",3)},function(){return jshero.testutil.assert_functionReturns("add(\"100123+456\")",100579)},function(){return jshero.testutil.assert_functionReturns("add(\"-10+6\")",-4)}]});
jshero.koans.add({id:"pi",title:"Math.PI",lesson:"Neben Funktionen bietet <code>Math</code> auch einige mathematische Konstanten an. "+"<code>Math.PI</code> liefert die Kreiszahl &pi; (gerundet 3.14) und <code>Math.E</code> die Eulersche Zahl e (gerundet 2.71). "+"Beachte: Die Konstanten werden im Gegensatz zu Funktionen ohne anschlie\xDFende Klammern aufgerufen.",task:"Schreibe eine Funktion <code>flaeche</code>, die die Fl\xE4che eines Kreises berechnet. "+"\xDCbergeben wird der Funktion als Parameter der Radius des Kreises. Tipp: Die Fl\xE4che eines Kreises ist &pi; * r&sup2;. "+"Dabei ist r der Radius des Kreises.",beforeTests:function(){if(typeof flaeche!=="undefined"){flaeche=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("flaeche")},function(){return jshero.testutil.assert_functionHasNumOfParameter("flaeche",1)},function(){return jshero.testutil.assert_functionReturns("flaeche(4)",Math.PI*4*4)},function(){return jshero.testutil.assert_functionReturns("flaeche(1)",Math.PI)},function(){return jshero.testutil.assert_functionReturns("flaeche(0)",0)}]});
(function(){var isOneToSix=function(x){return x===1||x===2||x===3||x===4||x===5||x===6};var throwA=function(x){var result;for(var i=0;i<1000;i++){result=dice();if(result===x){return true}}return false};var testWith=function(x){var ok,msg,e;try{ok=throwA(x);if(ok){msg='<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>'+x+'</code> zur\xFCck.'}else{msg='<code>dice()</code> gab bei 1000 Aufrufen keine <code>'+x+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>dice()</code>.';e=exc}return{ok:ok,msg:msg,e:e}};jshero.koans.add({id:'random',title:'Zufallszahlen',lesson:'Mit <code>Math.random()</code> erzeugt man eine Pseudozufallszahl zwischen 0 (inklusive) und 1 (exklusive).\n\n<pre><code>var x = Math.random();</code></pre>\n\n<code>x</code> k\xF6nnte z.B. den Wert <code>0.6206372241429993</code> erhalten.\nJeder Aufruf von <code>Math.random()</code> generiert eine neue Pseudozufallszahl.\nDie Zahlen sind zwischen 0 und 1 gleichverteilt. Sie hei\xDFen Pseudozufallszahlen,\nweil sie zuf\xE4llig aussehen, aber dennoch berechnet werden.\nM\xF6chte man Zufallszahlen in einem anderen Wertebereich oder mit einer anderen Verteilung erhalten,\nmuss man die von <code>Math.random()</code> generierten Zahlen\ngeeignet umrechnen. Das soll jetzt gleich ge\xFCbt werden.',task:'Schreibe eine Funktion <code>dice</code>, die wie ein W\xFCrfel eine Zufallszahl zwischen 1 und 6 zur\xFCckgibt.',beforeTests:function(){if(typeof dice!=='undefined'){dice=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('dice')},function(){return jshero.testutil.assert_functionHasNumOfParameter('dice',0)},function(){var ok,msg,e;try{ok=true;var result;for(var i=0;i<1000;i++){result=dice();if(!isOneToSix(result)){ok=false;break}}if(ok){msg='<code>dice()</code> gab bei 1000 Aufrufen nur nat\xFCrliche Zahlen zwischen <code>1</code> und <code>6</code> zur\xFCck.'}else{msg='<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>'+JSON.stringify(result)+'</code> zur\xFCck. Dies ist keine nat\xFCrliche Zahl zwischen <code>1</code> und <code>6</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>dice()</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){return testWith(1)},function(){return testWith(2)},function(){return testWith(3)},function(){return testWith(4)},function(){return testWith(5)},function(){return testWith(6)}]})})();
jshero.koans.add({id:'replace',title:'String: replace()',lesson:'Die Methode <code>replace</code> ersetzt einen Teilstring durch einen anderen:\n\n<pre><code>var str = "Hallo Marcel!";\nvar newstr = str.replace("Marcel", "Robert");</code></pre>\n\n"Marcel" wird durch "Robert" ersetzt. <code>newstr</code> hat also den Wert <code>"Hallo Robert!"</code>.\nDer urspr\xFCngliche String bleibt unver\xE4ndert. Nur das erste Vorkommen wird ersetzt:\n\n<pre><code>var newname = "Peter".replace("e", "a");</code></pre>\n\n<code>newname</code> enth\xE4lt den Wert <code>"Pater"</code> und nicht <code>"Patar"</code>.\nEin Spezialfall ergibt sich, wenn der ersetzende String der Leerstring ist:\n\n<pre><code>var nurso = "sowie so".replace("wie", "");</code></pre>\n\nDer zu ersetzende String wird entfernt. <code>nurso</code> enth\xE4lt den Wert <code>"so so"</code>.\nKommt der zu ersetzende String nicht vor, so wird der urspr\xFCngliche String zur\xFCckgegeben.',task:'Schreibe eine Funktion <code>convert</code>, die einen Datumsstring in englischer Schreibweise (20-05-2017 oder 20/05/2017) in\ndeutsche Schreibweise (20.05.2017) umwandet. Sowohl <code>convert("20-05-2017")</code> als auch <code>convert("20/05/2017")</code>\nsollten <code>"20.05.2017"</code> ergeben.',beforeTests:function(){if(typeof convert!=='undefined'){convert=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('convert')},function(){return jshero.testutil.assert_functionHasNumOfParameter('convert',1)},function(){return jshero.testutil.assert_functionReturns('convert("10-07-1871")','10.07.1871')},function(){return jshero.testutil.assert_functionReturns('convert("8/11/1922")','8.11.1922')}]});
jshero.koans.add({id:"round",title:"Runden",lesson:"M\xF6chte man eine Dezimalzahl auf- oder abrunden, stehen einem die Funktionen <code>Math.round()</code>,\n<code>Math.floor()</code> (engl.: Boden) und <code>Math.ceil()</code> (engl: Decke) zur Verf\xFCgung.\n\n<pre><code>var a = Math.round(5.49);\nvar b = Math.round(4.5);\nvar c = Math.floor(5.99);\nvar d = Math.ceil(4.01);</code></pre>\n\n<code>Math.round()</code> rundet kaufm\xE4nnisch. Zahlen mit der ersten Dezimalstelle kleiner gleich 4 werden abgerundet, alle anderen aufgerundet.\n<code>Math.floor()</code> rundet immer ab und <code>Math.ceil()</code> rundet immer auf. Die Variablen <code>a</code> bis <code>d</code>\nerhalten also alle den Wert <code>5</code>.",task:"Schreibe eine Funktion <code>round100</code>, die eine Dezimalzahl kaufm\xE4nnisch auf die Hunderterstelle rundet.\n<code>round100(1749)</code> sollte <code>1700</code> und <code>round100(856.123)</code> sollte <code>900</code> ergeben.\nTipp:&nbsp;Verwende neben <code>Math.round()</code> noch Multiplikation und Division.",beforeTests:function(){if(typeof round100!=="undefined"){round100=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("round100")},function(){return jshero.testutil.assert_functionHasNumOfParameter("round100",1)},function(){return jshero.testutil.assert_functionReturns("round100(49.999)",0)},function(){return jshero.testutil.assert_functionReturns("round100(4650)",4700)}]});
jshero.koans.add({id:"string",title:"Strings",lesson:"Wir haben gesehen, dass eine Variable ein Beh\xE4lter f\xFCr einen Wert ist. Werte besitzen dabei einen Typ. So kann ein Wert eine Zahl\n    wie <code>7.12</code> sein. Der Typ von <code>7.12</code> ist Zahl. Oder ein Wert kann ein Text wie <code>\"Hallo Welt!\"</code> sein.\n    Der Typ von <code>\"Hallo Welt!\"</code> ist Text. Diesen Typ\n    bezeichnet man auch als Zeichenkette oder String. Strings schreibt man immer in einfachen oder doppelten Anf\xFChrungszeichen. So ist \"Hallo Welt!\" derselbe String\n    wie 'Hallo Welt!'.<br>Mit Strings kann man arbeiten. Man kann sie zum Beispiel verketten. Dies macht man mit dem <code>+</code> Zeichen.\n    So liefert <code>\"Blau\" + \"meier\"</code> den String <code>\"Blaumeier\"</code>.<br>Die folgende Funktion h\xE4ngt an dem \xFCbergebenen Parameter einen Text an und\n    gibt den zusammengesetzten Text zur\xFCck: <pre><code>var lobe = function(name) {<br>  return name + \" ist toll!\";<br>};</code></pre>\n    So liefert <code>lobe(\"JavaScript\")</code> den Wert <code>\"JavaScript ist toll!\"</code>.",task:"Schreibe eine Funktion <code>begruesse</code>, die einen Parameter entgegennimmt und die <code>\"Hallo &lt;Parameter&gt;!\"</code> zur\xFCckgibt.\n    \xDCbergibt man der Funktion <code>\"Maria\"</code>, so sollte die Funktion <code>\"Hallo Maria!\"</code> zur\xFCckgeben. \xDCbergibt man der Funktion <code>\"Franz\"</code>,\n    so sollte die R\xFCckgabe <code>\"Hallo Franz!\"</code> sein.",beforeTests:function(){begruesse=undefined},tests:[function(){return jshero.testutil.assert_isFunction("begruesse")},function(){return jshero.testutil.assert_functionHasNumOfParameter("begruesse",1)},function(){return jshero.testutil.assert_functionReturns("begruesse(\"Maria\")","Hallo Maria!")},function(){return jshero.testutil.assert_functionReturns("begruesse(\"Franz\")","Hallo Franz!")}]});
jshero.koans.add({id:'stringcharat',title:'String: charAt()',lesson:'Um aus einem String das Zeichen an einer bestimmten Stelle zu erhalten, verwendet man die Methode '+'<code>charAt(index)</code>. Der Paramter <code>index</code> gibt die Stelle des Zeichens innerhalb der Zeichenkette an. '+'Dabei hat das erste Zeichen einer Zeichenkette den Index 0:'+'<pre><code>var n1 = "Maria".charAt(0);<br>var n2 = "Maria".charAt(1);<br>var n3 = "Maria".charAt(5);<br>var n4 = "Maria".charAt();</code></pre>'+'<code>n1</code> hat den Wert <code>"M"</code> und <code>n2</code> hat den Wert <code>"a"</code>. Ist der Index gr\xF6\xDFer als der Index des letzten Zeichens, '+'wird der leere String zur\xFCckgegeben. <code>n3</code> hat also den Wert <code>""</code>. '+'Wird kein Parameter \xFCbergeben, so wird das Zeichen mit dem Index <code>0</code> zur\xFCckgegeben. Man sagt: der Default-Wert f\xFCr <code>index</code> '+'ist <code>0</code>. Der Wert von <code>n4</code> ist also auch <code>"M"</code>.',task:'Schreibe eine Funktion <code>abkuerzung</code>, die zwei Strings als Parameter entgegennimmt und als R\xFCckgabe die Anfangsbuchstaben '+'dieser Strings zur\xFCckgibt. <code>abkuerzung("Hansestadt", "Bremen")</code> sollte <code>"HB"</code> zur\xFCckliefern.',beforeTests:function(){if(typeof abkuerzung!=='undefined'){abkuerzung=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('abkuerzung')},function(){return jshero.testutil.assert_functionHasNumOfParameter('abkuerzung',2)},function(){return jshero.testutil.assert_functionReturns('abkuerzung("Hansestadt", "Bremen")','HB')},function(){return jshero.testutil.assert_functionReturns('abkuerzung("Java", "Script")','JS')}]});
jshero.koans.add({id:'stringindexof',title:'String: indexOf()',lesson:'Um die Position eines Strings innerhalb eines anderen Strings zu bestimmen, verwendet man die Methode <code>indexOf</code>:\n\n<pre><code>\'var n1 = "Fred Feuerstein".indexOf("Feuer");\nvar n2 = "Fred Feuerstein".indexOf("Rauch");\nvar n3 = "Fred Feuerstein".indexOf("FEUER");</code></pre>\n\n<code>n1</code> ist <code>5</code>, da <code>"Feuer"</code> in <code>"Fred Feuerstein"</code> an der 5. Stelle beginnt.\nWie \xFCblich werden Strings von 0 an durchnummeriert.\nKommt das Suchwort im aufrufenden String nicht vor, wird <code>-1</code> zur\xFCckgegeben. <code>n2</code> ist also <code>-1</code>.\nDie Methode <code>indexOf()</code> unterscheidet zwischen Gro\xDF- und Kleinschreibung. <code>n3</code> ist also auch <code>-1</code>.',task:'Schreibe eine Funktion <code>indexOfIgnoreCase</code>, die 2 Strings entgegennimmt und wie die Methode <code>indexOf</code> die Position des\nzweiten Strings im ersten String bestimmt. Im Unterschied zur Methode <code>indexOf</code> soll die Gro\xDF- oder Kleinschreibung keine Rolle spielen.\nSowohl <code>indexOfIgnoreCase("So", "so")</code> als auch <code>indexOfIgnoreCase("so", "So")</code> sollen <code>0</code> ergeben.',beforeTests:function(){if(typeof indexOfIgnoreCase!=='undefined'){indexOfIgnoreCase=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('indexOfIgnoreCase')},function(){return jshero.testutil.assert_functionHasNumOfParameter('indexOfIgnoreCase',2)},function(){return jshero.testutil.assert_functionReturns('indexOfIgnoreCase("Fred Feuerstein", "FEUER")',5)},function(){return jshero.testutil.assert_functionReturns('indexOfIgnoreCase("WILMA FEUERSTEIN", "feuer")',6)},function(){return jshero.testutil.assert_functionReturns('indexOfIgnoreCase("JavaScript", "Script")',4)}]});
jshero.koans.add({id:'stringindexof2',title:'String: indexOf(), 2. Parameter',lesson:'Der Methode <code>indexOf</code> kann man als zweiten Parameter noch die Stelle mitgeben,\nab der der Suchstring im aufrufenden String gesucht werden soll.\n\n<pre><code>var n1 = "Fred Feuerstein".indexOf("e", 2);\nvar n2 = "Fred Feuerstein".indexOf("e", 3);\nvar n3 = "Fred Feuerstein".indexOf("e", 7);</code></pre>\n\nDas erste <code>"e"</code> befindet sich in <code>"Fred Feuerstein"</code> an 2. Stelle. Es wird bei einer Suche ab der 2. Stelle gefunden. <code>n1</code>\nist also 2. Das zweite <code>"e"</code> in <code>"Fred Feuerstein"</code> befindet sich an der 6. Stelle. Es wird bei der Suche ab der 3. Stelle gefunden.\n<code>n2</code> ist <code>6</code>. Mit der dritten Codezeile wird das dritte <code>"e"</code> in <code>"Fred Feuerstein"</code> gefunden.\n<code>n3</code> ist <code>8</code>.',task:'Schreibe eine Funktion <code>secondIndexOf</code>, die 2 Strings entgegennimmt und die zweite Position des\nzweiten Strings im ersten String bestimmt. Kommt der Suchstring nicht zweimal vor, so soll <code>-1</code> zur\xFCckgegeben werden.\n<code>secondIndexOf("Ida-Ida", "Ida")</code> soll <code>4</code> zur\xFCckgeben.\n<br/>Tipp: Falls Du Hilfe brauchst, lese dir auch die Beschreibung in\n<a href="https://wiki.selfhtml.org/wiki/JavaScript/Objekte/String/indexOf">SELFHTML</a> durch.',beforeTests:function(){if(typeof secondIndexOf!=='undefined'){secondIndexOf=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('secondIndexOf')},function(){return jshero.testutil.assert_functionHasNumOfParameter('secondIndexOf',2)},function(){return jshero.testutil.assert_functionReturns('secondIndexOf("Ida-Ida", "Ida")',4)},function(){return jshero.testutil.assert_functionReturns('secondIndexOf("a rose is a rose", "rose")',12)},function(){return jshero.testutil.assert_functionReturns('secondIndexOf("There is no there there.", "there")',18)},function(){return jshero.testutil.assert_functionReturns('secondIndexOf("There is no there there.", "There")',-1)}]});
jshero.koans.add({id:"stringlength",title:"String: length",lesson:"Strings besitzen die Eigenschaft <code>length</code>. Diese Eigenschaft liefert die Anzahl der Zeichen eines Strings. "+"Dazu muss man dem String  oder der Variablen, die den String enth\xE4lt, <code>.length</code> anh\xE4ngen:"+"<pre><code>var anzahl = \"Franz\".length;</code/></pre>"+"<code>\"Franz\"</code> hat 5 Zeichen. Also hat <code>anzahl</code> jetzt den Wert <code>5</code>."+"<pre><code>var stadt = \"Prag\";<br>anzahl = stadt.length;</code/></pre>"+"<code>\"Prag\"</code> hat 4 Zeichen. <code>anzahl</code> hat jetzt den Wert <code>4</code>."+"<pre><code>anzahl = \"\".length;</code/></pre>"+"Der Leerstring besitzt keine Zeichen. Der Wert von <code>anzahl</code> ist jetzt <code>0</code>.",task:"Schreibe eine Funktion <code>laenge</code>, die bei \xDCbergabe eines Strings die Anzahl der Zeichen dieses Strings zur\xFCckgibt. "+"<code>laenge(\"Franz\")</code> sollte <code>5</code> zur\xFCckgeben.",beforeTests:function(){if(typeof laenge!=="undefined"){laenge=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("laenge")},function(){return jshero.testutil.assert_functionHasNumOfParameter("laenge",1)},function(){return jshero.testutil.assert_functionReturns("laenge(\"Hallo Welt!\")",11)},function(){return jshero.testutil.assert_functionReturns("laenge(\"\")",0)}]});
jshero.koans.add({id:'stringsplit',title:'String: split()',lesson:'Die Methode <code>split</code> zerlegt einen String anhand eines Trennstrings in Teilstrings. Die Teilstrings werden als Array zur\xFCckgegeben. '+'Der urspr\xFCngliche String wird nicht ver\xE4ndert.'+'<pre><code>'+'var date = "31-10-2017";<br>'+'var parts = date.split("-");<br>'+'var day = parts[0]; // "31"<br>'+'var month = parts[1]; // "10"<br>'+'var year = parts[2]; // "2017"<br>'+'</code></pre>'+'Der Trennstring ist hier der Bindestrich. Er zerlegt den Datumsstring in drei Teile. Diese drei Teile werden als Array der Variablen <code>parts</code> zugewiesen. '+'Anschlie\xDFend werden die einzelnen Teile aus dem Array ausgelesen und gesonderten Variablen zugewiesen. Die Variable <code>date</code> hat weiterhin den Wert <code>"31-10-2017"</code>.',task:'Schreibe eine Funktion <code>add</code>, die einen String mit einer Additionsaufgabe entgegennimmt und die das Ergebnis der Addition als Zahl zur\xFCckgibt. '+'Es sollen endlich viele nat\xFCrliche Zahlen addiert werden. Die Additionsaufgabe ist ein String der Form "1+19+...+281". '+'So soll <code>add("7+12+100")</code> die Zahl <code>119</code> zur\xFCckgeben.',beforeTests:function(){if(typeof add!=='undefined'){add=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('add')},function(){return jshero.testutil.assert_functionHasNumOfParameter('add',1)},function(){return jshero.testutil.assert_functionReturns('add("1+2")',3)},function(){return jshero.testutil.assert_functionReturns('add("12+5+1+10")',28)},function(){return jshero.testutil.assert_functionReturns('add("50000+4000+300+20+1")',54321)},function(){return jshero.testutil.assert_functionReturns('add("13+2+4+100+3")',122)}]});
jshero.koans.add({id:'stringsubstr',title:'String: substr()',lesson:'Die Methode <code>substr</code> extrahiert aus einen String einen Teilstring:\n\n<pre><code>var see = "see and stop".substr(0, 3);\nvar and = "see and stop".substr(4, 3);\nvar stop = "see and stop".substr(8);</code></pre>\n\nDer erste Parameter gibt an, von welcher Stelle an der Substring extrahiert werden soll.\nDer zweite Parameter gibt an, wieviel Zeichen ab der festgelegten Stelle extrahiert werden sollen.\nIst der zweite Paramter nicht angegeben, so wird immer bis zum Ende des urspr\xFCglichen Strings extrahiert.',task:'Schreibe eine Funktion <code>firstWord</code>, die einen String entgegennimmt und das erste Wort\nin diesem String zur\xFCckgibt. Das erste Wort sind dabei alle Zeichen bis zum ersten Leerzeichen.\n<code>firstWord("Wo ist hier")</code> sollte <code>"Wo"</code> zur\xFCckgeben.',beforeTests:function(){if(typeof firstWord!=='undefined'){firstWord=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('firstWord')},function(){return jshero.testutil.assert_functionHasNumOfParameter('firstWord',1)},function(){return jshero.testutil.assert_functionReturns('firstWord("Wo ist hier")','Wo')},function(){return jshero.testutil.assert_functionReturns('firstWord("Irres Licht")','Irres')}]});
jshero.koans.add({id:'stringupper',title:'String: toUpperCase()',lesson:'Neben der Eigenschaft <code>length</code> besitzen Strings noch eine Reihe von Methoden. Das sind Funktionen, die direkt auf dem String angewendet werden. '+'Wie die Eigenschaft <code>length</code> werden diese Methoden mit einem Punkt direkt dem String oder einer Variablen, die einen String enth\xE4lt, angeh\xE4ngt. '+'Da Methoden Funktionen sind, folgen in runden Klammern eingeschlossen die Argumente. '+'Zwei dieser String-Methoden sind die parameterlosen Methoden <code>toUpperCase</code> und <code>toLowerCase</code>. '+'Sie geben den String, auf dem sie angewendet werden, in Gro\xDF- bzw. Kleinbuchstaben zur\xFCck. Wichtig ist, dass der eigentliche String unver\xE4ndert bleibt. '+'Die R\xFCckgabe dieser Methoden ist der in Gro\xDF- bzw. Kleinbuchstaben umgewandelte String.'+'<pre><code>var stadt = "Prag";<br>var ausgabe = stadt.toUpperCase();</code/></pre>'+'<code>ausgabe</code> erh\xE4lt den Wert <code>"PRAG"</code>. <code>stadt</code> hat weiterhin den Wert <code>"Prag"</code>.'+'<pre><code>ausgabe = stadt.toLowerCase();</code/></pre>'+'Jetzt hat <code>ausgabe</code> den Wert <code>"prag"</code>.'+'<pre><code>ausgabe = "Flug 714".toUpperCase();</code/></pre>'+'Hier wird <code>toUpperCase()</code> direkt auf einen String angewendet. Der Wert von <code>ausgabe</code> ist <code>"FLUG 714"</code>. '+'Zahlen und auch Sonderzeichen werden nicht ver\xE4ndert.',task:'Schreibe eine Funktion <code>toCase</code>, die bei \xDCbergabe eines Strings diesen aneinandergeh\xE4ngt in Klein- und in Gro\xDFschreibung zur\xFCckgibt. '+'Das Trennzeichen zwischen der Klein- und Gro\xDFschreibung soll <code>-</code> sein. '+'<code>toCase("Ida")</code> sollte <code>"ida-IDA"</code> zur\xFCckgeben.',beforeTests:function(){if(typeof toCase!=='undefined'){toCase=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('toCase')},function(){return jshero.testutil.assert_functionHasNumOfParameter('toCase',1)},function(){return jshero.testutil.assert_functionReturns('toCase("Ida")','ida-IDA')},function(){return jshero.testutil.assert_functionReturns('toCase("Paris")','paris-PARIS')}]});
jshero.koans.add({id:'subfunction',title:'Funktionen benutzen Funktionen',lesson:'Funktionen k\xF6nnen weitere Funktionen aufrufen:'+'<pre><code>'+'var brutto = function(netto) {<br>'+'  var steuersatz = 19;<br>'+'  var steuer = netto * steuersatz / 100;<br>'+'  return netto + steuer;<br>'+'};<br><br>'+'var addiereMitMehrwertsteuer = function(nettoX, nettoY) {<br>'+'  var bruttoX = brutto(nettoX);<br>'+'  var bruttoY = brutto(nettoY);<br>'+'  return bruttoX + bruttoY;<br>'+'};</code></pre>'+'<code>addiereMitMehrwertsteuer</code> nimmt 2 Nettobetr\xE4ge entgegen und gibt die Summe der Bruttobetr\xE4ge zur\xFCck. <code>brutto</code> '+'berechnet aus einem Nettobetrag den Bruttobetrag. Dabei wird eine Mehrwertsteuer von 19% zugrunde gelegt. '+'Anstatt den Bruttobetrag selbst zu berechnen, ruft <code>addiereMitMehrwertsteuer</code> die Funktion '+'<code>brutto</code> auf. Das hat zwei Vorteile: Der Code ist besser lesbar und die Bruttoberechnung wird zentral an einer Stelle durchgef\xFChrt.',task:'Schreibe eine Funktion <code>sum</code>, die ein Array gef\xFCllt mit Zahlen entgegennimmt und die Summe dieser Zahlen zur\xFCckgibt. '+'Schreibe eine Funktion <code>mean</code>, die ein Array gef\xFCllt mit Zahlen entgegennimmt und den Durchschnitt dieser Zahlen zur\xFCckgibt. '+'Die Funktion <code>mean</code> soll dabei die Funktion <code>sum</code> benutzen.',beforeTests:function(){if(typeof sum!=='undefined'){mean=undefined}if(typeof mean!=='undefined'){mean=undefined}},tests:[// sum
function(){return jshero.testutil.assert_isFunction('sum')},function(){return jshero.testutil.assert_functionHasNumOfParameter('sum',1)},function(){return jshero.testutil.assert_functionReturns('sum([0])',0)},function(){return jshero.testutil.assert_functionReturns('sum([1, 2])',3)},function(){return jshero.testutil.assert_functionReturns('sum([1, 4, 10, 85])',100)},function(){return jshero.testutil.assert_functionReturns('sum([-2, -4, 17, 34])',45)},// mean
function(){return jshero.testutil.assert_isFunction('mean')},function(){return jshero.testutil.assert_functionHasNumOfParameter('mean',1)},function(){return jshero.testutil.assert_functionReturns('mean([0])',0)},function(){return jshero.testutil.assert_functionReturns('mean([1, 2])',1.5)},function(){return jshero.testutil.assert_functionReturns('mean([1, 4, 10, 85])',25)},function(){return jshero.testutil.assert_functionReturns('mean([-2, -4, 17, 34])',11.25)},// mean calls sum
function(){var msg,e;var sumIsCalled=false;var oldSum=sum;sum=function(x){sumIsCalled=true;return oldSum(x)};mean([1,2,9]);try{if(sumIsCalled){msg='<code>mean</code> ruft <code>sum</code> auf.'}else{msg='<code>mean</code> ruft nicht <code>sum</code> auf.'}}catch(exc){sumIsCalled=false;msg='Fehler beim Aufruf von <code>mean([1, 2, 9])</code>.';e=exc}return{ok:sumIsCalled,msg:msg,e:e}}]});
jshero.koans.add({id:"trim",title:"String: trim()",lesson:"Die Methode <code>trim</code> entfernt Leerzeichen an beiden Enden eines Strings. Der an den Enden um Leerzeichen bereinigte String wird zur\xFCckgegeben. "+"Der urspr\xFCgliche String bleibt unver\xE4ndert."+"<pre><code>"+"var eingabe = \" Rosa Parks \";<br>"+"var name = eingabe.trim();"+"</code></pre>"+"<code>name</code> enth\xE4lt den String <code>\"Rosa Parks\"</code>. Wie angedeutet werden h\xE4ufig Benutzereingaben vor der Verarbeitung getrimmt.",task:"Schreibe eine Funktion <code>firstChar</code>, die bei \xDCbergabe eines Strings das erste Zeichen, das kein Leerzeichen ist, zur\xFCckgibt. "+"<code>firstChar(\" Rosa\")</code> sollte <code>\"R\"</code> zur\xFCckgeben.",beforeTests:function(){if(typeof firstChar!=="undefined"){firstChar=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("firstChar")},function(){return jshero.testutil.assert_functionHasNumOfParameter("firstChar",1)},function(){return jshero.testutil.assert_functionReturns("firstChar(\" Maria\")","M")},function(){return jshero.testutil.assert_functionReturns("firstChar(\"Franz\")","F")}]});
(function(dateUtil){jshero.koans.add({id:'undefined',title:'undefined',lesson:'Bisher hatten wir Variablen bei der Deklaration immer auch initialisiert.'+'<pre><code>'+'// Deklaration und Initialisierung<br>'+'var x = 1;'+'</code></pre>'+'Man kann eine Varialbe aber auch deklarieren und ihr sp\xE4ter einen Wert zuweisen.'+'<pre><code>'+'var x; // Deklaration<br>'+'x = 1; // Initialisierung'+'</code></pre>'+'Variablen, die nicht initialisiert wurden, haben den Wert <code>undefined</code> (engl.: nicht definiert). '+'In der Praxis kommt das bei Funktionsaufrufen am h\xE4ufigsten vor. Ruft man eine Funktion, die einen Parameter erwartet, ohne Argument auf, '+'dann erh\xE4lt der Funktionsparameter den Wert <code>undefined</code>.'+'<pre><code>'+'var echo = function(x) {<br>'+'  return x;<br>'+'};<br>'+'// Aufruf ohne Argument<br>'+'var y = echo();'+'</code></pre>'+'<code>echo</code> wird ohne Argument aufgerufen. Dem Parameter <code>x</code> wird so kein Wert zugewiesen, er erh\xE4lt den Wert <code>undefined</code>. '+'Da <code>echo</code> den Parameter <code>x</code> einfach nur zur\xFCckgibt, erh\xE4lt auch <code>y</code> den Wert <code>undefined</code>. <br><br>'+'Eine Funktion, die einen Parameter erwartet, kann immer auch ohne Argument aufgerufen werden. Man sollte sich beim Schreiben von Funktionen also immer \xFCberlegen, '+'was in diesem Fall passieren soll. Gute Praxis ist es, in einem solchen Fall dem Parameter einen Default-Wert (engl.: Vorgabe) zuzuweisen. '+'Das hatten wir schon bei der String-Methode <code>charAt(index)</code> kennen gelernt. Normalerweise gibt diese Methode den Buchstaben an der Stelle <code>index</code> '+'zur\xFCck. Rufen wir <code>charAt</code> ohne Argument auf, erh\xE4lt <code>index</code> den Default <code>0</code>. Es wird der Buchstabe an der Stelle <code>0</code> zur\xFCckgegeben. '+'Um eine Varaible auf <code>undefined</code> zu \xFCberpr\xFCfen, verwendet man wie \xFCblich die strikte Gleichkeit. Die Methode <code>charAt</code> k\xF6nnte also folgenden Code-Ausschnitt enthalten:'+'<pre><code>'+'if (index === undefined) {<br>'+'  index = 0;<br>'+'}<br>'+'</code></pre>',task:'Schreibe eine Funktion <code>hallo</code>, die einen String als Parameter entgegennimmt und <code>"Hallo &lt;Parameter&gt;!"</code> zur\xFCckgibt. '+'<code>hallo("Akg\xFCn")</code> sollte <code>"Hallo Akg\xFCn!"</code> zur\xFCckgeben. Wird <code>hallo</code> ohne Argument aufgerufen, so soll <code>"Hallo Welt!"</code> zur\xFCckgegeben werden.',beforeTests:function(){if(typeof hallo!=='undefined'){hallo=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('hallo')},function(){return jshero.testutil.assert_functionHasNumOfParameter('hallo',1)},function(){return jshero.testutil.assert_functionReturns('hallo("Melek")','Hallo Melek!')},function(){return jshero.testutil.assert_functionReturns('hallo("Stefan")','Hallo Stefan!')},function(){return jshero.testutil.assert_functionReturns('hallo()','Hallo Welt!')}]})})(jshero.date);
jshero.koans.add({id:"var",title:"Variablen",lesson:"JavaScript-Programme bestehen aus einer Reihe von Anweisungen. Jede Anweisung f\xFChrt eine elementare Operation durch. "+"Durch das Ausf\xFChren vieler Anweisungen kann man schlie\xDFlich komplexe Aufgaben l\xF6sen. "+"Jede Anweisung schreibt man in eine Zeile und schlie\xDFt sie mit einem Semikolon ab.<br><br>"+"Eine elementare Anweisung ist die Deklaration und Initialisierung einer Variablen. "+"In der Programmierung ist eine Variable ein Beh\xE4lter f\xFCr einen Wert. "+"Mit der Anweisung "+"<pre><code>var stadt = \"Prag\";</code></pre>"+"deklariert man eine Variable mit dem Namen <code>stadt</code> und initialisiert sie mit dem Wert <code>\"Prag\"</code>. "+"Mit dem Schl\xFCsselwort <code>var</code> wird die Variable deklariert. "+"Mit dem Gleichheitszeichen, dem Zuweisungsoperator, weist man der Variablen einen Wert zu.<br><br>"+"Beachte: JavaScript unterscheidet zwischen Gro\xDF- und Kleinschreibung. <code>stadt</code> und <code>Stadt</code> sind "+"zwei verschiedene Variablen. Man sagt auch: JavaScript ist case sensitive.",task:"Deklariere eine Variable <code>vorname</code> und initialisiere sie mit dem Wert <code>\"Franz\"</code>.",beforeTests:function(){if(typeof vorname!=="undefined"){vorname=undefined}},tests:[function(){return jshero.testutil.assert_variableDefined(vorname,"vorname")},function(){return jshero.testutil.assert_variableHasValue(vorname,"vorname","Franz")}]});
jshero.koans.add({id:"var2",title:"Mehrere Variablen",lesson:"M\xF6chte man mehrere Variablen deklarieren und initialisieren, so kann man das in zwei Programmzeilen tun:"+"<pre><code>var stadt = \"Prag\";<br>var land = \"Tschechien\";</code></pre>"+"In jeder Zeile steht eine Anweisung. Jede Anweisung sollte mit einem Semikolon abgeschlossen werden.",task:"Deklariere eine Variable <code>blume</code> und weise ihr den Wert <code>\"Rose\"</code> zu. "+"Deklariere eine zweite Variable <code>tier</code> und weise ihr den Wert <code>\"K\xE4fer\"</code> zu.",beforeTests:function(){if(typeof blume!=="undefined"){blume=undefined}if(typeof tier!=="undefined"){tier=undefined}},tests:[function(){return jshero.testutil.assert_variableDefined(blume,"blume")},function(){return jshero.testutil.assert_variableHasValue(blume,"blume","Rose")},function(){return jshero.testutil.assert_variableDefined(tier,"tier")},function(){return jshero.testutil.assert_variableHasValue(tier,"tier","K\xE4fer")}]});
jshero.koans.add({id:'while',title:'while-Schleife',lesson:'Die <code>while</code>-Schleife besitzt nur eine Schleifen-Bedingung.\nDer Schleifen-Code wird ausgef\xFChrt, solange die Bedingung <code>true</code> ergibt.\nErgibt die Bedingung <code>false</code>, wird die Schleife beendet und die Codeausf\xFChrung\nwird nach der Schleife fortgesetzt.\n\n<pre><code>var dreiX = "";\nwhile (dreiX.length < 3) {\n  dreiX = dreiX + "x";\n}</code></pre>\n\nSolange <code>dreiX</code> weniger als 3 Zeichen besitzt, wird es um <code>"x"</code> erg\xE4nzt.\nHat <code>dreiX</code> die L\xE4nge 3, wird die Schleife beendet.\n<code>dreiX</code> hat dann den Wert <code>"xxx"</code>.',task:'Schreibe eine Funktion <code>abstand</code>, die eine nat\xFCrliche Zahl n als Parameter\nentgegennimmt und die einen String bestehend aus n Leerzeichen zur\xFCckgibt.\n<code>abstand(1)</code> sollte <code>" "</code> ergeben.',beforeTests:function(){if(typeof abstand!=='undefined'){abstand=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('abstand')},function(){return jshero.testutil.assert_functionHasNumOfParameter('abstand',1)},function(){return jshero.testutil.assert_functionReturns('abstand(0)','')},function(){return jshero.testutil.assert_functionReturns('abstand(2)','  ')},function(){return jshero.testutil.assert_functionReturns('abstand(5)','     ')}]});
jshero.koans.add({id:"xor",title:"XOR",lesson:"In der letzten Aufgabe hast du ein sogenanntes NAND-Gatter (engl.: Not AND - nicht und) programmiert. "+"NAND-Gatter sind in der Digitaltechnik ein sogenannter Standardbaustein. Mit ihm lassen sich alle logischen Verkn\xFCpfungen zusammenstellen. "+"Hier sollst du ein weiteres wichtiges Gatter, das XOR-Gatter (engl.: eXclusive OR - exklusives Oder), kennen lernen.",task:"Schreibe eine Funktion <code>xor</code>, die zwei boolesche Werte als Parameter entgegennimmt. Die R\xFCckgabe der Funktion soll <code>true</code> sein, "+"wenn beide Paramter verschieden sind. In den anderen F\xE4llen soll die R\xFCckgabe <code>false</code> sein. <code>xor(true, false)</code> und "+"<code>xor(false, true)</code> sollen <code>true</code> liefern, <code>xor(true, true)</code> und <code>xor(false, false)</code> sollen <code>false</code> zur\xFCckgeben.",beforeTests:function(){if(typeof xor!=="undefined"){xor=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("xor")},function(){return jshero.testutil.assert_functionHasNumOfParameter("xor",2)},function(){return jshero.testutil.assert_functionReturns("xor(true, true)",false)},function(){return jshero.testutil.assert_functionReturns("xor(true, false)",true)},function(){return jshero.testutil.assert_functionReturns("xor(false, true)",true)},function(){return jshero.testutil.assert_functionReturns("xor(false, false)",false)}]});
/* This puts the koans in the desired order */jshero.koans.initReorder(['var','var2','function','function2','functioncall','parameter','parameter2','string','log','stringlength','stringupper','stringcharat','trim','stringindexof','stringindexof2','stringsubstr','replace','number','modulo','mean','math','minmax','pi','round','random','parseint','numbertostring','bool','xor','equals','equals2','even','notequals','greaterthan','if','else','elseif','array','array2','array3','arraylength','arraysort','arraypush','for','for2','while','dowhile','ggt','break','bubblesort','arguments','comment','undefined','nan','stringsplit','date','date2','date3','subfunction','further']);

jshero.koans.add({id:"var",title:"Variablen",lesson:'JavaScript-Programme bestehen aus einer Reihe von Anweisungen. Jede Anweisung f\u00fchrt eine elementare Operation durch. Durch das Ausf\u00fchren vieler Anweisungen kann man schlie\u00dflich komplexe Aufgaben l\u00f6sen. Jede Anweisung schreibt man in eine Zeile und schlie\u00dft sie mit einem Semikolon ab.\x3cbr\x3e\x3cbr\x3eEine elementare Anweisung ist die Deklaration und Initialisierung einer Variablen. In der Programmierung ist eine Variable ein Beh\u00e4lter f\u00fcr einen Wert. Mit der Anweisung \x3cpre\x3e\x3ccode\x3evar stadt \x3d "Prag";\x3c/code\x3e\x3c/pre\x3edeklariert man eine Variable mit dem Namen \x3ccode\x3estadt\x3c/code\x3e und initialisiert sie mit dem Wert \x3ccode\x3e"Prag"\x3c/code\x3e. Mit dem Schl\u00fcsselwort \x3ccode\x3evar\x3c/code\x3e wird die Variable deklariert. Mit dem Gleichheitszeichen, dem Zuweisungsoperator, weist man der Variablen einen Wert zu.\x3cbr\x3e\x3cbr\x3eBeachte: JavaScript unterscheidet zwischen Gro\u00df- und Kleinschreibung. \x3ccode\x3estadt\x3c/code\x3e und \x3ccode\x3eStadt\x3c/code\x3e sind zwei verschiedene Variablen. Man sagt auch: JavaScript ist case sensitive.',
task:'Deklariere eine Variable \x3ccode\x3evorname\x3c/code\x3e und initialisiere sie mit dem Wert \x3ccode\x3e"Franz"\x3c/code\x3e.',beforeTests:function(){"undefined"!==typeof vorname&&(vorname=void 0)},tests:[function(){var a="undefined"!==typeof vorname;return{ok:a,msg:a?"\x3ccode\x3evorname\x3c/code\x3e hat einen Wert.":"\x3ccode\x3evorname\x3c/code\x3e hat keinen Wert."}},function(){var a="Franz"===vorname,b;b=a?'\x3ccode\x3evorname\x3c/code\x3e hat den Wert "Franz".':'\x3ccode\x3evorname\x3c/code\x3e hat nicht den Wert \x3ccode\x3e"Franz"\x3c/code\x3e, sondern den Wert \x3ccode\x3e'+
JSON.stringify(vorname)+"\x3c/code\x3e.";return{ok:a,msg:b}}]});
jshero.koans.add({id:"var2",title:"Mehrere Variablen",lesson:'M\u00f6chte man mehrere Variablen deklarieren und initialisieren, so kann man das in zwei Programmzeilen tun:\x3cpre\x3e\x3ccode\x3evar stadt \x3d "Prag";\x3cbr\x3evar land \x3d "Tschechien";\x3c/code\x3e\x3c/pre\x3eIn jeder Zeile steht eine Anweisung. Jede Anweisung sollte mit einem Semikolon abgeschlossen werden.',task:'Deklariere eine Variable \x3ccode\x3eblume\x3c/code\x3e und weise ihr den Wert \x3ccode\x3e"Rose"\x3c/code\x3e zu. Deklariere eine zweite Variable \x3ccode\x3etier\x3c/code\x3e und weise ihr den Wert \x3ccode\x3e"K\u00e4fer"\x3c/code\x3e zu.',beforeTests:function(){"undefined"!==
typeof blume&&(blume=void 0);"undefined"!==typeof tier&&(tier=void 0)},tests:[function(){var a="undefined"!==typeof blume;return{ok:a,msg:a?"\x3ccode\x3eblume\x3c/code\x3e hat einen Wert.":"\x3ccode\x3eblume\x3c/code\x3e hat keinen Wert."}},function(){var a="Rose"===blume,b;b=a?'\x3ccode\x3eblume\x3c/code\x3e hat den Wert \x3ccode\x3e"Rose"\x3c/code\x3e.':'\x3ccode\x3eblume\x3c/code\x3e hat nicht den Wert \x3ccode\x3e"Rose"\x3c/code\x3e, sondern den Wert \x3ccode\x3e'+JSON.stringify(blume)+"\x3c/code\x3e.";
return{ok:a,msg:b}},function(){var a="undefined"!==typeof tier;return{ok:a,msg:a?"\x3ccode\x3etier\x3c/code\x3e hat einen Wert.":"\x3ccode\x3etier\x3c/code\x3e hat keinen Wert."}},function(){var a="K\u00e4fer"===tier,b;b=a?'\x3ccode\x3etier\x3c/code\x3e hat den Wert \x3ccode\x3e"K\u00e4fer"\x3c/code\x3e.':'\x3ccode\x3etier\x3c/code\x3e hat nicht den Wert \x3ccode\x3e"K\u00e4fer"\x3c/code\x3e, sondern den Wert \x3ccode\x3e'+JSON.stringify(tier)+"\x3c/code\x3e.";return{ok:a,msg:b}}]});
jshero.koans.add({id:"function",title:"Funktionen",lesson:'Eine Funktion ist ein Block von Anweisungen, der beliebig oft ausgef\u00fchrt werden kann. Eine Funktion kann Parameter entgegennehmen und eine Funktion kann einen Wert zur\u00fcckgeben. Funktionen werden mit dem Schl\u00fcsselwort \x3ccode\x3efunction\x3c/code\x3e definiert. Darauf folgen in runden Klammern eingeschlossen die Parameter und anschlie\u00dfend, eingeschlossen in geschweiften Klammern, die Anweisungen. Mit dem Schl\u00fcsselwort \x3ccode\x3ereturn\x3c/code\x3e kann ein Wert zur\u00fcckgegeben werden. Gleichzeitig beendet \x3ccode\x3ereturn\x3c/code\x3e die Funktion. Anweisungen nach einem \x3ccode\x3ereturn\x3c/code\x3e werden nicht mehr ausgef\u00fchrt. Funktionen kann man Variablen zuordnen. Die Funktion tr\u00e4gt dann den Namen der Variablen. Mit \x3cpre\x3e\x3ccode\x3evar farbe \x3d function() {\x3cbr\x3e  return "gr\u00fcn";\x3cbr\x3e};\x3c/code\x3e\x3c/pre\x3e definieren wir eine Funktion \x3ccode\x3efarbe\x3c/code\x3e, die \x3ccode\x3e"gr\u00fcn"\x3c/code\x3e zur\u00fcckgibt. Die Funktion nimmt keine Paramter entgegen (die runde Klammer ist leer) und sie enth\u00e4lt genau eine Anweisung, die R\u00fcckgabe.\x3cbr\x3e Der Aufruf einer Funktion geschieht \u00fcber ihren Namen. Mit \x3cpre\x3e\x3ccode\x3evar ergebnis \x3d farbe();\x3c/code\x3e\x3c/pre\x3ewird die Funktion \x3ccode\x3efarbe\x3c/code\x3e ausgef\u00fchrt und ihre R\u00fcckgabe der Variablen \x3ccode\x3eergebnis\x3c/code\x3e zugewiesen. \x3ccode\x3eergebnis\x3c/code\x3e hat dann den Wert \x3ccode\x3e"gr\u00fcn"\x3c/code\x3e.',
task:'Schreibe eine Funktion \x3ccode\x3ehallo\x3c/code\x3e, die \x3ccode\x3e"Hallo Welt!"\x3c/code\x3e zur\u00fcckgibt.',beforeTests:function(){"undefined"!==typeof hallo&&(hallo=void 0)},tests:[function(){var a="function"===typeof hallo;return{ok:a,msg:a?"\x3ccode\x3ehallo\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3ehallo\x3c/code\x3e ist keine Funktion."}},function(){var a,b,d;try{var c=hallo();b=(a="Hallo Welt!"===c)?'\x3ccode\x3ehallo()\x3c/code\x3e gibt \x3ccode\x3e"Hallo Welt!"\x3c/code\x3e zur\u00fcck.':
'\x3ccode\x3ehallo()\x3c/code\x3e gibt nicht \x3ccode\x3e"Hallo Welt!"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3ehallo()\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"parameter",title:"Parameter",lesson:'Jetzt lernen wir Funktionen mit Parametern kennen. Mit \x3cpre\x3e\x3ccode\x3evar gebe \x3d function(eingabe) {\x3cbr\x3e  return eingabe;\x3cbr\x3e};\x3c/code\x3e\x3c/pre\x3edefinieren wir eine Funktion, die den \u00fcbergebenen Parameter \x3ccode\x3eeingabe\x3c/code\x3e einfach wieder zur\u00fcckgibt. Parameter sind Variablen. Sie stehen in der runden Klammer und ben\u00f6tigen nicht das Schl\u00fcsselwort \x3ccode\x3evar\x3c/code\x3e zu ihrer Deklaration. Mit \x3cpre\x3e\x3ccode\x3evar ergebnis \x3d gebe("Apfel");\x3c/code\x3e\x3c/pre\x3erufen wir die Funktion \x3ccode\x3egebe\x3c/code\x3e mit der Wert \x3ccode\x3e"Apfel"\x3c/code\x3e auf. Jetzt wird unsere zuvor definierte Funktion \x3ccode\x3egebe\x3c/code\x3e ausgef\u00fchrt. Dabei wird zun\u00e4chst der Wert \x3ccode\x3e"Apfel"\x3c/code\x3e dem Parameter \x3ccode\x3eeingabe\x3c/code\x3e zugewiesen. \x3ccode\x3eeingabe\x3c/code\x3e hat jetzt den Wert \x3ccode\x3e"Apfel"\x3c/code\x3e. In der einzigen Codezeile der Funktion \x3ccode\x3egebe\x3c/code\x3e wird nun die Variable \x3ccode\x3eeingabe\x3c/code\x3e mit der \x3ccode\x3ereturn\x3c/code\x3e-Anweisung zur\u00fcckgegeben. Diese R\u00fcckgabe wird der Variablen \x3ccode\x3eergebnis\x3c/code\x3e zugewiesen. \x3ccode\x3eergebnis\x3c/code\x3e hat dann auch den Wert \x3ccode\x3e"Apfel"\x3c/code\x3e.',task:"Schreibe eine Funktion \x3ccode\x3eecho\x3c/code\x3e, die ebenfalls den \u00fcbergebenen Parameter wieder zur\u00fcckgibt.",
beforeTests:function(){"undefined"!==typeof echo&&(echo=void 0)},tests:[function(){var a="function"===typeof echo;return{ok:a,msg:a?"\x3ccode\x3eecho\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eecho\x3c/code\x3e ist keine Funktion."}},function(){var a=echo.length,b=1===a;return{ok:b,msg:b?"\x3ccode\x3eecho\x3c/code\x3e hat genau 1 Parameter.":"\x3ccode\x3eecho\x3c/code\x3e hat nicht 1, sondern "+a+" Parameter."}},function(){var a,b,d;try{var c=echo("Hallo Welt!");b=(a="Hallo Welt!"===c)?'\x3ccode\x3eecho("Hallo Welt!")\x3c/code\x3e gibt \x3ccode\x3e"Hallo Welt!"\x3c/code\x3e zur\u00fcck.':
'\x3ccode\x3eecho("Hallo Welt!")\x3c/code\x3e gibt nicht \x3ccode\x3e"Hallo Welt!"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3eecho("Hallo Welt!")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=echo("Franz");b=(a="Franz"===c)?'\x3ccode\x3eecho("Franz")\x3c/code\x3e gibt \x3ccode\x3e"Franz"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3eecho("Franz")\x3c/code\x3e gibt nicht \x3ccode\x3e"Franz"\x3c/code\x3e, sondern \x3ccode\x3e'+
JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3eecho("Franz")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"string",title:"Strings",lesson:'Wir haben gesehen, dass eine Variable ein Beh\u00e4lter f\u00fcr einen Wert ist. Werte besitzen dabei einen Typ. So kann ein Wert eine Zahl wie \x3ccode\x3e7.12\x3c/code\x3e sein. Der Typ von \x3ccode\x3e7.12\x3c/code\x3e ist Zahl. Oder ein Wert kann ein Text wie \x3ccode\x3e"Hallo Welt!"\x3c/code\x3e sein. Der Typ von \x3ccode\x3e"Hallo Welt!"\x3c/code\x3e ist Text. Diesen Typ bezeichnet man auch als Zeichenkette oder String. Strings schreibt man immer in einfachen oder doppelten Anf\u00fchrungszeichen. So ist "Hallo Welt!" derselbe String wie \'Hallo Welt!\'.\x3cbr\x3eMit Strings kann man arbeiten. Man kann sie zum Beispiel verketten. Dies macht man mit dem \x3ccode\x3e+\x3c/code\x3e Zeichen. So liefert \x3ccode\x3e"Java" + "Script"\x3c/code\x3e den String \x3ccode\x3e"JavaScript"\x3c/code\x3e.\x3cbr\x3eDie folgende Funktion h\u00e4ngt an dem \u00fcbergebenen Parameter einen Text an und gibt den zusammengesetzten Text zur\u00fcck: \x3cpre\x3e\x3ccode\x3evar lobe \x3d function(name) {\x3cbr\x3e  return name + " ist toll!";\x3cbr\x3e};\x3c/code\x3e\x3c/pre\x3eSo liefert \x3ccode\x3elobe("JavaScript")\x3c/code\x3e den Wert \x3ccode\x3e"JavaScript ist toll!"\x3c/code\x3e.',task:'Schreibe eine Funktion \x3ccode\x3ebegruesse\x3c/code\x3e, die einen Parameter entgegennimmt und die \x3ccode\x3e"Hallo \x26lt;Parameter\x26gt;!"\x3c/code\x3e zur\u00fcckgibt. \u00dcbergibt man der Funktion \x3ccode\x3e"Maria"\x3c/code\x3e, so sollte die Funktion \x3ccode\x3e"Hallo Maria!"\x3c/code\x3e zur\u00fcckgeben. \u00dcbergibt man der Funktion \x3ccode\x3e"Franz"\x3c/code\x3e, so sollte die R\u00fcckgabe \x3ccode\x3e"Hallo Franz!"\x3c/code\x3e sein.',
beforeTests:function(){"undefined"!==typeof begruesse&&(begruesse=void 0)},tests:[function(){var a="function"===typeof begruesse;return{msg:a?"\x3ccode\x3ebegruesse\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3ebegruesse\x3c/code\x3e ist keine Funktion.",ok:a}},function(){var a=1===begruesse.length;return{ok:a,msg:a?"\x3ccode\x3ebegruesse\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3ebegruesse\x3c/code\x3e hat nicht 1, sondern "+begruesse.length+" Parameter."}},function(){var a,b,d;try{var c=begruesse("Maria");
"Hallo Maria!"===c?(a=!0,b='\x3ccode\x3ebegruesse("Maria")\x3c/code\x3e gibt \x3ccode\x3e"Hallo Maria!"\x3c/code\x3e zur\u00fcck.'):(a=!1,b='\x3ccode\x3ebegruesse("Maria")\x3c/code\x3e gibt nicht \x3ccode\x3e"Hallo Maria!"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck.")}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3ehallo("Maria")\x3c/code\x3e.',d=e}return{msg:b,ok:a,e:d}},function(){var a,b,d;try{var c=begruesse("Franz");"Hallo Franz!"===c?(a=!0,b='\x3ccode\x3ebegruesse("Franz")\x3c/code\x3e gibt \x3ccode\x3e"Hallo Franz!"\x3c/code\x3e zur\u00fcck.'):
(a=!1,b='\x3ccode\x3ebegruesse("Franz")\x3c/code\x3e gibt nicht \x3ccode\x3e"Hallo Franz!"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck.")}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3ehallo("Franz")\x3c/code\x3e.',d=e}return{msg:b,ok:a,e:d}}]});
jshero.koans.add({id:"log",title:"Loggen",lesson:'Wenn man Programme schreibt, laufen die Dinge manchmal nicht so wie man will. Es kommt einfach nicht das gew\u00fcnschte Ergebnis heraus und man wei\u00df nicht warum. Eine M\u00f6glichkeit hier weiter zu kommen ist das Loggen. Man l\u00e4\u00dft sich den Wert von Variablen w\u00e4hrend der Programmausf\u00fchrung ausgeben. In JavaScript macht man das mit der Funktion \x3ccode\x3econsole.log\x3c/code\x3e.\x3cpre\x3e\x3ccode\x3evar mitteilung \x3d "Hallo";\x3cbr\x3econsole.log(mitteilung);\x3cbr\x3emitteilung \x3d mitteilung + " Franz!";\x3cbr\x3econsole.log(mitteilung);\x3cbr\x3e\x3c/code\x3e\x3c/pre\x3eWir geben den Wert von \x3ccode\x3emitteilung\x3c/code\x3e zweimal mit \x3ccode\x3econsole.log\x3c/code\x3e aus. Beim ersten Log wird der initiale Werte von \x3ccode\x3emitteilung\x3c/code\x3e ausgegeben. Beim zweiten Log sehen wir, welchen Wert \x3ccode\x3emitteilung\x3c/code\x3e nach der \u00c4nderung hat. So k\u00f6nnen wir feststellen, welchen Wert Variablen an bestimmen Stellen des Programmsablaufs besitzen und wie sich dieser Wert im Ablauf \u00e4ndert. In unserem Beispiel erhalten wir nacheinander die Ausgaben \x3ccode\x3e"Hallo"\x3c/code\x3e und \x3ccode\x3e"Hallo Franz!"\x3c/code\x3e.\x3cbr\x3e\x3cbr\x3eWo man das Log zu sehen bekommt, h\u00e4ngt von der JavaScript-Umgebung ab. Node.js wird in einer klassischen Konsole gestartet. Dort wird auch das Log ausgegeben. In Browsern sieht man die Log-Ausgabe im normalen Betrieb nicht. Doch jeder Browser besitzt sogenannte Entwickler-Werkzeuge. Das sind m\u00e4chtige Tools zur Unterst\u00fctzung von Webentwicklern. Eines dieser Tools ist die Konsole. Dort wird das Log ausgegeben. Wie man die Entwickler-Werkzeuge \u00f6ffnet h\u00e4ngt vom jeweiligen Browser ab. Bei vielen Browsern (z.B. Firefox) wird sie mit der Taste F12 ge\u00f6ffnet. Die Konsole kannst du dann als Reiter ausw\u00e4hlen. Benutzt du JavaScript Hero im Browser, dann kannst du das sofort ausprobieren. \u00d6ffne die Entwickler-Konsole (im Firefox mit F12), schreibe unten in das L\u00f6sungsfeld \x3ccode\x3econsole.log("Hallo Konsole!")\x3c/code\x3e und f\u00fchre die Tests aus. In der Entwickler-Konsole erscheint "Hallo Konsole!".\x3cbr\x3e\x3cbr\x3eDa es sinnvoll ist, das Log direkt in der Testausgabe zu sehen, besitzt JavaScript Hero eine eigene Log-Funktion: \x3ccode\x3ejshero.log\x3c/code\x3e. Diese Funktion loggt so wie oben \x3ccode\x3econsole.log\x3c/code\x3e. Die Ausgabe wird allerdings nicht in die Entwickler-Konsole, sondern in die Testausgabe geschrieben. So sieht man genau, was bei welchem Testaufruf geloggt wird. \x3ccode\x3ejshero.log\x3c/code\x3e kannst du in jeder Lektion verwenden! Der Vollst\u00e4ndigkeit halber seien zwei Unterschiede zwischen dem Loggen mit \x3ccode\x3econsole.log\x3c/code\x3e und \x3ccode\x3ejshero.log\x3c/code\x3e genannt: (i)\x26nbsp;\x3ccode\x3econsole.log\x3c/code\x3e kann mehrere Paramter gleichzeitig loggen und es loggt Objekte (diese werden wir sp\u00e4ter kennen lernen) in ihrer Objekt-Notation. (ii)\x26nbsp;\x3ccode\x3ejshero.log\x3c/code\x3e loggt nicht beim Einlesen deines L\u00f6sungs-Codes. Es ist nur beim Aufruf deiner L\u00f6sungsfunktion aktiv. Dadurch werden Log-Aufrufe au\u00dferhalb deiner L\u00f6sungsfunktion mit \x3ccode\x3ejshero.log\x3c/code\x3e nicht geloggt, w\u00e4hrend sie mit \x3ccode\x3econsole.log\x3c/code\x3e geloggt werden.',task:'Schreibe eine Funktion \x3ccode\x3erufe\x3c/code\x3e, die einen String als Parameter entgegennimmt und diesen String verdoppelt zur\u00fcckgibt. Gleichzeitig soll der Eingangsparameter und die R\u00fcckgabe mit \x3ccode\x3ejshero.log\x3c/code\x3e geloggt werden. Der Aufruf \x3ccode\x3erufe("Werder")\x3c/code\x3e sollte \x3ccode\x3e"WerderWerder"\x3c/code\x3e zur\u00fcckgeben und es sollte nacheinander \x3ccode\x3e"Werder"\x3c/code\x3e und \x3ccode\x3e"WerderWerder"\x3c/code\x3e geloggt werden.',
beforeTests:function(){"undefined"!==typeof rufe&&(rufe=void 0)},tests:[function(){var a="function"===typeof rufe;return{msg:a?"\x3ccode\x3erufe\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3erufe\x3c/code\x3e ist keine Funktion.",ok:a}},function(){var a=1===rufe.length;return{ok:a,msg:a?"\x3ccode\x3erufe\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3erufe\x3c/code\x3e hat nicht 1, sondern "+rufe.length+" Parameter."}},function(){var a,b,d;try{var c=rufe("Werder");"WerderWerder"===c?(a=!0,b='\x3ccode\x3erufe("Werder")\x3c/code\x3e gibt \x3ccode\x3e"WerderWerder"\x3c/code\x3e zur\u00fcck.'):
(a=!1,b='\x3ccode\x3erufe("Werder")\x3c/code\x3e gibt nicht \x3ccode\x3e"WerderWerder"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck.")}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3erufe("Werder")\x3c/code\x3e.',d=e}return{msg:b,ok:a,e:d}},function(){var a,b,d;try{rufe("Werder");var c=jshero.getLogs().length;2===c?(a=!0,b='\x3ccode\x3erufe("Werder")\x3c/code\x3e loggt mit \x3ccode\x3ejshero.log\x3c/code\x3e genau 2 mal.'):(a=!1,b='\x3ccode\x3erufe("Werder")\x3c/code\x3e loggt mit \x3ccode\x3ejshero.log\x3c/code\x3e nicht 2 mal, sondern '+
c+" mal.")}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3erufe("Werder")\x3c/code\x3e.',d=e}return{msg:b,ok:a,e:d}},function(){var a,b,d;try{rufe("Werder");var c=jshero.getLogs()[0];"Werder"===c?(a=!0,b='\x3ccode\x3erufe("Werder")\x3c/code\x3e loggt als erstes die \u00dcbergabe \x3ccode\x3e"Werder"\x3c/code\x3e.'):(a=!1,b='\x3ccode\x3erufe("Werder")\x3c/code\x3e loggt als erstes nicht die \u00dcbergabe \x3ccode\x3e"Werder"\x3c/code\x3e, sondern es wird \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e geloggt.")}catch(e){a=
!1,b='Fehler beim Aufruf von \x3ccode\x3erufe("Werder")\x3c/code\x3e.',d=e}return{msg:b,ok:a,e:d}},function(){var a,b,d;try{rufe("Werder");var c=jshero.getLogs()[1];"WerderWerder"===c?(a=!0,b='\x3ccode\x3erufe("Werder")\x3c/code\x3e loggt als zweites die R\u00fcckgabe \x3ccode\x3e"WerderWerder"\x3c/code\x3e.'):(a=!1,b='\x3ccode\x3erufe("Werder")\x3c/code\x3e loggt als zweites nicht die R\u00fcckgabe \x3ccode\x3e"WerderWerder"\x3c/code\x3e, sondern es wird \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e geloggt.")}catch(e){a=
!1,b='Fehler beim Aufruf von \x3ccode\x3erufe("Werder")\x3c/code\x3e.',d=e}return{msg:b,ok:a,e:d}},function(){var a,b,d;try{var c=rufe("Kickers");"KickersKickers"===c?(a=!0,b='\x3ccode\x3erufe("Kickers")\x3c/code\x3e gibt \x3ccode\x3e"KickersKickers"\x3c/code\x3e zur\u00fcck.'):(a=!1,b='\x3ccode\x3erufe("Kickers")\x3c/code\x3e gibt nicht \x3ccode\x3e"KickersKickers"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck.")}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3erufe("Kickers")\x3c/code\x3e.',
d=e}return{msg:b,ok:a,e:d}},function(){var a,b,d;try{rufe("Kickers");var c=jshero.getLogs()[0];"Kickers"===c?(a=!0,b='\x3ccode\x3erufe("Kickers")\x3c/code\x3e loggt als erstes die \u00dcbergabe \x3ccode\x3e"Kickers"\x3c/code\x3e.'):(a=!1,b='\x3ccode\x3erufe("Kickers")\x3c/code\x3e loggt als erstes nicht die \u00dcbergabe \x3ccode\x3e"Kickers"\x3c/code\x3e, sondern es wird \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e geloggt.")}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3erufe("Kickers")\x3c/code\x3e.',
d=e}return{msg:b,ok:a,e:d}},function(){var a,b,d;try{rufe("Kickers");var c=jshero.getLogs()[1];"KickersKickers"===c?(a=!0,b='\x3ccode\x3erufe("Kickers")\x3c/code\x3e loggt als zweites die R\u00fcckgabe \x3ccode\x3e"KickersKickers"\x3c/code\x3e.'):(a=!1,b='\x3ccode\x3erufe("Kickers")\x3c/code\x3e loggt als zweites nicht die R\u00fcckgabe \x3ccode\x3e"KickersKickers"\x3c/code\x3e, sondern es wird \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e geloggt.")}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3erufe("Werder")\x3c/code\x3e.',
d=e}return{msg:b,ok:a,e:d}}]});
jshero.koans.add({id:"stringlength",title:"String: length",lesson:'Strings besitzen die Eigenschaft \x3ccode\x3elength\x3c/code\x3e. Diese Eigenschaft liefert die Anzahl der Zeichen eines Strings. Dazu muss man dem String  oder der Variablen, die den String enth\u00e4lt, \x3ccode\x3e.length\x3c/code\x3e anh\u00e4ngen:\x3cpre\x3e\x3ccode\x3evar anzahl \x3d "Franz".length;\x3c/code/\x3e\x3c/pre\x3e\x3ccode\x3e"Franz"\x3c/code\x3e hat 5 Zeichen. Also hat \x3ccode\x3eanzahl\x3c/code\x3e jetzt den Wert \x3ccode\x3e5\x3c/code\x3e.\x3cpre\x3e\x3ccode\x3evar stadt \x3d "Prag";\x3cbr\x3eanzahl \x3d stadt.length;\x3c/code/\x3e\x3c/pre\x3e\x3ccode\x3e"Prag"\x3c/code\x3e hat 4 Zeichen. \x3ccode\x3eanzahl\x3c/code\x3e hat jetzt den Wert \x3ccode\x3e4\x3c/code\x3e.\x3cpre\x3e\x3ccode\x3eanzahl \x3d "".length;\x3c/code/\x3e\x3c/pre\x3eDer Leerstring besitzt keine Zeichen. Der Wert von \x3ccode\x3eanzahl\x3c/code\x3e ist jetzt \x3ccode\x3e0\x3c/code\x3e.',task:'Schreibe eine Funktion \x3ccode\x3elaenge\x3c/code\x3e, die bei \u00dcbergabe eines Strings die Anzahl der Zeichen dieses Strings zur\u00fcckgibt. \x3ccode\x3elaenge("Franz")\x3c/code\x3e sollte \x3ccode\x3e5\x3c/code\x3e zur\u00fcckgeben.',
beforeTests:function(){"undefined"!==typeof laenge&&(laenge=void 0)},tests:[function(){var a="function"===typeof laenge;return{ok:a,msg:a?"\x3ccode\x3elaenge\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3elaenge\x3c/code\x3e ist keine Funktion."}},function(){var a=laenge.length,b=1===a;return{ok:b,msg:b?"\x3ccode\x3elaenge\x3c/code\x3e hat genau 1 Parameter.":"\x3ccode\x3elaenge\x3c/code\x3e hat nicht 1, sondern "+a+" Parameter."}},function(){var a,b,d;try{var c=laenge("Hallo Welt!");b=(a=11===c)?
'\x3ccode\x3elaenge("Hallo Welt!")\x3c/code\x3e gibt \x3ccode\x3e11\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3elaenge("Hallo Welt!")\x3c/code\x3e gibt nicht \x3ccode\x3e11\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3elaenge("Hallo Welt!")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=laenge("");b=(a=0===c)?'\x3ccode\x3elaenge("")\x3c/code\x3e gibt \x3ccode\x3e0\x3c/code\x3e zur\u00fcck.':
'\x3ccode\x3elaenge("")\x3c/code\x3e gibt nicht \x3ccode\x3e0\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3elaenge("")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"stringupper",title:"String: toUpperCase()",lesson:'Neben der Eigenschaft \x3ccode\x3elength\x3c/code\x3e besitzen Strings noch eine Reihe von Methoden. Das sind Funktionen, die direkt auf dem String angewendet werden. Wie die Eigenschaft \x3ccode\x3elength\x3c/code\x3e werden diese Methoden mit einem Punkt direkt dem String oder einer Variablen, die einen String enth\u00e4lt, angeh\u00e4ngt. Da Methoden Funktionen sind, folgen in runden Klammern eingeschlossen die Parameter. Zwei dieser String-Methoden sind die parameterlosen Methoden \x3ccode\x3etoUpperCase()\x3c/code\x3e und \x3ccode\x3etoLowerCase()\x3c/code\x3e. Sie geben den String, auf dem sie angewendet werden, in Gro\u00df- bzw. Kleinbuchstaben zur\u00fcck. Wichtig ist, dass der eigentliche String unver\u00e4ndert bleibt. Die R\u00fcckgabe dieser Methoden ist der in Gro\u00df- bzw. Kleinbuchstaben umgewandelte String.\x3cpre\x3e\x3ccode\x3evar stadt \x3d "Prag";\x3cbr\x3evar ausgabe \x3d stadt.toUpperCase();\x3c/code/\x3e\x3c/pre\x3e\x3ccode\x3eausgabe\x3c/code\x3e erh\u00e4lt den Wert \x3ccode\x3e"PRAG"\x3c/code\x3e. \x3ccode\x3estadt\x3c/code\x3e hat weiterhin den Wert \x3ccode\x3e"Prag"\x3c/code\x3e.\x3cpre\x3e\x3ccode\x3eausgabe \x3d stadt.toLowerCase();\x3c/code/\x3e\x3c/pre\x3eJetzt hat \x3ccode\x3eausgabe\x3c/code\x3e den Wert \x3ccode\x3e"prag"\x3c/code\x3e.\x3cpre\x3e\x3ccode\x3eausgabe \x3d "Flug 714".toUpperCase();\x3c/code/\x3e\x3c/pre\x3eHier wird \x3ccode\x3etoUpperCase()\x3c/code\x3e direkt auf einen String angewendet. Der Wert von \x3ccode\x3eausgabe\x3c/code\x3e ist \x3ccode\x3e"FLUG 714"\x3c/code\x3e. Zahlen und auch Sonderzeichen werden nicht ver\u00e4ndert.',task:'Schreibe eine Funktion \x3ccode\x3etoCase\x3c/code\x3e, die bei \u00dcbergabe eines Strings diesen aneinandergeh\u00e4ngt in Klein- und in Gro\u00dfschreibung zur\u00fcckgibt. Das Trennzeichen zwischen der Klein- und Gro\u00dfschreibung soll \x3ccode\x3e-\x3c/code\x3e sein. \x3ccode\x3etoCase("Code")\x3c/code\x3e sollte \x3ccode\x3e"code-CODE"\x3c/code\x3e zur\u00fcckgeben.',
beforeTests:function(){"undefined"!==typeof toCase&&(toCase=void 0)},tests:[function(){var a="function"===typeof toCase;return{ok:a,msg:a?"\x3ccode\x3etoCase\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3etoCase\x3c/code\x3e ist keine Funktion."}},function(){var a=toCase.length,b=1===a;return{ok:b,msg:b?"\x3ccode\x3etoCase\x3c/code\x3e hat genau 1 Parameter.":"\x3ccode\x3etoCase\x3c/code\x3e hat nicht 1, sondern "+a+" Parameter."}},function(){var a,b,d;try{var c=toCase("Code");b=(a="code-CODE"===c)?
'\x3ccode\x3etoCase("Code")\x3c/code\x3e gibt \x3ccode\x3e"code-CODE"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3etoCase("Code")\x3c/code\x3e gibt nicht \x3ccode\x3e"code-CODE"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3etoCase("Code")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=toCase("Maria");b=(a="maria-MARIA"===c)?'\x3ccode\x3etoCase("Maria")\x3c/code\x3e gibt \x3ccode\x3e"maria-MARIA"\x3c/code\x3e zur\u00fcck.':
'\x3ccode\x3etoCase("Maria")\x3c/code\x3e gibt nicht \x3ccode\x3e"maria-MARIA"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3etoCase("Maria")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"stringcharat",title:"String: charAt()",lesson:'Um aus einem String das Zeichen an einer bestimmten Stelle zu bestimmen, verwendet man die Methode \x3ccode\x3echarAt(index)\x3c/code\x3e. Der Paramter \x3ccode\x3eindex\x3c/code\x3e gibt die Stelle des Zeichens innerhalb der Zeichenkette an. Dabei hat das erste Zeichen einer Zeichenkette den Index 0:\x3cpre\x3e\x3ccode\x3evar n1 \x3d "Maria".charAt(0);\x3cbr\x3evar n2 \x3d "Maria".charAt(1);\x3cbr\x3evar n3 \x3d "Maria".charAt(5);\x3cbr\x3evar n4 \x3d "Maria".charAt();\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3en1\x3c/code\x3e hat den Wert \x3ccode\x3e"M"\x3c/code\x3e und \x3ccode\x3en2\x3c/code\x3e hat den Wert \x3ccode\x3e"a"\x3c/code\x3e. Ist der Index gr\u00f6\u00dfer als der Index des letzten Zeichens, wird der leere String zur\u00fcckgegeben. \x3ccode\x3en3\x3c/code\x3e hat also den Wert \x3ccode\x3e""\x3c/code\x3e. Wird kein Parameter \u00fcbergeben, so wird das Zeichen mit dem Index \x3ccode\x3e0\x3c/code\x3e zur\u00fcckgegeben. Man sagt: der Default-Wert f\u00fcr \x3ccode\x3eindex\x3c/code\x3e ist \x3ccode\x3e0\x3c/code\x3e. Der Wert von \x3ccode\x3en4\x3c/code\x3e ist also auch \x3ccode\x3e"M"\x3c/code\x3e.',task:'Schreibe eine Funktion \x3ccode\x3eabkuerzung\x3c/code\x3e, die zwei Strings als Parameter entgegennimmt und als R\u00fcckgabe die Anfangsbuchstaben dieser Strings zur\u00fcckgibt. \x3ccode\x3eabkuerzung("Hansestadt", "Bremen")\x3c/code\x3e sollte \x3ccode\x3e"HB"\x3c/code\x3e zur\u00fcckliefern.',
beforeTests:function(){"undefined"!==typeof abkuerzung&&(abkuerzung=void 0)},tests:[function(){var a="function"===typeof abkuerzung;return{ok:a,msg:a?"\x3ccode\x3eabkuerzung\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eabkuerzung\x3c/code\x3e ist keine Funktion."}},function(){var a=2===abkuerzung.length;return{ok:a,msg:a?"\x3ccode\x3eabkuerzung\x3c/code\x3e hat zwei Parameter.":"\x3ccode\x3eabkuerzung\x3c/code\x3e hat nicht 2, sondern "+abkuerzung.length+" Parameter."}},function(){var a,b,d;try{var c=
abkuerzung("Hansestadt","Bremen");b=(a="HB"===c)?'\x3ccode\x3eabkuerzung("Hansestadt", "Bremen")\x3c/code\x3e gibt \x3ccode\x3e"HB"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3eabkuerzung("Hansestadt", "Bremen")\x3c/code\x3e gibt nicht \x3ccode\x3e"HB"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){d=e,a=!1,b='Fehler beim Aufruf von \x3ccode\x3eabkuerzung("Hansestadt", "Bremen")\x3c/code\x3e.'}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=abkuerzung("Java",
"Script");b=(a="JS"===c)?'\x3ccode\x3eabkuerzung("Java", "Script")\x3c/code\x3e gibt \x3ccode\x3e"JS"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3eabkuerzung("Java", "Script")\x3c/code\x3e gibt nicht \x3ccode\x3e"JS"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3eabkuerzung("Java", "Script")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"trim",title:"String: trim()",lesson:'Die Methode \x3ccode\x3etrim\x3c/code\x3e entfernt Leerzeichen an beiden Enden eines Strings. Der an den Enden um Leerzeichen bereinigte String wird zur\u00fcckgegeben. Der urspr\u00fcgliche String bleibt unver\u00e4ndert.\x3cpre\x3e\x3ccode\x3evar eingabe \x3d " Rosa Parks ";\x3cbr\x3evar name \x3d eingabe.trim();\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3ename\x3c/code\x3e enth\u00e4lt den String \x3ccode\x3e"Rosa Parks"\x3c/code\x3e. Wie angedeutet werden h\u00e4ufig Benutzereingaben vor der Verarbeitung getrimmt.',task:'Schreibe eine Funktion \x3ccode\x3efirstChar\x3c/code\x3e, die bei \u00dcbergabe eines Strings das erste Zeichen, das kein Leerzeichen ist, zur\u00fcckgibt. \x3ccode\x3efirstChar(" Rosa")\x3c/code\x3e sollte \x3ccode\x3e"R"\x3c/code\x3e zur\u00fcckgeben.',
beforeTests:function(){"undefined"!==typeof firstChar&&(firstChar=void 0)},tests:[function(){var a="function"===typeof firstChar;return{ok:a,msg:a?"\x3ccode\x3efirstChar\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3efirstChar\x3c/code\x3e ist keine Funktion."}},function(){var a=firstChar.length,b=1===a;return{ok:b,msg:b?"\x3ccode\x3efirstChar\x3c/code\x3e hat genau 1 Parameter.":"\x3ccode\x3efirstChar\x3c/code\x3e hat nicht 1, sondern "+a+" Parameter."}},function(){var a,b,d;try{var c=firstChar(" Rosa");
b=(a="R"===c)?'\x3ccode\x3efirstChar(" Rosa")\x3c/code\x3e gibt \x3ccode\x3e"R"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3efirstChar(" Rosa")\x3c/code\x3e gibt nicht \x3ccode\x3e"R"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3efirstChar(" Rosa")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=firstChar("Parks");b=(a="P"===c)?'\x3ccode\x3efirstChar("Parks")\x3c/code\x3e gibt \x3ccode\x3e"P"\x3c/code\x3e zur\u00fcck.':
'\x3ccode\x3efirstChar("Parks")\x3c/code\x3e gibt nicht \x3ccode\x3e"P"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3efirstChar("Parks")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"stringindexof",title:"String: indexOf()",lesson:'Um die Position eines Strings innerhalb eines anderen Strings zu bestimmen, verwendet man die Methode \x3ccode\x3eindexOf\x3c/code\x3e:\x3cpre\x3e\x3ccode\x3evar n1 \x3d "Fred Feuerstein".indexOf("Feuer");\x3cbr\x3evar n2 \x3d "Fred Feuerstein".indexOf("Rauch");\x3cbr\x3evar n3 \x3d "Fred Feuerstein".indexOf("FEUER");\x3cbr\x3e\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3en1\x3c/code\x3e ist \x3ccode\x3e5\x3c/code\x3e, da \x3ccode\x3e"Feuer"\x3c/code\x3e in \x3ccode\x3e"Fred Feuerstein"\x3c/code\x3e an der 5. Stelle beginnt. Wie \u00fcblich werden Strings von 0 an durchnummeriert. Kommt das Suchwort im aufrufenden String nicht vor, wird \x3ccode\x3e-1\x3c/code\x3e zur\u00fcckgegeben. \x3ccode\x3en2\x3c/code\x3e ist also \x3ccode\x3e-1\x3c/code\x3e. Die Methode \x3ccode\x3eindexOf()\x3c/code\x3e unterscheidet zwischen Gro\u00df- und Kleinschreibung. \x3ccode\x3en3\x3c/code\x3e ist also auch \x3ccode\x3e-1\x3c/code\x3e.',task:'Schreibe eine Funktion \x3ccode\x3eindexOfIgnoreCase\x3c/code\x3e, die 2 Strings entgegennimmt und wie die Methode \x3ccode\x3eindexOf\x3c/code\x3e die Position des zweiten Strings im ersten String bestimmt. Im Unterschied zur Methode \x3ccode\x3eindexOf\x3c/code\x3e soll die Gro\u00df- oder Kleinschreibung keine Rolle spielen. Sowohl \x3ccode\x3eindexOfIgnoreCase("So", "so")\x3c/code\x3e als auch \x3ccode\x3eindexOfIgnoreCase("so", "So")\x3c/code\x3e sollen \x3ccode\x3e0\x3c/code\x3e ergeben.',
beforeTests:function(){"undefined"!==typeof indexOfIgnoreCase&&(indexOfIgnoreCase=void 0)},tests:[function(){var a="function"===typeof indexOfIgnoreCase;return{ok:a,msg:a?"\x3ccode\x3eindexOfIgnoreCase\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eindexOfIgnoreCase\x3c/code\x3e ist keine Funktion."}},function(){var a=2===indexOfIgnoreCase.length;return{ok:a,msg:a?"\x3ccode\x3eindexOfIgnoreCase\x3c/code\x3e hat 2 Parameter.":"\x3ccode\x3eindexOfIgnoreCase\x3c/code\x3e hat nicht 2, sondern "+indexOfIgnoreCase.length+
" Parameter."}},function(){var a,b,d;try{var c=indexOfIgnoreCase("Fred Feuerstein","FEUER");b=(a=5===c)?'\x3ccode\x3eindexOfIgnoreCase("Fred Feuerstein", "FEUER")\x3c/code\x3e gibt \x3ccode\x3e5\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3eindexOfIgnoreCase("Fred Feuerstein", "FEUER")\x3c/code\x3e gibt nicht \x3ccode\x3e5\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3eindexOfIgnoreCase("Fred Feuerstein", "FEUER")\x3c/code\x3e.',
d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=indexOfIgnoreCase("WILMA FEUERSTEIN","feuer");b=(a=6===c)?'\x3ccode\x3eindexOfIgnoreCase("WILMA FEUERSTEIN", "feuer")\x3c/code\x3e gibt \x3ccode\x3e6\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3eindexOfIgnoreCase("WILMA FEUERSTEIN", "feuer")\x3c/code\x3e gibt nicht \x3ccode\x3e6\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3eindexOfIgnoreCase("WILMA FEUERSTEIN", "feuer")\x3c/code\x3e.',
d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"stringindexof2",title:"String: ... indexOf()",lesson:'Der Methode \x3ccode\x3eindexOf\x3c/code\x3e kann man als zweiten Parameter noch die Stelle mitgeben, ab der der Suchstring im aufrufenden String gesucht werden soll. \x3cpre\x3e\x3ccode\x3evar n1 \x3d "Fred Feuerstein".indexOf("e", 2);\x3cbr\x3evar n2 \x3d "Fred Feuerstein".indexOf("e", 3);\x3cbr\x3evar n3 \x3d "Fred Feuerstein".indexOf("e", 7);\x3cbr\x3e\x3c/code\x3e\x3c/pre\x3eDas erste \x3ccode\x3e"e"\x3c/code\x3e befindet sich in \x3ccode\x3e"Fred Feuerstein"\x3c/code\x3e an 2. Stelle. Es wird bei einer Suche ab der 2. Stelle gefunden. \x3ccode\x3en1\x3c/code\x3e ist also 2. Das zweite \x3ccode\x3e"e"\x3c/code\x3e in \x3ccode\x3e"Fred Feuerstein"\x3c/code\x3e befindet sich an der 6. Stelle. Es wird bei der Suche ab der 3. Stelle gefunden. \x3ccode\x3en2\x3c/code\x3e ist \x3ccode\x3e6\x3c/code\x3e. Mit der dritten Codezeile wird das dritte \x3ccode\x3e"e"\x3c/code\x3e in \x3ccode\x3e"Fred Feuerstein"\x3c/code\x3e gefunden. \x3ccode\x3en3\x3c/code\x3e ist \x3ccode\x3e8\x3c/code\x3e.',task:'Schreibe eine Funktion \x3ccode\x3esecondIndexOf\x3c/code\x3e, die 2 Strings entgegennimmt und die zweite Position des zweiten Strings im ersten String bestimmt. Kommt der Suchstring nicht zweimal vor, so soll \x3ccode\x3e-1\x3c/code\x3e zur\u00fcckgegeben werden. \x3ccode\x3esecondIndexOf("Maria Maria", "Maria")\x3c/code\x3e soll \x3ccode\x3e6\x3c/code\x3e zur\u00fcckgeben.',
beforeTests:function(){"undefined"!==typeof secondIndexOf&&(secondIndexOf=void 0)},tests:[function(){var a="function"===typeof secondIndexOf;return{ok:a,msg:a?"\x3ccode\x3esecondIndexOf\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3esecondIndexOf\x3c/code\x3e ist keine Funktion."}},function(){var a=2===secondIndexOf.length;return{ok:a,msg:a?"\x3ccode\x3esecondIndexOf\x3c/code\x3e hat 2 Parameter.":"\x3ccode\x3esecondIndexOf\x3c/code\x3e hat nicht 2, sondern "+secondIndexOf.length+" Parameter."}},function(){var a,
b,d;try{var c=secondIndexOf("Maria Maria","Maria");b=(a=6===c)?'\x3ccode\x3esecondIndexOf("Maria Maria", "Maria")\x3c/code\x3e gibt \x3ccode\x3e6\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3esecondIndexOf("Maria Maria", "Maria")\x3c/code\x3e gibt nicht \x3ccode\x3e6\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3esecondIndexOf("Maria Maria", "Maria")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=
secondIndexOf("xxXX","X");b=(a=3===c)?'\x3ccode\x3esecondIndexOf("xxXX", "X")\x3c/code\x3e gibt \x3ccode\x3e3\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3esecondIndexOf("xxXX", "X")\x3c/code\x3e gibt nicht \x3ccode\x3e3\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3esecondIndexOf("xxXX", "X")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=secondIndexOf("O ja!","ja");b=(a=-1===c)?'\x3ccode\x3esecondIndexOf("O ja!", "ja")\x3c/code\x3e gibt \x3ccode\x3e-1\x3c/code\x3e zur\u00fcck.':
'\x3ccode\x3esecondIndexOf("O ja!", "ja")\x3c/code\x3e gibt nicht \x3ccode\x3e-1\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3esecondIndexOf("O ja!", "ja")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"stringsubstr",title:"String: substr()",lesson:'Die Methode \x3ccode\x3esubstr\x3c/code\x3e extrahiert aus einen String einen Teilstring:\x3cpre\x3e\x3ccode\x3evar see \x3d "see and stop".substr(0, 3);\x3cbr\x3evar and \x3d "see and stop".substr(4, 3);\x3cbr\x3evar stop \x3d "see and stop".substr(8);\x3cbr\x3e\x3c/code\x3e\x3c/pre\x3eDer erste Parameter gibt an, von welcher Stelle an der Substring extrahiert werden soll. Der zweite Parameter gibt an, wieviel Zeichen ab der festgelegten Stelle extrahiert werden sollen. Ist der zweite Paramter nicht angegeben, so wird immer bis zum Ende des urspr\u00fcglichen Strings extrahiert.',task:'Schreibe eine Funktion \x3ccode\x3efirstWord\x3c/code\x3e, die einen String entgegennimmt und das erste Wort in diesem String zur\u00fcckgibt. Das erste Wort sind dabei alle Zeichen bis zum ersten Leerzeichen. \x3ccode\x3efirstWord("Wo ist hier")\x3c/code\x3e sollte \x3ccode\x3e"Wo"\x3c/code\x3e zur\u00fcckgeben.',
beforeTests:function(){"undefined"!==typeof firstWord&&(firstWord=void 0)},tests:[function(){var a="function"===typeof firstWord;return{ok:a,msg:a?"\x3ccode\x3efirstWord\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3efirstWord\x3c/code\x3e ist keine Funktion."}},function(){var a=1===firstWord.length;return{ok:a,msg:a?"\x3ccode\x3efirstWord\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3efirstWord\x3c/code\x3e hat nicht 1, sondern "+firstWord.length+" Parameter."}},function(){var a,b,d;try{var c=firstWord("Wo ist hier");
b=(a="Wo"===c)?'\x3ccode\x3efirstWord("Wo ist hier")\x3c/code\x3e gibt \x3ccode\x3e"Wo"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3efirstWord("Wo ist hier")\x3c/code\x3e gibt nicht \x3ccode\x3e"Wo"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3efirstWord("Wo ist hier")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=firstWord("Irres Licht");b=(a="Irres"===c)?'\x3ccode\x3efirstWord("Irres Licht")\x3c/code\x3e gibt \x3ccode\x3e"Irres"\x3c/code\x3e zur\u00fcck.':
'\x3ccode\x3efirstWord("Irres Licht")\x3c/code\x3e gibt nicht \x3ccode\x3e"Irres"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3efirstWord("Irres Licht")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"replace",title:"String: replace()",lesson:'Die Methode \x3ccode\x3ereplace\x3c/code\x3e ersetzt einen Teilstring durch einen anderen:\x3cpre\x3e\x3ccode\x3evar str \x3d "Hallo Marcel!";\x3cbr\x3evar newstr \x3d str.replace("Marcel", "Robert");\x3c/code\x3e\x3c/pre\x3e"Marcel" wird durch "Robert" ersetzt. \x3ccode\x3enewstr\x3c/code\x3e hat also den Wert \x3ccode\x3e"Hallo Robert!"\x3c/code\x3e. Der urspr\u00fcngliche String bleibt unver\u00e4ndert. Nur das erste Vorkommen wird ersetzt:\x3cpre\x3e\x3ccode\x3evar newname \x3d "Peter".replace("e", "a");\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3enewname\x3c/code\x3e enth\u00e4lt den Wert \x3ccode\x3e"Pater"\x3c/code\x3e und nicht \x3ccode\x3e"Patar"\x3c/code\x3e. Ein Spezialfall ergibt sich, wenn der ersetzende String der Leerstring ist:\x3cpre\x3e\x3ccode\x3evar nurso \x3d "sowie so".replace("wie", "");\x3c/code\x3e\x3c/pre\x3eDer zu ersetzende String wird entfernt. \x3ccode\x3enurso\x3c/code\x3e enth\u00e4lt den Wert \x3ccode\x3e"so so"\x3c/code\x3e. Kommt der zu ersetzende String nicht vor, so wird der urspr\u00fcngliche String zur\u00fcckgegeben.',task:'Schreibe eine Funktion \x3ccode\x3econvert\x3c/code\x3e, die einen Datumsstring in englischer Schreibweise (20-05-2017 oder 20/05/2017) in deutsche Schreibweise (20.05.2017) umwandet. Sowohl \x3ccode\x3econvert("20-05-2017")\x3c/code\x3e als auch \x3ccode\x3econvert("20/05/2017")\x3c/code\x3e sollten \x3ccode\x3e"20.05.2017"\x3c/code\x3e ergeben.',
beforeTests:function(){"undefined"!==typeof convert&&(convert=void 0)},tests:[function(){var a="function"===typeof convert;return{ok:a,msg:a?"\x3ccode\x3econvert\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3econvert\x3c/code\x3e ist keine Funktion."}},function(){var a=1===convert.length;return{ok:a,msg:a?"\x3ccode\x3econvert\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3econvert\x3c/code\x3e hat nicht 1, sondern "+convert.length+" Parameter."}},function(){var a,b,d;try{var c=convert("10-07-1871");b=
(a="10.07.1871"===c)?'\x3ccode\x3econvert("10-07-1871")\x3c/code\x3e gibt \x3ccode\x3e"10.07.1871"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3econvert("10-07-1871")\x3c/code\x3e gibt nicht \x3ccode\x3e"10.07.1871"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3econvert("10-07-1871")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=convert("18/11/1922");b=(a="18.11.1922"===c)?'\x3ccode\x3econvert("18/11/1922")\x3c/code\x3e gibt \x3ccode\x3e"18.11.1922"\x3c/code\x3e zur\u00fcck.':
'\x3ccode\x3econvert("18/11/1922")\x3c/code\x3e gibt nicht \x3ccode\x3e"18.11.1922"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3econvert("18/11/1922")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"number",title:"Zahlen",lesson:"Zahlen werden in JavaScript durch einfache Ziffern dargestellt. Sie k\u00f6nnen einen Dezimalpunkt und ein Minuszeichen besitzen.\x3cpre\x3e\x3ccode\x3evar x1 \x3d 1;\x3cbr\x3evar x2 \x3d 1.0;\x3cbr\x3evar x3 \x3d 3.14;\x3cbr\x3evar x4 \x3d -1;\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3e1\x3c/code\x3e und \x3ccode\x3e1.0\x3c/code\x3e sind dieselbe Zahl. Mit Zahlen kann man rechnen. Die vier Grundrechenarten Addieren, Subtrahieren, Multiplizieren und Dividieren werden durch \x3ccode\x3e+ - *\x3c/code\x3e und \x3ccode\x3e/\x3c/code\x3e dargestellt.\x3cpre\x3e\x3ccode\x3evar x1 \x3d 6;\x3cbr\x3evar x2 \x3d 2;\x3cbr\x3evar x3 \x3d x1 + x2;\x3cbr\x3evar x4 \x3d x1 - x2;\x3cbr\x3evar x5 \x3d x1 * x2;\x3cbr\x3evar x6 \x3d x1 / x2;\x3c/code\x3e\x3c/pre\x3eDie Variablen \x3ccode\x3ex3\x3c/code\x3e bis \x3ccode\x3ex6\x3c/code\x3e haben so die Werte \x3ccode\x3e8\x3c/code\x3e, \x3ccode\x3e4\x3c/code\x3e, \x3ccode\x3e12\x3c/code\x3e und \x3ccode\x3e3\x3c/code\x3e.",task:"Schreibe eine Funktion \x3ccode\x3eadd\x3c/code\x3e, die zwei Zahlen als Parameter entgegennimmt und deren Summe zur\u00fcckgibt. \x3ccode\x3eadd(1, 2)\x3c/code\x3e sollte \x3ccode\x3e3\x3c/code\x3e ergeben.",
beforeTests:function(){"undefined"!==typeof add&&(add=void 0)},tests:[function(){var a="function"===typeof add;return{ok:a,msg:a?"\x3ccode\x3eadd\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eadd\x3c/code\x3e ist keine Funktion."}},function(){var a=2===add.length;return{ok:a,msg:a?"\x3ccode\x3eadd\x3c/code\x3e hat zwei Parameter.":"\x3ccode\x3eadd\x3c/code\x3e hat nicht 2, sondern "+add.length+" Parameter."}},function(){var a,b,d;try{var c=add(0,0);b=(a=0===c)?"\x3ccode\x3eadd(0, 0)\x3c/code\x3e ergibt \x3ccode\x3e0\x3c/code\x3e.":
"\x3ccode\x3eadd(0, 0)\x3c/code\x3e ergibt nicht \x3ccode\x3e0\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eadd(0, 0)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=add(2,3);b=(a=5===c)?"\x3ccode\x3eadd(2, 3)\x3c/code\x3e ergibt \x3ccode\x3e5\x3c/code\x3e.":"\x3ccode\x3eadd(2, 3)\x3c/code\x3e ergibt nicht \x3ccode\x3e5\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=
!1,b="Fehler beim Aufruf von \x3ccode\x3eadd(2, 3)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"modulo",title:"Modulo",lesson:"Ein weiterer arithmetischer Operator ist Modulo. Er berechnet den Rest einer Division und wird mit dem Prozentzeichen \x3ccode\x3e%\x3c/code\x3e notiert.\x3cpre\x3e\x3ccode\x3evar x \x3d 7 % 2;\x3cbr\x3evar y \x3d 20 % 3;\x3c/code\x3e\x3c/pre\x3e7 geteilt durch 2 ergibt 3 Rest 1. \x3ccode\x3ex\x3c/code\x3e ist also \x3ccode\x3e1\x3c/code\x3e.\x3cbr\x3e20 geteilt durch 3 ergibt 6 Rest 2. \x3ccode\x3ey\x3c/code\x3e ist also \x3ccode\x3e2\x3c/code\x3e.",task:"Schreibe eine Funktion \x3ccode\x3eeiner\x3c/code\x3e, die eine nat\u00fcrliche Zahl entgegenimmt und die Ziffer der Einer-Stelle zur\u00fcckgibt. \x3ccode\x3eeiner(2674)\x3c/code\x3e sollte \x3ccode\x3e4\x3c/code\x3e zur\u00fcckgeben.",
beforeTests:function(){"undefined"!==typeof einer&&(einer=void 0)},tests:[function(){var a="function"===typeof einer;return{ok:a,msg:a?"\x3ccode\x3eeiner\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eeiner\x3c/code\x3e ist keine Funktion."}},function(){var a=1===einer.length;return{ok:a,msg:a?"\x3ccode\x3eeiner\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3eeiner\x3c/code\x3e hat nicht 1, sondern "+einer.length+" Parameter."}},function(){var a,b,d;try{var c=einer(0);b=(a=0===c)?"\x3ccode\x3eeiner(0)\x3c/code\x3e gibt \x3ccode\x3e0\x3c/code\x3e zur\u00fcck.":
"\x3ccode\x3eeiner(0)\x3c/code\x3e gibt nicht \x3ccode\x3e0\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eeiner(0)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=einer(17);b=(a=7===c)?"\x3ccode\x3eeiner(17)\x3c/code\x3e gibt \x3ccode\x3e7\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3eeiner(17)\x3c/code\x3e gibt nicht \x3ccode\x3e7\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=
!1,b="Fehler beim Aufruf von \x3ccode\x3eeiner(17)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"mean",title:"Klammern",lesson:"Ebenso wie in der Mathematik gilt in JavaScript die Punkt-vor-Strichrechnung. Multiplikation und Division werden vor Addition und Subtraktion ausgef\u00fchrt. M\u00f6chte man zuerst die Strichrechnung ausf\u00fchren, verwendet man genauso wie in der Mathematik Klammern.\x3cpre\x3e\x3ccode\x3evar x1 \x3d 3 + 4 * 2;\x3cbr\x3evar x2 \x3d (3 + 4) * 2;\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3ex1\x3c/code\x3e hat den Wert \x3ccode\x3e11\x3c/code\x3e, der Wert von \x3ccode\x3ex2\x3c/code\x3e ist \x3ccode\x3e14\x3c/code\x3e.",task:"Schreibe eine Funktion \x3ccode\x3emittelwert\x3c/code\x3e, die zwei Zahlen als Parameter entgegennimmt und deren Mittelwert zur\u00fcckgibt. \x3ccode\x3emittelwert(1, 2)\x3c/code\x3e sollte \x3ccode\x3e1.5\x3c/code\x3e ergeben.",
beforeTests:function(){"undefined"!==typeof mittelwert&&(mittelwert=void 0)},tests:[function(){var a="function"===typeof mittelwert;return{ok:a,msg:a?"\x3ccode\x3emittelwert\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3emittelwert\x3c/code\x3e ist keine Funktion."}},function(){var a=2===mittelwert.length;return{ok:a,msg:a?"\x3ccode\x3emittelwert\x3c/code\x3e hat zwei Parameter.":"\x3ccode\x3emittelwert\x3c/code\x3e hat nicht 2, sondern "+mittelwert.length+" Parameter."}},function(){var a,b,d;try{var c=
mittelwert(1,2);b=(a=1.5===c)?"\x3ccode\x3emittelwert(1, 2)\x3c/code\x3e ergibt \x3ccode\x3e1.5\x3c/code\x3e.":"\x3ccode\x3emittelwert(1, 2)\x3c/code\x3e ergibt nicht \x3ccode\x3e1.5\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3emittelwert(1, 2)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=mittelwert(0,0);b=(a=0===c)?"\x3ccode\x3emittelwert(0, 0)\x3c/code\x3e ergibt \x3ccode\x3e0\x3c/code\x3e.":
"\x3ccode\x3emittelwert(0, 0)\x3c/code\x3e ergibt nicht \x3ccode\x3e0\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3emittelwert(0, 0)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"math",title:"Math",lesson:"Viele mathematische Funktionen sind in dem Objekt \x3ccode\x3eMath\x3c/code\x3e zusammengefasst. So gibt \x3ccode\x3eMath.sqrt(x)\x3c/code\x3e die Quadratwurzel (engl.: square root) zur\u00fcck und mit \x3ccode\x3eMath.pow(x, y)\x3c/code\x3e berechnet man die Potenz (engl.: power) x hoch y.\x3cpre\x3e\x3ccode\x3evar y1 \x3d Math.sqrt(9);\x3cbr\x3evar y2 \x3d Math.pow(10, 3);\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3ey1\x3c/code\x3e hat den Wert \x3ccode\x3e3\x3c/code\x3e und \x3ccode\x3ey2\x3c/code\x3e den Wert \x3ccode\x3e1000\x3c/code\x3e (10\x26sup3; \x3d 10 * 10 * 10 \x3d 1000). ",task:"Schreibe eine Funktion \x3ccode\x3ehypotenuse\x3c/code\x3e, die die L\u00e4nge der Hypotenuse eines rechtwinkligen Dreiecks berechnet. \u00dcbergeben wird der Funktion als Parameter die L\u00e4ngen der beiden Katheten. Tipp: In einem rechtwinkligen Dreieck gilt der Satz des Pythagoras. Sind a, b die L\u00e4ngen der beiden Katheten und c die L\u00e4nge der Hypotenuse, so gilt: a\x26sup2; + b\x26sup2; \x3d c\x26sup2;. Da 3\x26sup2; + 4\x26sup2; \x3d 5\x26sup2; gilt, sollte \x3ccode\x3ehypotenuse(3, 4)\x3c/code\x3e den Wert \x3ccode\x3e5\x3c/code\x3e liefern.",
beforeTests:function(){"undefined"!==typeof hypotenuse&&(hypotenuse=void 0)},tests:[function(){var a="function"===typeof hypotenuse;return{ok:a,msg:a?"\x3ccode\x3ehypotenuse\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3ehypotenuse\x3c/code\x3e ist keine Funktion."}},function(){var a=2===hypotenuse.length;return{ok:a,msg:a?"\x3ccode\x3ehypotenuse\x3c/code\x3e hat zwei Parameter.":"\x3ccode\x3ehypotenuse\x3c/code\x3e hat nicht 2, sondern "+hypotenuse.length+" Parameter."}},function(){var a,b,d;try{var c=
hypotenuse(3,4);b=(a=5===c)?"\x3ccode\x3ehypotenuse(3, 4)\x3c/code\x3e ergibt \x3ccode\x3e5\x3c/code\x3e.":"\x3ccode\x3ehypotenuse(3, 4)\x3c/code\x3e ergibt nicht \x3ccode\x3e5\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3ehypotenuse(3, 4)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=hypotenuse(5,12);b=(a=13===c)?"\x3ccode\x3ehypotenuse(5, 12)\x3c/code\x3e ergibt \x3ccode\x3e13\x3c/code\x3e.":
"\x3ccode\x3ehypotenuse(5, 12)\x3c/code\x3e ergibt nicht \x3ccode\x3e13\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3ehypotenuse(5, 12)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"pi",title:"Math.PI",lesson:"Neben mathematischen Funktionen besitzt \x3ccode\x3eMath\x3c/code\x3e auch einige mathematische Konstanten. \x3ccode\x3eMath.PI\x3c/code\x3e liefert die Kreiszahl \x26pi; (gerundet 3.14) und \x3ccode\x3eMath.E\x3c/code\x3e die Eulersche Zahl e (gerundet 2.71). Beachte: Die Konstanten werden im Gegensatz zu Funktionen ohne anschlie\u00dfende Klammern aufgerufen.",task:"Schreibe eine Funktion \x3ccode\x3eflaeche\x3c/code\x3e, die die Fl\u00e4che eines Kreises berechnet. \u00dcbergeben wird der Funktion als Parameter der Radius des Kreises. Tipp: Die Fl\u00e4che eines Kreises ist \x26pi; * r\x26sup2;. Dabei ist r der Radius des Kreises.",
beforeTests:function(){"undefined"!==typeof flaeche&&(flaeche=void 0)},tests:[function(){var a="function"===typeof flaeche;return{ok:a,msg:a?"\x3ccode\x3eflaeche\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eflaeche\x3c/code\x3e ist keine Funktion."}},function(){var a=1===flaeche.length;return{ok:a,msg:a?"\x3ccode\x3eflaeche\x3c/code\x3e hat einen Parameter.":"\x3ccode\x3eflaeche\x3c/code\x3e hat nicht 1, sondern "+flaeche.length+" Parameter."}},function(){var a,b,d;try{var c=flaeche(1);b=(a=c===
Math.PI)?"\x3ccode\x3eflaeche(1)\x3c/code\x3e ergibt \x3ccode\x3e"+Math.PI+"\x3c/code\x3e.":"\x3ccode\x3eflaeche(1)\x3c/code\x3e ergibt nicht \x3ccode\x3e"+Math.PI+"\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eflaeche(1)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=flaeche(2);b=(a=c===4*Math.PI)?"\x3ccode\x3eflaeche(2)\x3c/code\x3e ergibt \x3ccode\x3e"+4*Math.PI+"\x3c/code\x3e.":"\x3ccode\x3eflaeche(2)\x3c/code\x3e ergibt nicht \x3ccode\x3e"+
4*Math.PI+"\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eflaeche(2)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"round",title:"Runden",lesson:"M\u00f6chte man eine Dezimalzahl auf- oder abrunden, stehen einem die Funktionen \x3ccode\x3eMath.round()\x3c/code\x3e, \x3ccode\x3eMath.floor()\x3c/code\x3e (engl.: Boden) und \x3ccode\x3eMath.ceil()\x3c/code\x3e (engl: Decke) zur Verf\u00fcgung.\x3cpre\x3e\x3ccode\x3evar a \x3d Math.round(5.49);\x3cbr\x3evar b \x3d Math.round(4.5);\x3cbr\x3evar c \x3d Math.floor(5.99);\x3cbr\x3evar d \x3d Math.ceil(4.01);\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3eMath.round()\x3c/code\x3e rundet kaufm\u00e4nnisch. Zahlen mit der ersten Dezimalstelle kleiner gleich 4 werden abgerundet, alle anderen aufgerundet. \x3ccode\x3eMath.floor()\x3c/code\x3e rundet immer ab und \x3ccode\x3eMath.ceil()\x3c/code\x3e rundet immer auf. Die Variablen \x3ccode\x3ea\x3c/code\x3e bis \x3ccode\x3ed\x3c/code\x3e werden also alle auf \x3ccode\x3e5\x3c/code\x3e gerundet.",task:"Schreibe eine Funktion \x3ccode\x3eround100\x3c/code\x3e, die eine Dezimalzahl kaufm\u00e4nnisch auf die Hunderterstelle rundet. \x3ccode\x3eround100(1749)\x3c/code\x3e sollte \x3ccode\x3e1700\x3c/code\x3e und \x3ccode\x3eround100(856.123)\x3c/code\x3e sollte \x3ccode\x3e900\x3c/code\x3e ergeben.\x3cbr\x3eTipp: Verwende neben \x3ccode\x3eMath.round()\x3c/code\x3e noch Multiplikation und Division.",
beforeTests:function(){"undefined"!==typeof round100&&(round100=void 0)},tests:[function(){var a="function"===typeof round100;return{ok:a,msg:a?"\x3ccode\x3eround100\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eround100\x3c/code\x3e ist keine Funktion."}},function(){var a=1===round100.length;return{ok:a,msg:a?"\x3ccode\x3eround100\x3c/code\x3e hat einen Parameter.":"\x3ccode\x3eround100\x3c/code\x3e hat nicht 1, sondern "+round100.length+" Parameter."}},function(){var a,b,d;try{var c=round100(49.999);
b=(a=0===c)?"\x3ccode\x3eround100(49.999)\x3c/code\x3e ergibt \x3ccode\x3e0\x3c/code\x3e.":"\x3ccode\x3eround100(49.999)\x3c/code\x3e ergibt nicht \x3ccode\x3e0\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eround100(49.999)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=round100(4650);b=(a=4700===c)?"\x3ccode\x3eround100(4650)\x3c/code\x3e ergibt \x3ccode\x3e4700\x3c/code\x3e.":"\x3ccode\x3eround100(4650)\x3c/code\x3e ergibt nicht \x3ccode\x3e4700\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eround100(4650)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
(function(){jshero.koans.add({id:"random",title:"Zufallszahlen",lesson:"Mit \x3ccode\x3eMath.random()\x3c/code\x3e erzeugt man eine Pseudozufallszahl zwischen 0 (inklusive) und 1 (exklusive).\x3cpre\x3e\x3ccode\x3evar x \x3d Math.random();\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3ex\x3c/code\x3e k\u00f6nnte z.B. den Wert \x3ccode\x3e0.6206372241429993\x3c/code\x3e erhalten. Jeder Aufruf von \x3ccode\x3eMath.random()\x3c/code\x3e generiert eine neue Pseudozufallszahl. Die Zahlen sind zwischen 0 und 1 gleichverteilt. Sie hei\u00dfen Pseudozufallszahlen, weil sie zuf\u00e4llig aussehen, aber dennoch berechnet werden. M\u00f6chte man Zufallszahlen in einem anderen Wertebereich oder mit einer anderen Verteilung erhalten, muss man die von \x3ccode\x3eMath.random()\x3c/code\x3e generierten Zahlen geeignet umrechnen. Das soll jetzt gleich probiert werden.",task:"Schreibe eine Funktion \x3ccode\x3edice\x3c/code\x3e, die wie ein W\u00fcrfel eine Zufallszahl zwischen 1 und 6 zur\u00fcckgibt.",
beforeTests:function(){"undefined"!==typeof dice&&(dice=void 0)},tests:[function(){var a="function"===typeof dice;return{ok:a,msg:a?"\x3ccode\x3edice\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3edice\x3c/code\x3e ist keine Funktion."}},function(){var a=0===dice.length;return{ok:a,msg:a?"\x3ccode\x3edice\x3c/code\x3e hat keinen Parameter.":"\x3ccode\x3edice\x3c/code\x3e hat nicht 0, sondern "+dice.length+" Parameter."}},function(){var a,b,d;try{a=!0;for(var c,e=0;1E3>e;e++)if(c=dice(),1!==c&&2!==
c&&3!==c&&4!==c&&5!==c&&6!==c){a=!1;break}b=a?"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen nur nat\u00fcrliche Zahlen zwischen \x3ccode\x3e1\x3c/code\x3e und \x3ccode\x3e6\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen mindestens einmal \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck. Dies ist keine nat\u00fcrliche Zahl zwischen \x3ccode\x3e1\x3c/code\x3e und \x3ccode\x3e6\x3c/code\x3e."}catch(f){a=!1,b="Fehler beim Aufruf von \x3ccode\x3edice()\x3c/code\x3e.",
d=f}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{a=!1;for(var c,e=0;1E3>e;e++)if(c=dice(),1===c){a=!0;break}b=a?"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen mindestens einmal \x3ccode\x3e1\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen keine \x3ccode\x3e1\x3c/code\x3e zur\u00fcck."}catch(f){a=!1,b="Fehler beim Aufruf von \x3ccode\x3edice()\x3c/code\x3e.",d=f}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{a=!1;for(var c,e=0;1E3>e;e++)if(c=dice(),2===
c){a=!0;break}b=a?"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen mindestens einmal \x3ccode\x3e2\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen keine \x3ccode\x3e2\x3c/code\x3e zur\u00fcck."}catch(f){a=!1,b="Fehler beim Aufruf von \x3ccode\x3edice()\x3c/code\x3e.",d=f}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{a=!1;for(var c,e=0;1E3>e;e++)if(c=dice(),3===c){a=!0;break}b=a?"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen mindestens einmal \x3ccode\x3e3\x3c/code\x3e zur\u00fcck.":
"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen keine \x3ccode\x3e3\x3c/code\x3e zur\u00fcck."}catch(f){a=!1,b="Fehler beim Aufruf von \x3ccode\x3edice()\x3c/code\x3e.",d=f}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{a=!1;for(var c,e=0;1E3>e;e++)if(c=dice(),4===c){a=!0;break}b=a?"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen mindestens einmal \x3ccode\x3e4\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen keine \x3ccode\x3e4\x3c/code\x3e zur\u00fcck."}catch(f){a=
!1,b="Fehler beim Aufruf von \x3ccode\x3edice()\x3c/code\x3e.",d=f}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{a=!1;for(var c,e=0;1E3>e;e++)if(c=dice(),5===c){a=!0;break}b=a?"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen mindestens einmal \x3ccode\x3e5\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen keine \x3ccode\x3e5\x3c/code\x3e zur\u00fcck."}catch(f){a=!1,b="Fehler beim Aufruf von \x3ccode\x3edice()\x3c/code\x3e.",d=f}return{ok:a,msg:b,e:d}},function(){var a,
b,d;try{a=!1;for(var c,e=0;1E3>e;e++)if(c=dice(),6===c){a=!0;break}b=a?"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen mindestens einmal \x3ccode\x3e6\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3edice()\x3c/code\x3e gab bei 1000 Aufrufen keine \x3ccode\x3e6\x3c/code\x3e zur\u00fcck."}catch(f){a=!1,b="Fehler beim Aufruf von \x3ccode\x3edice()\x3c/code\x3e.",d=f}return{ok:a,msg:b,e:d}}]})})();
jshero.koans.add({id:"parseint",title:"parseInt",lesson:'H\u00e4ufig m\u00f6chte man eine Zahl, die als String vorliegt, in eine Zahl vom Typ Number umwandeln. F\u00fcr das Umwandeln von ganzen Zahlen (..., -2, -1, 0, 1, 2, ..) gibt es in JavaScript die Funktion \x3ccode\x3eparseInt\x3c/code\x3e. Folgende Beispiele geben \x3ccode\x3e19\x3c/code\x3e oder \x3ccode\x3e-19\x3c/code\x3e zur\u00fcck: \x3cpre\x3e\x3ccode\x3evar n1 \x3d parseInt("19", 10);\x3cbr\x3evar n2 \x3d parseInt("+19", 10);\x3cbr\x3evar n3 \x3d parseInt("-19", 10);\x3cbr\x3evar n4 \x3d parseInt("19 Grad", 10);\x3cbr\x3evar n5 \x3d parseInt("19.1", 10);\x3cbr\x3evar n6 \x3d parseInt("019", 10);\x3cbr\x3evar n7 \x3d parseInt(" 19", 10);\x3cbr\x3e\x3c/code\x3e\x3c/pre\x3eNeben dem direkten Einlesen von ganzen Zahlen mit oder ohne Vorzeichen (n1, n2, n3) beherrscht \x3ccode\x3eparseInt\x3c/code\x3e auch einige komplexe F\u00e4lle. Nicht-numerische Zeichen nach der ganzen Zahl (n4, n5) sowie Nullen (n6) und Leerzeichen (n7) vor der Zahl werden ignoriert.\x3cbr\x3e\x3cbr\x3eIn allen Beispielen ist der zweite an \x3ccode\x3eparseInt\x3c/code\x3e \u00fcbergebene Parameter \x3ccode\x3e10\x3c/code\x3e. Dieser Paramter gibt an, zu welcher Basis die Zahl interpretiert werden soll. \x3ccode\x3e10\x3c/code\x3e steht f\u00fcr das \u00fcbliche Dezimalsystem. L\u00e4\u00dft man den zweiten Paramter weg, wird normalerweise das Dezimalsystem als Default verwendet. Da es aber von dieser Regel Ausnahmen gibt und diese Ausnahmen in verschiedenen Browsern auch noch unterschiedlich gehandhabt werden, sollte man immer die Basis mit angeben!\x3cbr\x3e\x3cbr\x3eKann \x3ccode\x3eparseInt\x3c/code\x3e keine Zahl einlesen, gibt sie den Wert \x3ccode\x3eNaN\x3c/code\x3e (engl.: Not a Number) zur\u00fcck:\x3cpre\x3e\x3ccode\x3evar n1 \x3d parseInt("Nur Text", 10);\x3cbr\x3evar n2 \x3d parseInt("Nr. 8", 10);\x3cbr\x3e\x3c/code\x3e\x3c/pre\x3eIm ersten Fall ist \u00fcberhaupt keine Zahl vorhanden. Im zweiten Fall gibt es nicht-numerische Zeichen vor der eigentlichen Zahl. Auch das ist nicht zul\u00e4ssig und f\u00fchrt zur R\u00fcckgabe \x3ccode\x3eNaN\x3c/code\x3e.',task:'Schreibe eine Funktion \x3ccode\x3eadd\x3c/code\x3e, die einen String mit einer Additionsaufgabe entgegennimmt und die das Ergebnis der Addition als Zahl zur\u00fcckgibt. Es sollen zwei nat\u00fcrliche Zahlen addiert werden. Die Additionsaufgabe ist ein String der Form "zahl1+zahl2". So soll \x3ccode\x3eadd("100+19")\x3c/code\x3e die Zahl \x3ccode\x3e119\x3c/code\x3e zur\u00fcckgeben.',
beforeTests:function(){"undefined"!==typeof add&&(add=void 0)},tests:[function(){var a="function"===typeof add;return{ok:a,msg:a?"\x3ccode\x3eadd\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eadd\x3c/code\x3e ist keine Funktion."}},function(){var a=1===add.length;return{ok:a,msg:a?"\x3ccode\x3eadd\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3eadd\x3c/code\x3e hat nicht 1, sondern "+add.length+" Parameter."}},function(){var a,b,d;try{var c=add("1+2");b=(a=3===c)?'\x3ccode\x3eadd("1+2")\x3c/code\x3e ergibt \x3ccode\x3e3\x3c/code\x3e.':
'\x3ccode\x3eadd("1+2")\x3c/code\x3e ergibt nicht \x3ccode\x3e3\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3eadd("1+2")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=add("100123+456");b=(a=100579===c)?'\x3ccode\x3eadd("100123+456")\x3c/code\x3e ergibt \x3ccode\x3e100579\x3c/code\x3e.':'\x3ccode\x3eadd("100123+456")\x3c/code\x3e ergibt nicht \x3ccode\x3e100579\x3c/code\x3e, sondern \x3ccode\x3e'+
JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3eadd("100123+456")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"numbertostring",title:"Number: toString()",lesson:'Die Number-Methode \x3ccode\x3etoString\x3c/code\x3e wandelt eine Zahl in den entsprechenden String um. Der Dezimalpunkt wird dabei als Punkt dargestellt. Das kann man z.B. dazu verwenden, eine Zahl im deutschen Format, also mit Komma als Dezimalpunkt, auszugeben:\x3ccode\x3e\x3cpre\x3evar number \x3d 7.25;\x3cbr\x3evar numberInEnglish \x3d number.toString();\x3cbr\x3evar numberInGerman \x3d numberInEnglish.replace(".", ",");\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3enumberInEnglish\x3c/code\x3e enth\u00e4lt den String \x3ccode\x3e"7.25"\x3c/code\x3e. Da wir jetzt unsere Zahl als String vorliegen haben, k\u00f6nnen wir auf ihr die String-Methode \x3ccode\x3ereplace\x3c/code\x3e anwenden. \x3ccode\x3enumberInGerman\x3c/code\x3e enth\u00e4lt so den String \x3ccode\x3e"7,25"\x3c/code\x3e.',task:"Schreibe eine Funktion \x3ccode\x3edigitLength\x3c/code\x3e, die eine nat\u00fcrliche Zahl entgegennimmt und die Anzahl der Ziffern zur\u00fcckgibt. \x3ccode\x3edigitLength(709)\x3c/code\x3e sollte 3 zur\u00fcckgeben.",
beforeTests:function(){"undefined"!==typeof digitLength&&(digitLength=void 0)},tests:[function(){var a="function"===typeof digitLength;return{ok:a,msg:a?"\x3ccode\x3edigitLength\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3edigitLength\x3c/code\x3e ist keine Funktion."}},function(){var a=1===digitLength.length;return{ok:a,msg:a?"\x3ccode\x3edigitLength\x3c/code\x3e hat einen Parameter.":"\x3ccode\x3edigitLength\x3c/code\x3e hat nicht 1, sondern "+digitLength.length+" Parameter."}},function(){var a,
b,d;try{var c=digitLength(1);b=(a=1===c)?"\x3ccode\x3edigitLength(1)\x3c/code\x3e gibt \x3ccode\x3e1\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3edigitLength(1)\x3c/code\x3e gibt nicht \x3ccode\x3e1\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3edigitLength(1)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=digitLength(709);b=(a=3===c)?"\x3ccode\x3edigitLength(709)\x3c/code\x3e gibt \x3ccode\x3e3\x3c/code\x3e zur\u00fcck.":
"\x3ccode\x3edigitLength(709)\x3c/code\x3e gibt nicht \x3ccode\x3e3\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3edigitLength(709)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"bool",title:"Wahrheitswerte",lesson:'Der dritte wichtige Datentyp neben Strings und Zahlen sind Wahrheitswerte. Sie werden auch boolesche Werte genannt. Boolesche Werte kennen nur zwei Zust\u00e4nde: \x3ccode\x3etrue\x3c/code\x3e und \x3ccode\x3efalse\x3c/code\x3e. Mit booleschen Werten kann man \u00e4hnlich "rechnen" wie mit Zahlen. JavaScript kennt drei boolesche Operatoren: \x3ccode\x3e\x26\x26\x3c/code\x3e (und), \x3ccode\x3e||\x3c/code\x3e (oder) und \x3ccode\x3e!\x3c/code\x3e (nicht). Das Ergebnis dieser Operationen ist wieder ein boolescher Wert. \x3ccode\x3e\x26\x26\x3c/code\x3e verkn\u00fcpft zwei boolesche Werte. Sind beide Werte \x3ccode\x3etrue\x3c/code\x3e, ist das Ergebnis auch \x3ccode\x3etrue\x3c/code\x3e. In allen anderen F\u00e4llen ist es \x3ccode\x3efalse\x3c/code\x3e. Bei \x3ccode\x3e||\x3c/code\x3e ist das Ergebnis \x3ccode\x3efalse\x3c/code\x3e, wenn beide Eingangswerte auch \x3ccode\x3efalse\x3c/code\x3e sind. In  allen anderen F\u00e4llen ist das Ergebnis \x3ccode\x3etrue\x3c/code\x3e. \x3ccode\x3e!\x3c/code\x3e wird nur auf einen booleschen Wert angewendet und invertiert diesen Wert: aus \x3ccode\x3etrue\x3c/code\x3e wird \x3ccode\x3efalse\x3c/code\x3e und aus \x3ccode\x3efalse\x3c/code\x3e wird \x3ccode\x3etrue\x3c/code\x3e.\x3cpre\x3e\x3ccode\x3evar x1 \x3d true \x26\x26 false;\x3cbr\x3evar x2 \x3d !x1;\x3cbr\x3evar x3 \x3d x1 || x2;\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3ex1\x3c/code\x3e ist \x3ccode\x3efalse\x3c/code\x3e,  \x3ccode\x3ex2\x3c/code\x3e ist \x3ccode\x3etrue\x3c/code\x3e und \x3ccode\x3ex3\x3c/code\x3e ist ebenfalls \x3ccode\x3etrue\x3c/code\x3e.',task:"Schreibe eine Funktion \x3ccode\x3enand\x3c/code\x3e, die zwei boolesche Werte als Parameter entgegennimmt. Die R\u00fcckgabe der Funktion soll \x3ccode\x3efalse\x3c/code\x3e sein, wenn beide Paramter \x3ccode\x3etrue\x3c/code\x3e sind. In den anderen F\u00e4llen soll die R\u00fcckgabe \x3ccode\x3etrue\x3c/code\x3e sein. \x3ccode\x3enand(true, true)\x3c/code\x3e soll \x3ccode\x3efalse\x3c/code\x3e liefern, \x3ccode\x3enand(true, false)\x3c/code\x3e, \x3ccode\x3enand(false, true)\x3c/code\x3e und \x3ccode\x3enand(false, false)\x3c/code\x3e sollen \x3ccode\x3etrue\x3c/code\x3e zur\u00fcckgeben.",
beforeTests:function(){"undefined"!==typeof nand&&(nand=void 0)},tests:[function(){var a="function"===typeof nand;return{ok:a,msg:a?"\x3ccode\x3enand\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3enand\x3c/code\x3e ist keine Funktion."}},function(){var a=2===nand.length;return{ok:a,msg:a?"\x3ccode\x3enand\x3c/code\x3e hat zwei Parameter.":"\x3ccode\x3enand\x3c/code\x3e hat nicht 2, sondern "+nand.length+" Parameter."}},function(){var a,b,d;try{var c=nand(!0,!0);b=(a=!1===c)?"\x3ccode\x3enand(true, true)\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.":
"\x3ccode\x3enand(true, true)\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3enand(true, true)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=nand(!0,!1);b=(a=!0===c)?"\x3ccode\x3enand(true, false)\x3c/code\x3e ergibt \x3ccode\x3etrue\x3c/code\x3e.":"\x3ccode\x3enand(true, false)\x3c/code\x3e ergibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3enand(true, false)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=nand(!1,!0);b=(a=!0===c)?"\x3ccode\x3enand(false, true)\x3c/code\x3e ergibt \x3ccode\x3etrue\x3c/code\x3e.":"\x3ccode\x3enand(false, true)\x3c/code\x3e ergibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3enand(false, true)\x3c/code\x3e.",
d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=nand(!1,!1);b=(a=!0===c)?"\x3ccode\x3enand(false, false)\x3c/code\x3e ergibt \x3ccode\x3etrue\x3c/code\x3e.":"\x3ccode\x3enand(false, false)\x3c/code\x3e ergibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3enand(false, false)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"xor",title:"XOR",lesson:"In der letzten Aufgabe hast du ein sogenanntes NAND-Gatter (engl.: Not AND - nicht und) programmiert. NAND-Gatter sind in der Digitaltechnik ein sogenannter Standardbaustein. Mit ihm lassen sich alle logischen Verkn\u00fcpfungen zusammenstellen. Hier sollst du ein weiteres wichtiges Gatter, das XOR-Gatter (engl.: eXclusive OR - exklusives Oder), kennen lernen.",task:"Schreibe eine Funktion \x3ccode\x3exor\x3c/code\x3e, die zwei boolesche Werte als Parameter entgegennimmt. Die R\u00fcckgabe der Funktion soll \x3ccode\x3etrue\x3c/code\x3e sein, wenn beide Paramter verschieden sind. In den anderen F\u00e4llen soll die R\u00fcckgabe \x3ccode\x3efalse\x3c/code\x3e sein. \x3ccode\x3exor(true, false)\x3c/code\x3e und \x3ccode\x3exor(false, true)\x3c/code\x3e sollen \x3ccode\x3etrue\x3c/code\x3e liefern, \x3ccode\x3exor(true, true)\x3c/code\x3e und \x3ccode\x3exor(false, false)\x3c/code\x3e sollen \x3ccode\x3efalse\x3c/code\x3e zur\u00fcckgeben.",
beforeTests:function(){"undefined"!==typeof nand&&(nand=void 0)},tests:[function(){var a="function"===typeof xor;return{ok:a,msg:a?"\x3ccode\x3exor\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3exor\x3c/code\x3e ist keine Funktion."}},function(){var a=2===xor.length;return{ok:a,msg:a?"\x3ccode\x3exor\x3c/code\x3e hat zwei Parameter.":"\x3ccode\x3exor\x3c/code\x3e hat nicht 2, sondern "+xor.length+" Parameter."}},function(){var a,b,d;try{var c=xor(!0,!0);b=(a=!1===c)?"\x3ccode\x3exor(true, true)\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.":
"\x3ccode\x3exor(true, true)\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3exor(true, true)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=xor(!1,!1);b=(a=!1===c)?"\x3ccode\x3exor(false, false)\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.":"\x3ccode\x3exor(false, false)\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3exor(false, false)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=xor(!0,!1);b=(a=!0===c)?"\x3ccode\x3exor(true, false)\x3c/code\x3e ergibt \x3ccode\x3etrue\x3c/code\x3e.":"\x3ccode\x3exor(true, false)\x3c/code\x3e ergibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3exor(true, false)\x3c/code\x3e.",
d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=xor(!1,!0);b=(a=!0===c)?"\x3ccode\x3exor(false, true)\x3c/code\x3e ergibt \x3ccode\x3etrue\x3c/code\x3e.":"\x3ccode\x3exor(false, true)\x3c/code\x3e ergibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3exor(false, true)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"equals",title:"Strikte Gleichheit",lesson:'Zwei Werte kann man auf strikte Gleichheit \u00fcberpr\u00fcfen. Das Ergebnis eines solchen Vergleichs ist entweder \x3ccode\x3etrue\x3c/code\x3e, die beiden Werte sind gleich, oder \x3ccode\x3efalse\x3c/code\x3e, die beiden Werte sind ungleich. Der Operator f\u00fcr strikte Gleichheit ist \x3ccode\x3e\x3d\x3d\x3d\x3c/code\x3e.\x3cpre\x3e\x3ccode\x3evar sprache \x3d "JavaScript";\x3cbr\x3evar x \x3d 10;\x3cbr\x3evar v1 \x3d sprache \x3d\x3d\x3d "Java";\x3cbr\x3evar v2 \x3d x \x3d\x3d\x3d 10;\x3cbr\x3evar v3 \x3d x \x3d\x3d\x3d "10";\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3ev1\x3c/code\x3e bekommt das Ergebnis des Vergleichs der Variablen \x3ccode\x3esprache\x3c/code\x3e mit dem Wert \x3ccode\x3e"Java"\x3c/code\x3e zugewiesen. Da \x3ccode\x3esprache\x3c/code\x3e zuvor den Wert \x3ccode\x3eJavaScript\x3c/code\x3e erhalten hat und diese beiden Werte verschieden sind, hat \x3ccode\x3ev1\x3c/code\x3e den Wert \x3ccode\x3efalse\x3c/code\x3e. \x3ccode\x3ev2\x3c/code\x3e ist \x3ccode\x3etrue\x3c/code\x3e, da der Wert von \x3ccode\x3ex\x3c/code\x3e gleich \x3ccode\x3e10\x3c/code\x3e ist. Bei der strikten Gleichheit kommt es auch darauf an, dass die Datentypen der beiden verglichenen Werte gleich sind. \x3ccode\x3ev3\x3c/code\x3e ist \x3ccode\x3efalse\x3c/code\x3e, da hier unterschiedliche Typen verglichen werden. Auf der linken Seite des Vergleichs steht eine Zahl, auf der rechten Seite ein String.',task:"Schreibe eine Funktion \x3ccode\x3egleich\x3c/code\x3e, die zwei Werte auf strikte Gleichheit \u00fcberpr\u00fcft. \x3ccode\x3egleich(1, 1)\x3c/code\x3e soll \x3ccode\x3etrue\x3c/code\x3e zur\u00fcckgeben, \x3ccode\x3egleich(1, 2)\x3c/code\x3e soll \x3ccode\x3efalse\x3c/code\x3e ergeben.",
beforeTests:function(){"undefined"!==typeof gleich&&(gleich=void 0)},tests:[function(){var a="function"===typeof gleich;return{ok:a,msg:a?"\x3ccode\x3egleich\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3egleich\x3c/code\x3e ist keine Funktion."}},function(){var a=2===gleich.length;return{ok:a,msg:a?"\x3ccode\x3egleich\x3c/code\x3e hat zwei Parameter.":"\x3ccode\x3egleich\x3c/code\x3e hat nicht 2, sondern "+gleich.length+" Parameter."}},function(){var a,b,d;try{var c=gleich(1,1);b=(a=!0===c)?"\x3ccode\x3egleich(1, 1)\x3c/code\x3e ergibt \x3ccode\x3etrue\x3c/code\x3e.":
"\x3ccode\x3egleich(1, 1)\x3c/code\x3e ergibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3egleich(1, 1)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=gleich(1,"1");b=(a=!1===c)?'\x3ccode\x3egleich(1, "1")\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.':'\x3ccode\x3egleich(1, "1")\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+
"\x3c/code\x3e."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3egleich(1, "1")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"equals2",title:"Drei gleiche Werte",lesson:"Die folgende Aufgabe soll das Zusammenspiel von strikter Gleichheit und booleschen Operatoren vertiefen.",task:"Schreibe eine Funktion \x3ccode\x3egleich\x3c/code\x3e, die 3 Werte auf strikte Gleichheit \u00fcberpr\u00fcft. Die Funktion soll nur dann \x3ccode\x3etrue\x3c/code\x3e ergeben, wenn alle 3 Werte gleich sind. \x3ccode\x3egleich(1, 1, 1)\x3c/code\x3e soll \x3ccode\x3etrue\x3c/code\x3e zur\u00fcckgeben, \x3ccode\x3egleich(1, 1, 2)\x3c/code\x3e soll \x3ccode\x3efalse\x3c/code\x3e ergeben.",beforeTests:function(){"undefined"!==
typeof gleich&&(gleich=void 0)},tests:[function(){var a="function"===typeof gleich;return{ok:a,msg:a?"\x3ccode\x3egleich\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3egleich\x3c/code\x3e ist keine Funktion."}},function(){var a=3===gleich.length;return{ok:a,msg:a?"\x3ccode\x3egleich\x3c/code\x3e hat 3 Parameter.":"\x3ccode\x3egleich\x3c/code\x3e hat nicht 3, sondern "+gleich.length+" Parameter."}},function(){var a,b,d;try{var c=gleich(1,1,1);b=(a=!0===c)?"\x3ccode\x3egleich(1, 1, 1)\x3c/code\x3e ergibt \x3ccode\x3etrue\x3c/code\x3e.":
"\x3ccode\x3egleich(1, 1, 1)\x3c/code\x3e ergibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3egleich(1, 1, 1)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=gleich(1,1,"1");b=(a=!1===c)?'\x3ccode\x3egleich(1, 1, "1")\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.':'\x3ccode\x3egleich(1, 1, "1")\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e'+
JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3egleich(1, 1, "1")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=gleich(1,"1",1);b=(a=!1===c)?'\x3ccode\x3egleich(1, "1", 1)\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.':'\x3ccode\x3egleich(1, "1", 1)\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3egleich(1, "1", 1)\x3c/code\x3e.',
d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=gleich("1",1,1);b=(a=!1===c)?'\x3ccode\x3egleich("1", 1, 1)\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.':'\x3ccode\x3egleich("1", 1, 1)\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3egleich("1", 1, 1)\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"even",title:"Gerade Zahlen",lesson:"Diese Aufgabe soll das Zusammenspiel von strikter Gleichheit und dem Modulo-Operator vertiefen.",task:"Schreibe eine Funktion \x3ccode\x3eistGerade\x3c/code\x3e, die angibt, ob eine \u00fcbergebene Zahl gerade oder ungerade ist. Ist die \u00fcbergebene Zahl gerade, so soll die Funktion \x3ccode\x3etrue\x3c/code\x3e zur\u00fcckgeben, andernfalls \x3ccode\x3efalse\x3c/code\x3e. \x3ccode\x3eistGerade(6)\x3c/code\x3e soll \x3ccode\x3etrue\x3c/code\x3e ergeben und \x3ccode\x3eistGerade(7)\x3c/code\x3e soll \x3ccode\x3efalse\x3c/code\x3e zur\u00fcckgeben. ",
beforeTests:function(){"undefined"!==typeof istGerade&&(gleich=void 0)},tests:[function(){var a="function"===typeof istGerade;return{ok:a,msg:a?"\x3ccode\x3eistGerade\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eistGerade\x3c/code\x3e ist keine Funktion."}},function(){var a=1===istGerade.length;return{ok:a,msg:a?"\x3ccode\x3eistGerade\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3eistGerade\x3c/code\x3e hat nicht 1, sondern "+istGerade.length+" Parameter."}},function(){var a,b,d;try{var c=istGerade(10);
b=(a=!0===c)?"\x3ccode\x3eistGerade(10)\x3c/code\x3e ergibt \x3ccode\x3etrue\x3c/code\x3e.":"\x3ccode\x3eistGerade(10)\x3c/code\x3e ergibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eistGerade(10)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=istGerade(15);b=(a=!1===c)?"\x3ccode\x3eistGerade(15)\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.":"\x3ccode\x3eistGerade(15)\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eistGerade(15)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"notequals",title:"Strikte Ungleichtheit",lesson:'Mit \x3ccode\x3e!\x3d\x3d\x3c/code\x3e vergleicht man zwei Werte auf strikte Ungleichheit.\x3cpre\x3e\x3ccode\x3evar v1 \x3d "lauf" !\x3d\x3d "Lauf";\x3cbr\x3evar v2 \x3d 10 !\x3d\x3d "10";\x3c/code\x3e\x3c/pre\x3eBeide Vergleiche ergeben \x3ccode\x3etrue\x3c/code\x3e. Der erste, weil sich die beiden Strings in der Gro\u00df- und Kleinschreibung unterscheiden. Der zweite, weil sich die beiden Werte von Typ her unterscheiden.',task:"Schreibe eine Funktion \x3ccode\x3eungleich\x3c/code\x3e, die 3 Werte auf strikte Ungleichheit \u00fcberpr\u00fcft. Die Funktion soll nur dann \x3ccode\x3etrue\x3c/code\x3e ergeben, wenn alle drei Parameter unterschiedlich sind. \x3ccode\x3eungleich(1, 2, 3)\x3c/code\x3e soll \x3ccode\x3etrue\x3c/code\x3e liefern, \x3ccode\x3eungleich(1, 1, 2)\x3c/code\x3e soll \x3ccode\x3efalse\x3c/code\x3e ergeben.",
beforeTests:function(){"undefined"!==typeof ungleich&&(ungleich=void 0)},tests:[function(){var a="function"===typeof ungleich;return{ok:a,msg:a?"\x3ccode\x3eungleich\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eungleich\x3c/code\x3e ist keine Funktion."}},function(){var a=3===ungleich.length;return{ok:a,msg:a?"\x3ccode\x3eungleich\x3c/code\x3e hat 3 Parameter.":"\x3ccode\x3eungleich\x3c/code\x3e hat nicht 3, sondern "+ungleich.length+" Parameter."}},function(){var a,b,d;try{var c=ungleich(1,2,3);
b=(a=!0===c)?"\x3ccode\x3eungleich(1, 2, 3)\x3c/code\x3e ergibt \x3ccode\x3etrue\x3c/code\x3e.":"\x3ccode\x3eungleich(1, 2, 3)\x3c/code\x3e ergibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eungleich(1, 2, 3)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=ungleich(1,1,2);b=(a=!1===c)?"\x3ccode\x3eungleich(1, 1, 2)\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.":"\x3ccode\x3eungleich(1, 1, 2)\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eungleich(1, 1, 2)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=ungleich(1,2,1);b=(a=!1===c)?"\x3ccode\x3eungleich(1, 2, 1)\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.":"\x3ccode\x3eungleich(1, 2, 1)\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eungleich(1, 2, 1)\x3c/code\x3e.",
d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=ungleich(2,1,1);b=(a=!1===c)?"\x3ccode\x3eungleich(2, 1, 1)\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.":"\x3ccode\x3eungleich(2, 1, 1)\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eungleich(2, 1, 1)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=ungleich("1",1,!0);b=(a=!0===c)?'\x3ccode\x3eungleich("1", 1, true)\x3c/code\x3e ergibt \x3ccode\x3etrue\x3c/code\x3e.':
'\x3ccode\x3eungleich("1", 1, true)\x3c/code\x3e ergibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3eungleich("1", 1, true)\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"greaterthan",title:"Zahlen vergleichen",lesson:"Zahlen kann man mit den aus der Mathematik bekannten Zeichen \x3ccode\x3e\x26gt;\x3c/code\x3e, \x3ccode\x3e\x26gt;\x3d\x3c/code\x3e, \x3ccode\x3e\x26lt;\x3c/code\x3e und \x3ccode\x3e\x26gt;\x3d\x3c/code\x3e auf gr\u00f6\u00dfer, gr\u00f6\u00dfer gleich, kleiner und kleiner gleich vergleichen. Im folgenden Beispiel liefern alle Ausdr\u00fccke den Wert \x3ccode\x3etrue\x3c/code\x3e:\x3cpre\x3e\x3ccode\x3evar v1 \x3d 5 \x3e 4;\x3cbr\x3evar v2 \x3d 5 \x3e\x3d 5;\x3cbr\x3evar v3 \x3d 5 \x3c 6;\x3cbr\x3evar v4 \x3d 5 \x3c\x3d 5;\x3c/code\x3e\x3c/pre\x3e",task:"Schreibe eine Funktion \x3ccode\x3eistDreistellig\x3c/code\x3e, die pr\u00fcft, ob eine Zahl gr\u00f6\u00dfer gleich 100 und kleiner 1000 ist. \x3ccode\x3eistDreistellig(500)\x3c/code\x3e sollte \x3ccode\x3etrue\x3c/code\x3e zur\u00fcckgeben, \x3ccode\x3eistDreistellig(50)\x3c/code\x3e sollte \x3ccode\x3efalse\x3c/code\x3e ergeben.",
beforeTests:function(){"undefined"!==typeof istDreistellig&&(istDreistellig=void 0)},tests:[function(){var a="function"===typeof istDreistellig;return{ok:a,msg:a?"\x3ccode\x3eistDreistellig\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eistDreistellig\x3c/code\x3e ist keine Funktion."}},function(){var a=1===istDreistellig.length;return{ok:a,msg:a?"\x3ccode\x3eistDreistellig\x3c/code\x3e hat einen Parameter.":"\x3ccode\x3eistDreistellig\x3c/code\x3e hat nicht 1, sondern "+istDreistellig.length+" Parameter."}},
function(){var a,b,d;try{var c=istDreistellig(100);b=(a=!0===c)?"\x3ccode\x3eistDreistellig(100)\x3c/code\x3e ergibt \x3ccode\x3etrue\x3c/code\x3e.":"\x3ccode\x3eistDreistellig(100)\x3c/code\x3e ergibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eistDreistellig(100)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=istDreistellig(999);b=(a=!0===c)?"\x3ccode\x3eistDreistellig(999)\x3c/code\x3e ergibt \x3ccode\x3etrue\x3c/code\x3e.":
"\x3ccode\x3eistDreistellig(999)\x3c/code\x3e ergibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eistDreistellig(999)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=istDreistellig(99);b=(a=!1===c)?"\x3ccode\x3eistDreistellig(99)\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.":"\x3ccode\x3eistDreistellig(99)\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eistDreistellig(99)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=istDreistellig(1E3);b=(a=!1===c)?"\x3ccode\x3eistDreistellig(1000)\x3c/code\x3e ergibt \x3ccode\x3efalse\x3c/code\x3e.":"\x3ccode\x3eistDreistellig(1000)\x3c/code\x3e ergibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eistDreistellig(1000)\x3c/code\x3e.",
d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"if",title:"if",lesson:"H\u00e4ufig soll Code nur dann ausgef\u00fchrt werden, wenn eine bestimmte Bedingung erf\u00fcllt ist. Dazu verwendet man die \x3ccode\x3eif\x3c/code\x3e-Anweisung.\x3cpre\x3e\x3ccode\x3evar gewinn \x3d 0;\x3cbr\x3eif (wuerfelzahl \x3d\x3d\x3d 6) {\x3cbr\x3e  gewinn \x3d 100;\x3cbr\x3e}\x3c/code\x3e\x3c/pre\x3eDiese Anweisung besteht aus dem Schl\u00fcsselwort \x3ccode\x3eif\x3c/code\x3e (engl: wenn) gefolgt von runden Klammern. In den runden Klammern steht ein Ausdruck - die Bedingung -, der zu \x3ccode\x3etrue\x3c/code\x3e oder \x3ccode\x3efalse\x3c/code\x3e ausgewertet wird. Ergibt die Bedingung \x3ccode\x3etrue\x3c/code\x3e, werden alle Anweisungen in dem durch die geschweiften Klammern begrenzten Block ausgef\u00fchrt. Ergibt die Bedingung \x3ccode\x3efalse\x3c/code\x3e, wird der durch die geschweiften Klammern begrenzte Block \u00fcbersprungen. Hat in unserem Beispiel die Variable \x3ccode\x3ewuerfelzahl\x3c/code\x3e den Wert \x3ccode\x3e6\x3c/code\x3e, so wird \x3ccode\x3egewinn\x3c/code\x3e auf \x3ccode\x3e100\x3c/code\x3e gesetzt. Hat \x3ccode\x3ewuerfelzahl\x3c/code\x3e nicht den Wert \x3ccode\x3e6\x3c/code\x3e, bleibt \x3ccode\x3egewinn\x3c/code\x3e bei \x3ccode\x3e0\x3c/code\x3e.",task:'Schreibe eine Funktion \x3ccode\x3egleich\x3c/code\x3e, die 2 Werte auf strikte Gleichheit \u00fcberpr\u00fcft. Sind die beiden Werte gleich, so soll der String \x3ccode\x3e"GLEICH"\x3c/code\x3e zur\u00fcckgegeben werden. Sind sie ungleich, so soll man \x3ccode\x3e"UNGLEICH"\x3c/code\x3e erhalten.',
beforeTests:function(){"undefined"!==typeof gleich&&(gleich=void 0)},tests:[function(){var a="function"===typeof gleich;return{ok:a,msg:a?"\x3ccode\x3egleich\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3egleich\x3c/code\x3e ist keine Funktion."}},function(){var a=2===gleich.length;return{ok:a,msg:a?"\x3ccode\x3egleich\x3c/code\x3e hat 2 Parameter.":"\x3ccode\x3egleich\x3c/code\x3e hat nicht 2, sondern "+gleich.length+" Parameter."}},function(){var a,b,d;try{var c=gleich(1,1);b=(a="GLEICH"===c)?'\x3ccode\x3egleich(1, 1)\x3c/code\x3e ergibt \x3ccode\x3e"GLEICH"\x3c/code\x3e.':
'\x3ccode\x3egleich(1, 1)\x3c/code\x3e ergibt nicht \x3ccode\x3e"GLEICH"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3egleich(1, 1)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=gleich(1,"1");b=(a="UNGLEICH"===c)?'\x3ccode\x3egleich(1, "1")\x3c/code\x3e ergibt \x3ccode\x3e"UNGLEICH"\x3c/code\x3e.':'\x3ccode\x3egleich(1, "1")\x3c/code\x3e ergibt nicht \x3ccode\x3e"UNGLEICH"\x3c/code\x3e, sondern \x3ccode\x3e'+
JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3egleich(1, "1")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"else",title:"if ... else",lesson:'M\u00f6chte man, dass ein Codeblock nur dann ausgef\u00fchrt wird, wenn eine \x3ccode\x3eif\x3c/code\x3e-Bedingung nicht erf\u00fcllt ist, verwendet man zus\u00e4tzlich zum \x3ccode\x3eif\x3c/code\x3e ein \x3ccode\x3eelse\x3c/code\x3e (engl.: sonst).\x3cpre\x3e\x3ccode\x3evar mitteilung;\x3cbr\x3eif (betrag \x3e 1000) {\x3cbr\x3e  mitteilung \x3d "Keine Auszahlung m\u00f6glich!";\x3cbr\x3e} else {\x3cbr\x3e  mitteilung \x3d "Der Betrag wird ausgezahlt!";\x3cbr\x3e}\x3c/code\x3e\x3c/pre\x3eJe nachdem, ob \x3ccode\x3ebetrag\x3c/code\x3e gr\u00f6\u00dfer oder kleiner \x3ccode\x3e1000\x3c/code\x3e ist, wird entweder der \x3ccode\x3eif\x3c/code\x3e-Zweig oder der \x3ccode\x3eelse\x3c/code\x3e-Zweig ausgef\u00fchrt.',task:"Schreibe eine Funktion \x3ccode\x3eaddiereMitZuschlag\x3c/code\x3e, die zwei Betr\u00e4ge mit Zuschlag addiert. F\u00fcr jeden Betrag, der kleiner gleich \x3ccode\x3e10\x3c/code\x3e ist, betr\u00e4gt der Zuschlag \x3ccode\x3e1\x3c/code\x3e. F\u00fcr jeden Betrag, der gr\u00f6\u00dfer \x3ccode\x3e10\x3c/code\x3e ist, betr\u00e4gt der Zuschlag \x3ccode\x3e2\x3c/code\x3e. \x3ccode\x3eaddiereMitZuschlag(10, 20)\x3c/code\x3e sollte \x3ccode\x3e33\x3c/code\x3e ergeben.",
beforeTests:function(){"undefined"!==typeof addiereMitZuschlag&&(addiereMitZuschlag=void 0)},tests:[function(){var a="function"===typeof addiereMitZuschlag;return{ok:a,msg:a?"\x3ccode\x3eaddiereMitZuschlag\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eaddiereMitZuschlag\x3c/code\x3e ist keine Funktion."}},function(){var a=2===addiereMitZuschlag.length;return{ok:a,msg:a?"\x3ccode\x3eaddiereMitZuschlag\x3c/code\x3e hat 2 Parameter.":"\x3ccode\x3eaddiereMitZuschlag\x3c/code\x3e hat nicht 2, sondern "+
addiereMitZuschlag.length+" Parameter."}},function(){var a,b,d;try{var c=addiereMitZuschlag(10,10);b=(a=22===c)?"\x3ccode\x3eaddiereMitZuschlag(10, 10)\x3c/code\x3e ergibt \x3ccode\x3e22\x3c/code\x3e.":"\x3ccode\x3eaddiereMitZuschlag(10, 10)\x3c/code\x3e ergibt nicht \x3ccode\x3e22\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eaddiereMitZuschlag(10, 10)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=
addiereMitZuschlag(10,11);b=(a=24===c)?"\x3ccode\x3eaddiereMitZuschlag(10, 11)\x3c/code\x3e ergibt \x3ccode\x3e24\x3c/code\x3e.":"\x3ccode\x3eaddiereMitZuschlag(10, 11)\x3c/code\x3e ergibt nicht \x3ccode\x3e24\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eaddiereMitZuschlag(10, 11)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=addiereMitZuschlag(11,10);b=(a=24===c)?"\x3ccode\x3eaddiereMitZuschlag(11, 10)\x3c/code\x3e ergibt \x3ccode\x3e24\x3c/code\x3e.":
"\x3ccode\x3eaddiereMitZuschlag(11, 10)\x3c/code\x3e ergibt nicht \x3ccode\x3e24\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eaddiereMitZuschlag(11, 10)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=addiereMitZuschlag(11,11);b=(a=26===c)?"\x3ccode\x3eaddiereMitZuschlag(11, 11)\x3c/code\x3e ergibt \x3ccode\x3e26\x3c/code\x3e.":"\x3ccode\x3eaddiereMitZuschlag(11, 11)\x3c/code\x3e ergibt nicht \x3ccode\x3e26\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eaddiereMitZuschlag(11, 11)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"elseif",title:"else if",lesson:'M\u00f6chte man mehrere F\u00e4lle unterscheiden, kann man ein \x3ccode\x3eif\x3c/code\x3e mit beliebig vielen \x3ccode\x3eelse if\x3c/code\x3e erg\u00e4nzen. Zum Schluss kann bei Bedarf noch ein einzelnes \x3ccode\x3eelse\x3c/code\x3e stehen.\x3cpre\x3e\x3ccode\x3evar mitteilung;\x3cbr\x3eif (betrag \x3e 1000) {\x3cbr\x3e  mitteilung \x3d "Zu gro\u00df. Keine Auszahlung m\u00f6glich!";\x3cbr\x3e} else if (betrag \x3c 10) {\x3cbr\x3e  mitteilung \x3d "Zu klein. Keine Auszahlung m\u00f6glich!";\x3cbr\x3e} else {\x3cbr\x3e  mitteilung \x3d "Der Betrag wird ausgezahlt!";\x3cbr\x3e}\x3c/code\x3e\x3c/pre\x3eZuerst wird gepr\u00fcft, ob \x3ccode\x3ebetrag\x3c/code\x3e gr\u00f6\u00dfer \x3ccode\x3e1000\x3c/code\x3e ist. Ist das der Fall, wird die "Zu gro\u00df..."-Mitteilung gesetzt und der Code am Ende des gesamten Blocks fortgesetzt. Ist das nicht der Fall, wird die \x3ccode\x3eelse if\x3c/code\x3e-Bedingung gepr\u00fcft. Ist diese erf\u00fcllt, wird die "Zu klein..."-Mitteilung gesetzt und der Code am Ende des gesamten Blocks fortgesetzt. Erst wenn keine Bedingung erf\u00fcllt ist, wird der abschlie\u00dfenden \x3ccode\x3eelse\x3c/code\x3e-Block ausgef\u00fchrt.',task:"Schreibe eine Funktion \x3ccode\x3eaddiereMitZuschlag\x3c/code\x3e, die zwei Betr\u00e4ge mit Zuschlag addiert. F\u00fcr jeden Betrag, der kleiner gleich \x3ccode\x3e10\x3c/code\x3e ist, betr\u00e4gt der Zuschlag \x3ccode\x3e1\x3c/code\x3e. F\u00fcr jeden Betrag, der gr\u00f6\u00dfer \x3ccode\x3e10\x3c/code\x3e und kleiner gleich \x3ccode\x3e20\x3c/code\x3e ist, betr\u00e4gt der Zuschlag \x3ccode\x3e2\x3c/code\x3e. F\u00fcr jeden Betrag, der gr\u00f6\u00dfer \x3ccode\x3e20\x3c/code\x3e ist, betr\u00e4gt der Zuschlag 3. \x3ccode\x3eaddiereMitZuschlag(10, 30)\x3c/code\x3e sollte \x3ccode\x3e44\x3c/code\x3e ergeben.",
beforeTests:function(){"undefined"!==typeof gleich&&(gleich=void 0)},tests:[function(){var a="function"===typeof addiereMitZuschlag;return{ok:a,msg:a?"\x3ccode\x3eaddiereMitZuschlag\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eaddiereMitZuschlag\x3c/code\x3e ist keine Funktion."}},function(){var a=2===addiereMitZuschlag.length;return{ok:a,msg:a?"\x3ccode\x3eaddiereMitZuschlag\x3c/code\x3e hat 2 Parameter.":"\x3ccode\x3eaddiereMitZuschlag\x3c/code\x3e hat nicht 2, sondern "+addiereMitZuschlag.length+
" Parameter."}},function(){var a,b,d;try{var c=addiereMitZuschlag(10,10);b=(a=22===c)?"\x3ccode\x3eaddiereMitZuschlag(10, 10)\x3c/code\x3e ergibt \x3ccode\x3e22\x3c/code\x3e.":"\x3ccode\x3eaddiereMitZuschlag(10, 10)\x3c/code\x3e ergibt nicht \x3ccode\x3e22\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eaddiereMitZuschlag(10, 10)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=addiereMitZuschlag(10,
11);b=(a=24===c)?"\x3ccode\x3eaddiereMitZuschlag(10, 11)\x3c/code\x3e ergibt \x3ccode\x3e24\x3c/code\x3e.":"\x3ccode\x3eaddiereMitZuschlag(10, 11)\x3c/code\x3e ergibt nicht \x3ccode\x3e24\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eaddiereMitZuschlag(10, 11)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=addiereMitZuschlag(11,10);b=(a=24===c)?"\x3ccode\x3eaddiereMitZuschlag(11, 10)\x3c/code\x3e ergibt \x3ccode\x3e24\x3c/code\x3e.":
"\x3ccode\x3eaddiereMitZuschlag(11, 10)\x3c/code\x3e ergibt nicht \x3ccode\x3e24\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eaddiereMitZuschlag(11, 10)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=addiereMitZuschlag(11,11);b=(a=26===c)?"\x3ccode\x3eaddiereMitZuschlag(11, 11)\x3c/code\x3e ergibt \x3ccode\x3e26\x3c/code\x3e.":"\x3ccode\x3eaddiereMitZuschlag(11, 11)\x3c/code\x3e ergibt nicht \x3ccode\x3e26\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eaddiereMitZuschlag(11, 11)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=addiereMitZuschlag(10,21);b=(a=35===c)?"\x3ccode\x3eaddiereMitZuschlag(10, 21)\x3c/code\x3e ergibt \x3ccode\x3e35\x3c/code\x3e.":"\x3ccode\x3eaddiereMitZuschlag(10, 21)\x3c/code\x3e ergibt nicht \x3ccode\x3e35\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eaddiereMitZuschlag(10, 21)\x3c/code\x3e.",
d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=addiereMitZuschlag(21,10);b=(a=35===c)?"\x3ccode\x3eaddiereMitZuschlag(21, 10)\x3c/code\x3e ergibt \x3ccode\x3e35\x3c/code\x3e.":"\x3ccode\x3eaddiereMitZuschlag(21, 10)\x3c/code\x3e ergibt nicht \x3ccode\x3e35\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eaddiereMitZuschlag(21, 10)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"array",title:"Arrays anlegen",lesson:'Arrays sind Objekte zur Speicherung vieler, meist \u00e4hnlicher Werte. Diese sogenannten Elemente werden in einem Array der Reihe nach abgelegt. Arrays erzeugt man am besten mit eckigen Klammern.\x3cpre\x3e\x3ccode\x3evar sprachen \x3d ["C", "C++", "Java", "JavaScript"];\x3cbr\x3evar primzahlen \x3d [2, 3, 5, 7, 11];\x3cbr\x3evar leeresArray \x3d [];\x3cbr\x3evar a \x3d "Douglas";\x3cbr\x3evar b \x3d 12;\x3cbr\x3evar c \x3d true;\x3cbr\x3evar allesMoegliche \x3d [a, b, c];\x3c/code\x3e\x3c/pre\x3eDie Elemente eines Arrays k\u00f6nnen, wie das letzte Beispiel zeigt, alle einen anderen Datentyp besitzen.',
task:"Schreibe eine Funktion \x3ccode\x3etoArray\x3c/code\x3e, die 2 Paramter entgegennimmt und diese als Array zur\u00fcckgibt. \x3ccode\x3etoArray(5, 9)\x3c/code\x3e sollte das Array \x3ccode\x3e[5, 9]\x3c/code\x3e ergeben.",beforeTests:function(){"undefined"!==typeof toArray&&(toArray=void 0)},tests:[function(){var a="function"===typeof toArray;return{ok:a,msg:a?"\x3ccode\x3etoArray\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3etoArray\x3c/code\x3e ist keine Funktion."}},function(){var a=2===toArray.length;
return{ok:a,msg:a?"\x3ccode\x3etoArray\x3c/code\x3e hat 2 Parameter.":"\x3ccode\x3etoArray\x3c/code\x3e hat nicht 2, sondern "+toArray.length+" Parameter."}},function(){var a,b,d;try{var c=toArray(1,2);b=(a=Array.isArray(c))?"\x3ccode\x3etoArray(1, 2)\x3c/code\x3e gibt ein Array zur\u00fcck.":"\x3ccode\x3etoArray(1, 2)\x3c/code\x3e gibt kein Array zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3etoArray(1, 2)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=
toArray(1,2);b=(a=2===c.length&&1===c[0]&&2===c[1])?"\x3ccode\x3etoArray(1, 2)\x3c/code\x3e gibt \x3ccode\x3e[1, 2]\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3etoArray(1, 2)\x3c/code\x3e gibt nicht \x3ccode\x3e[1, 2]\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3etoArray(1, 2)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=toArray("H\u00e4nsel","Gretel");b=(a=Array.isArray(c)&&2===c.length&&
"H\u00e4nsel"===c[0]&&"Gretel"===c[1])?'\x3ccode\x3etoArray("H\u00e4nsel", "Gretel")\x3c/code\x3e gibt \x3ccode\x3e["H\u00e4nsel", "Gretel"]\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3etoArray("H\u00e4nsel", "Gretel")\x3c/code\x3e gibt nicht \x3ccode\x3e["H\u00e4nsel", "Gretel"]\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von toArray("H\u00e4nsel", "Gretel")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"array2",title:"Array-Elemente ansprechen",lesson:'Die Elemente eines Arrays werden mit einem Index beginnend mit 0 angesprochen. \x3cpre\x3e\x3ccode\x3evar sprachen \x3d ["C", "C++", "Java", "JavaScript"];\x3cbr\x3evar c \x3d sprachen[0];\x3cbr\x3evar cPlusPlus \x3d sprachen[1];\x3cbr\x3evar java \x3d sprachen[2];\x3cbr\x3evar javaScript \x3d sprachen[3];',task:"Schreibe eine Funktion \x3ccode\x3egetFirstElement\x3c/code\x3e, die ein Array entgegennimmt und die das erste Element des Arrays zur\u00fcckgibt. \x3ccode\x3egetFirstElement([1, 2])\x3c/code\x3e sollte \x3ccode\x3e1\x3c/code\x3e zur\u00fcckgeben.",
beforeTests:function(){"undefined"!==typeof getFirstElement&&(getFirstElement=void 0)},tests:[function(){var a="function"===typeof getFirstElement;return{ok:a,msg:a?"\x3ccode\x3egetFirstElement\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3egetFirstElement\x3c/code\x3e ist keine Funktion."}},function(){var a=1===getFirstElement.length;return{ok:a,msg:a?"\x3ccode\x3egetFirstElement\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3egetFirstElement\x3c/code\x3e hat nicht 1, sondern "+getFirstElement.length+
" Parameter."}},function(){var a,b,d;try{var c=getFirstElement([1,2]);b=(a=1===c)?"\x3ccode\x3egetFirstElement([1, 2])\x3c/code\x3e gibt \x3ccode\x3e1\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3egetFirstElement([1, 2])\x3c/code\x3e gibt nicht \x3ccode\x3e1\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3egetFirstElement([1, 2])\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=getFirstElement(["H\u00e4nsel",
"Gretel"]);b=(a="H\u00e4nsel"===c)?'\x3ccode\x3egetFirstElement(["H\u00e4nsel", "Gretel"])\x3c/code\x3e gibt \x3ccode\x3e"H\u00e4nsel"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3egetFirstElement(["H\u00e4nsel", "Gretel"])\x3c/code\x3e gibt nicht \x3ccode\x3e"H\u00e4nsel"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3egetFirstElement(["H\u00e4nsel", "Gretel"])\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"array3",title:"Array-Elemente setzen",lesson:'Ebenso wie man Array-Elemente \u00fcber einen Index auslesen kann, kann man sie \u00fcber diesen Index setzen. Dabei spielt es keine Rolle, ob das Array vorher gef\u00fcllt oder leer war.\x3cpre\x3e\x3ccode\x3evar sprachen \x3d [];\x3cbr\x3esprachen[0] \x3d "C";\x3cbr\x3esprachen[1] \x3d "C++";\x3cbr\x3esprachen[2] \x3d "Java";\x3cbr\x3esprachen[3] \x3d "JavaScript";\x3c/code\x3e\x3c/pre\x3eHier wird ein leeres Array nacheinander mit den aufgef\u00fchrten Werten gef\u00fcllt.',
task:"Schreibe eine Funktion \x3ccode\x3esetFirstElement\x3c/code\x3e, die ein Array und eine beliebige Variable entgegennimmt. Die Variable soll als erstes Element in das Array geschrieben werden. Das Array soll dann zur\u00fcckgegeben werden. \x3ccode\x3esetFirstElement([1, 2], 3)\x3c/code\x3e sollte \x3ccode\x3e[3, 2]\x3c/code\x3e zur\u00fcckgeben.",beforeTests:function(){"undefined"!==typeof setFirstElement&&(setFirstElement=void 0)},tests:[function(){var a="function"===typeof setFirstElement;
return{ok:a,msg:a?"\x3ccode\x3esetFirstElement\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3esetFirstElement\x3c/code\x3e ist keine Funktion."}},function(){var a=2===setFirstElement.length;return{ok:a,msg:a?"\x3ccode\x3esetFirstElement\x3c/code\x3e hat 2 Parameter.":"\x3ccode\x3esetFirstElement\x3c/code\x3e hat nicht 2, sondern "+setFirstElement.length+" Parameter."}},function(){var a,b,d;try{var c=setFirstElement([1,2],3);b=(a=Array.isArray(c)&&2===c.length&&3===c[0]&&2===c[1])?"\x3ccode\x3esetFirstElement([1, 2], 3)\x3c/code\x3e gibt \x3ccode\x3e[3, 2]\x3c/code\x3e zur\u00fcck.":
"\x3ccode\x3esetFirstElement([1, 2], 3)\x3c/code\x3e gibt nicht \x3ccode\x3e[3, 2]\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3esetFirstElement([1, 2], 3)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=setFirstElement([],1);b=(a=Array.isArray(c)&&1===c.length&&1===c[0])?"\x3ccode\x3esetFirstElement([], 1)\x3c/code\x3e gibt \x3ccode\x3e[1]\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3esetFirstElement([], 1)\x3c/code\x3e gibt nicht \x3ccode\x3e[1]\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){d=e,a=!1,b="Fehler beim Aufruf von \x3ccode\x3esetFirstElement([], 1)\x3c/code\x3e."}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"arraylength",title:"Array: length",lesson:'Die Eigenschaft \x3ccode\x3elength\x3c/code\x3e hatten wird schon bei Strings kennengelernt. Dort gab sie die Anzahl der Zeichen eines Strings zur\u00fcck. Bei Arrays gibt sie die Anzahl der Elemente zur\u00fcck. \x3cpre\x3e\x3ccode\x3evar sprachen \x3d [];\x3cbr\x3evar l0 \x3d sprachen.length;\x3cbr\x3esprachen[0] \x3d "C";\x3cbr\x3evar l1 \x3d sprachen.length;\x3cbr\x3esprachen[1] \x3d "C++";\x3cbr\x3evar l2 \x3d sprachen.length;\x3c/code\x3e\x3c/pre\x3eDas leere Array zu Anfang enth\u00e4llt keine Elemente. \x3ccode\x3el0\x3c/code\x3e ist also \x3ccode\x3e0\x3c/code\x3e. Nun f\u00fcllen wir das Array nach und nach. \x3ccode\x3el1\x3c/code\x3e und \x3ccode\x3el2\x3c/code\x3e haben dann die Werte \x3ccode\x3e1\x3c/code\x3e und \x3ccode\x3e2\x3c/code\x3e. Beachte: Die L\u00e4nge eines Arrays ist immer um 1 gr\u00f6\u00dfer als der h\u00f6chste Index des Arrays.',task:"Schreibe eine Funktion \x3ccode\x3egetLastElement\x3c/code\x3e, die ein Array entgegennimmt und die das letzte Element des Arrays zur\u00fcckgibt. \x3ccode\x3egetLastElement([1, 2])\x3c/code\x3e sollte \x3ccode\x3e2\x3c/code\x3e zur\u00fcckgeben.",
beforeTests:function(){"undefined"!==typeof setFirstElement&&(setFirstElement=void 0)},tests:[function(){var a="function"===typeof getLastElement;return{ok:a,msg:a?"\x3ccode\x3egetLastElement\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3egetLastElement\x3c/code\x3e ist keine Funktion."}},function(){var a=1===getLastElement.length;return{ok:a,msg:a?"\x3ccode\x3egetLastElement\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3egetLastElement\x3c/code\x3e hat nicht 1, sondern "+getLastElement.length+" Parameter."}},
function(){var a,b,d;try{var c=getLastElement([1,2]);b=(a=2===c)?"\x3ccode\x3egetLastElement([1, 2])\x3c/code\x3e gibt \x3ccode\x3e2\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3egetLastElement([1, 2])\x3c/code\x3e gibt nicht \x3ccode\x3e2\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3egetLastElement([1, 2])\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=getLastElement(["a","b","c"]);b=(a=
"c"===c)?'\x3ccode\x3egetLastElement(["a", "b", "c"])\x3c/code\x3e gibt \x3ccode\x3e"c"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3egetLastElement(["a", "b", "c"])\x3c/code\x3e gibt nicht \x3ccode\x3e"c"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3egetLastElement(["a", "b", "c"])\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
jshero.koans.add({id:"arraysort",title:"Arrays sortieren",lesson:"Wir k\u00f6nnen jetzt Arrays mit vorgegebener L\u00e4nge sortieren.",task:"Schreibe eine Funktion \x3ccode\x3esortiere\x3c/code\x3e, die ein mit 3 Zahlen gef\u00fclltes Array entgegennimmt und die diese 3 Zahlen aufsteigend sortiert als Array  zur\u00fcckgibt. \x3ccode\x3esortiere([2,\x26nbsp;3,\x26nbsp;1])\x3c/code\x3e sollte \x3ccode\x3e[1,\x26nbsp;2,\x26nbsp;3]\x3c/code\x3e ergeben.",beforeTests:function(){"undefined"!==typeof sortiere&&
(sortieren=void 0)},tests:[function(){var a="function"===typeof sortiere;return{ok:a,msg:a?"\x3ccode\x3esortiere\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3esortiere\x3c/code\x3e ist keine Funktion."}},function(){var a=1===sortiere.length;return{ok:a,msg:a?"\x3ccode\x3esortiere\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3esortiere\x3c/code\x3e hat nicht 1, sondern "+sortiere.length+" Parameter."}},function(){var a,b,d;try{var c=sortiere([3,2,1]);b=(a=Array.isArray(c)&&3===c.length&&1===c[0]&&2===
c[1]&&3===c[2])?"\x3ccode\x3esortiere([3, 2, 1])\x3c/code\x3e gibt \x3ccode\x3e[1, 2, 3]\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3esortiere([3, 2, 1])\x3c/code\x3e gibt nicht \x3ccode\x3e[1, 2, 3]\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3esortiere([3, 2, 1])\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=sortiere([2,3,1]);b=(a=Array.isArray(c)&&3===c.length&&1===c[0]&&2===c[1]&&3===
c[2])?"\x3ccode\x3esortiere([2, 3, 1])\x3c/code\x3e gibt \x3ccode\x3e[1, 2, 3]\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3esortiere([2, 3, 1])\x3c/code\x3e gibt nicht \x3ccode\x3e[1, 2, 3]\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3esortiere([2, 3, 1])\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
(function(a){jshero.koans.add({id:"arraypush",title:"Array: shift() und push()",lesson:'Arrays besitzen eine Reihe von Methoden. Zwei dieser Methoden sind \x3ccode\x3eshift\x3c/code\x3e und \x3ccode\x3epush\x3c/code\x3e. Zur Erinnerung: Methoden sind Funktionen, die auf einem Objekt, hier einem Array, ausgef\u00fchrt werden. Methoden werden mit einem Punkt an das Objekt angeh\u00e4ngt. Wie bei Funktionen \u00fcblich folgt dem Methodennamen die runden Klammern, ggf. gef\u00fcllt mit Parametern. \x3ccode\x3eshift\x3c/code\x3e hat keine Parameter und verschiebt die Elemente eines Arrays nach links. Das 1te Element wird zum 0ten, das 2te zum 1ten, das 3te zum 2ten, usw. Das 0te Element wird aus dem Array entfernt und zur\u00fcckgegeben. Nach dem \x3ccode\x3eshift\x3c/code\x3e hat das Array ein Element weniger.\x3cpre\x3e\x3ccode\x3evar sprachen \x3d ["C", "Java", "JavaScript"];\x3cbr\x3evar naechsteSprache \x3d sprachen.shift();\x3c/code\x3e\x3c/pre\x3eDas Array \x3ccode\x3esprachen\x3c/code\x3e wird mit 3 Programmiersprachen angelegt. Nach dem \x3ccode\x3eshift\x3c/code\x3e enth\u00e4lt \x3ccode\x3esprachen\x3c/code\x3e nur noch 2 Elemente, n\u00e4mlich \x3ccode\x3e["Java", "JavaScript"]\x3c/code\x3e. Der Wert \x3ccode\x3e"C"\x3c/code\x3e ist in der Variablen \x3ccode\x3enaechsteSprache\x3c/code\x3e gelandet.\x3cbr\x3eMit der h\u00e4ufig verwendeten Methode \x3ccode\x3epush\x3c/code\x3e f\u00fcgt man dem Array ein neues Element hinzu. Das neue Element wird als Parameter \u00fcbergeben und an das Ende des Arrays geh\u00e4ngt.\x3cpre\x3e\x3ccode\x3evar sprachen \x3d [];\x3cbr\x3esprachen.push("C");\x3cbr\x3esprachen.push("Java");\x3cbr\x3esprachen.push("JavaScript");\x3c/code\x3e\x3c/pre\x3eHier wird ein leeres Array nacheinander mit den aufgef\u00fchrten Werten gef\u00fcllt. Am Ende erhalten wir das Array \x3ccode\x3e["C", "Java", "JavaScript"]\x3c/code\x3e. Wir hatten gesehen, dass man ein Array auch per Index f\u00fcllen kann. \x3ccode\x3esprachen[sprachen.length] \x3d "PHP"\x3c/code\x3e ist dasselbe wie \x3ccode\x3esprachen.push("PHP")\x3c/code\x3e. Doch schon an der L\u00e4nge des Codes sieht man, dass die Variante mit \x3ccode\x3epush\x3c/code\x3e eleganter ist.',task:'Schreibe eine Funktion \x3ccode\x3erotiere\x3c/code\x3e, die die Elemente eines Arrays rotiert. Alle Elemente des Arrays sollen um eine Position nach links verschoben werden. Das 0te Element soll ans Ende des Arrays gestellt werden. Das rotierte Array soll zur\u00fcckgegeben werden. \x3ccode\x3erotiere(["a", "b", "c"])\x3c/code\x3e sollte \x3ccode\x3e["b", "c", "a"]\x3c/code\x3e ergeben.',
beforeTests:function(){"undefined"!==typeof rotiere&&(rotiere=void 0)},tests:[function(){var a="function"===typeof rotiere;return{ok:a,msg:a?"\x3ccode\x3erotiere\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3erotiere\x3c/code\x3e ist keine Funktion."}},function(){var a=1===rotiere.length;return{ok:a,msg:a?"\x3ccode\x3erotiere\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3erotiere\x3c/code\x3e hat nicht 1, sondern "+rotiere.length+" Parameter."}},function(){var b,d,c;try{var e=rotiere([1,2]);d=(b=a.isEqual(e,
[2,1]))?"\x3ccode\x3erotiere([1, 2])\x3c/code\x3e gibt \x3ccode\x3e[2, 1]\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3erotiere([1, 2])\x3c/code\x3e gibt nicht \x3ccode\x3e[2, 1]\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(e)+"\x3c/code\x3e zur\u00fcck."}catch(f){b=!1,d="Fehler beim Aufruf von \x3ccode\x3erotiere([1, 2])\x3c/code\x3e.",c=f}return{ok:b,msg:d,e:c}},function(){var b,d,c;try{var e=rotiere(["a","b","c"]);d=(b=a.isEqual(e,["b","c","a"]))?'\x3ccode\x3erotiere(["a", "b", "c"])\x3c/code\x3e gibt \x3ccode\x3e["b", "c", "a"]\x3c/code\x3e zur\u00fcck.':
'\x3ccode\x3erotiere(["a", "b", "c"])\x3c/code\x3e gibt nicht \x3ccode\x3e["b", "c", "a"]\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(e)+"\x3c/code\x3e zur\u00fcck."}catch(f){b=!1,d='Fehler beim Aufruf von \x3ccode\x3erotiere(["a", "b", "c"])\x3c/code\x3e.',c=f}return{ok:b,msg:d,e:c}}]})})(jshero.array);
(function(){jshero.koans.add({id:"for",title:"for - Schleife",lesson:"Mit Schleifen k\u00f6nnen Code-Abschnitte mehrmals durchlaufen werden. JavaScript kennt mehrere Schleifenarten. Die einfachste ist die \x3ccode\x3efor\x3c/code\x3e-Schleife.\x3cpre\x3e\x3ccode\x3evar summe \x3d 0;\x3cbr\x3efor (var i \x3d 1; i \x3c 3; i++) {\x3cbr\x3e  summe \x3d summe + i;\x3cbr\x3e}\x3c/code\x3e\x3c/pre\x3eDie \x3ccode\x3efor\x3c/code\x3e-Schleife besteht aus drei Steuer-Anweisungen und dem Schleifen-Code. Die drei Anweisungen folgen dem \x3ccode\x3efor\x3c/code\x3e in runden Klammern. Sie werden durch Semikolons voneinander getrennt. Die erste Anweisung ist die Start-Anweisung. Sie wird einmal zu Beginn der Schleife ausgef\u00fchrt. Hier wird normalerweise eine Variable, die sogenannte Schleifenvariable, initialisiert. Die zweite Anweisung ist die Schleifen-Bedingung. Sie wird vor jedem Schleifendurchlauf zu \x3ccode\x3etrue\x3c/code\x3e oder \x3ccode\x3efalse\x3c/code\x3e ausgewertet. Ist der Ausdruck \x3ccode\x3etrue\x3c/code\x3e, wird der Schleifen-Code ausgef\u00fchrt. Ist er \x3ccode\x3efalse\x3c/code\x3e, wird die Schleife beendet und die Programmausf\u00fchrung wird nach der Schleife fortgesetzt. Nach jedem Schleifen-Durchlauf wird die dritte Anweisung, die sogenannten End-Anweisung, ausgef\u00fchrt. Hier wird normalerweise die Schleifenvariable erh\u00f6ht. Anschlie\u00dfend beginnt ein neuer Schleifendurchlauf mit erneuter Auswertung der Schleifen-Bedingung. Der Schleifen-Code folgt in Mengenklammern den drei Steueranweisungen.\x3cbr\x3eIn unserem Beispiel hat \x3ccode\x3esumme\x3c/code\x3e zun\u00e4chst den Wert \x3ccode\x3e0\x3c/code\x3e. In der Start-Anweisung wird \x3ccode\x3ei\x3c/code\x3e mit \x3ccode\x3e1\x3c/code\x3e initialisiert. Die Schleifenbedingung \x3ccode\x3e1 \x3c 3\x3c/code\x3e ist erf\u00fcllt, also wird der Schleifen-Code ausgef\u00fchrt. \x3ccode\x3esumme\x3c/code\x3e erh\u00e4lt den Wert \x3ccode\x3e0 + 1\x3c/code\x3e, also \x3ccode\x3e1\x3c/code\x3e. Nun wird in der End-Anweisung \x3ccode\x3ei\x3c/code\x3e um \x3ccode\x3e1\x3c/code\x3e erh\u00f6ht (\x3ccode\x3ei++\x3c/code\x3e ist identisch mit \x3ccode\x3ei \x3d i + 1\x3c/code\x3e). Es erh\u00e4llt also den Wert \x3ccode\x3e2\x3c/code\x3e. Der zweite Schleifendurchlauf startet mit Auswertung der Schleifenbedingung. Diese Bedingung (\x3ccode\x3e2 \x3c 3\x3c/code\x3e) ist immer noch erf\u00fcllt. Der Schleifen-Code wird erneut ausgef\u00fchrt und \x3ccode\x3esumme\x3c/code\x3e erh\u00e4lt jetzt den Wert \x3ccode\x3e1 + 2\x3c/code\x3e, also \x3ccode\x3e3\x3c/code\x3e. \x3ccode\x3ei\x3c/code\x3e wird abermals erh\u00f6ht und hat nun den Wert \x3ccode\x3e3\x3c/code\x3e. Die Schleifenbedingung \x3ccode\x3e3 \x3c 3\x3c/code\x3e ist jetzt nicht mehr erf\u00fcllt. Die Schleife wird beendet und die Programmausf\u00fchrung wird nach der Schleife fortgesetzt. Unser Codebespiel hat also alle nat\u00fcrlichen Zahlen echt kleiner 3 addiert.",task:"Schreibe eine Funktion \x3ccode\x3eaddiereBis\x3c/code\x3e, die eine Zahl als Parameter entgegennimmt und die alle nat\u00fcrlichen Zahlen echt kleiner dem Paramter aufaddiert. Das Ergebnis der Addition soll zur\u00fcckgegeben werden. \x3ccode\x3eaddiereBis(4)\x3c/code\x3e sollte \x3ccode\x3e6\x3c/code\x3e ergeben.",
beforeTests:function(){"undefined"!==typeof addiereBis&&(rotiere=void 0)},tests:[function(){var a="function"===typeof addiereBis;return{ok:a,msg:a?"\x3ccode\x3eaddiereBis\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eaddiereBis\x3c/code\x3e ist keine Funktion."}},function(){var a=1===addiereBis.length;return{ok:a,msg:a?"\x3ccode\x3eaddiereBis\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3eaddiereBis\x3c/code\x3e hat nicht 1, sondern "+addiereBis.length+" Parameter."}},function(){var a,b,d;try{var c=
addiereBis(2);b=(a=1===c)?"\x3ccode\x3eaddiereBis(2)\x3c/code\x3e gibt \x3ccode\x3e1\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3eaddiereBis(2)\x3c/code\x3e gibt nicht \x3ccode\x3e1\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eaddiereBis(2)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=addiereBis(4);b=(a=6===c)?"\x3ccode\x3eaddiereBis(4)\x3c/code\x3e gibt \x3ccode\x3e6\x3c/code\x3e zur\u00fcck.":
"\x3ccode\x3eaddiereBis(4)\x3c/code\x3e gibt nicht \x3ccode\x3e6\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eaddiereBis(4)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]})})();
(function(){jshero.koans.add({id:"for2",title:"Schleifen und Arrays",lesson:"\x3ccode\x3efor\x3c/code\x3e-Schleifen eignen sich besonders gut zum Durchlaufen von Arrays. Die folgende Funktion gibt das gr\u00f6\u00dfte Element eines Arrays zur\u00fcck:\x3cpre\x3e\x3ccode\x3efunction max(a) {\x3cbr\x3e  var maximum \x3d a[0];\x3cbr\x3e  for (var i \x3d 1; i \x3c a.length; i++) {\x3cbr\x3e    if (a[i] \x3e maximum) {\x3cbr\x3e      maximum \x3d a[i];\x3cbr\x3e    }\x3cbr\x3e  }\x3cbr\x3e  return maximum;\x3cbr\x3e}\x3c/code\x3e\x3c/pre\x3e",task:"Schreibe eine Funktion \x3ccode\x3emean\x3c/code\x3e, die ein Array gef\u00fcllt mit Zahlen entgegennimmt und den Mittelwert dieser Zahlen zur\u00fcckgibt. Tipp: Um den Mittelwert von n Zahlen zu berechnen, mu\u00dft du die Zahlen aufaddieren und die erhaltene Summe durch n teilen. \x3ccode\x3emean([1, 4])\x3c/code\x3e sollte \x3ccode\x3e(1 + 4)/2 \x3d 2.5\x3c/code\x3e ergeben.",
beforeTests:function(){"undefined"!==typeof mean&&(mean=void 0)},tests:[function(){var a="function"===typeof mean;return{ok:a,msg:a?"\x3ccode\x3emean\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3emean\x3c/code\x3e ist keine Funktion."}},function(){var a=1===mean.length;return{ok:a,msg:a?"\x3ccode\x3emean\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3emean\x3c/code\x3e hat nicht 1, sondern "+mean.length+" Parameter."}},function(){var a,b,d;try{var c=mean([0]);b=(a=0===c)?"\x3ccode\x3emean([0])\x3c/code\x3e gibt \x3ccode\x3e0\x3c/code\x3e zur\u00fcck.":
"\x3ccode\x3emean([0])\x3c/code\x3e gibt nicht \x3ccode\x3e0\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3emean([0])\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=mean([1,2]);b=(a=1.5===c)?"\x3ccode\x3emean([1, 2])\x3c/code\x3e gibt \x3ccode\x3e1.5\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3emean([1, 2])\x3c/code\x3e gibt nicht \x3ccode\x3e1.5\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+
"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3emean([1, 2])\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=mean([1,4,10,85]);b=(a=25===c)?"\x3ccode\x3emean([1, 4, 10, 85])\x3c/code\x3e gibt \x3ccode\x3e25\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3emean([1, 4, 10, 85])\x3c/code\x3e gibt nicht \x3ccode\x3e25\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3emean([1, 4, 10, 85])\x3c/code\x3e.",
d=e}return{ok:a,msg:b,e:d}}]})})();
(function(){jshero.koans.add({id:"while",title:"while - Schleife",lesson:'Die \x3ccode\x3ewhile\x3c/code\x3e-Schleife besitzt nur eine Schleifen-Bedingung. Der Schleifen-Code wird ausgef\u00fchrt, solange die Bedingung \x3ccode\x3etrue\x3c/code\x3e ergibt. Ergibt die Bedingung \x3ccode\x3efalse\x3c/code\x3e, wird die Schleife beendet und die Codeausf\u00fchrung wird nach der Schleife fortgesetzt.\x3cpre\x3e\x3ccode\x3evar space \x3d "";\x3cbr\x3ewhile (space.length \x3c 3) {\x3cbr\x3e  space \x3d space + "x";\x3cbr\x3e}\x3c/code\x3e\x3c/pre\x3eSolange \x3ccode\x3espace\x3c/code\x3e weniger als 3 Zeichen besitzt, wird es um \x3ccode\x3e"x"\x3c/code\x3e erg\u00e4nzt. Hat \x3ccode\x3espace\x3c/code\x3e die L\u00e4nge 3, wird die Schleife beendet. \x3ccode\x3espace\x3c/code\x3e hat dann den Wert \x3ccode\x3e"xxx"\x3c/code\x3e.',task:'Schreibe eine Funktion \x3ccode\x3eabstand\x3c/code\x3e, die eine nat\u00fcrliche Zahl n als Parameter entgegennimmt und die einen String bestehend aus n Leerzeichen zur\u00fcckgibt. \x3ccode\x3eabstand(1)\x3c/code\x3e sollte \x3ccode\x3e" "\x3c/code\x3e ergeben.',
beforeTests:function(){"undefined"!==typeof abstand&&(abstand=void 0)},tests:[function(){var a="function"===typeof abstand;return{ok:a,msg:a?"\x3ccode\x3eabstand\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eabstand\x3c/code\x3e ist keine Funktion."}},function(){var a=1===abstand.length;return{ok:a,msg:a?"\x3ccode\x3eabstand\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3eabstand\x3c/code\x3e hat nicht 1, sondern "+abstand.length+" Parameter."}},function(){var a,b,d;try{var c=abstand(0);b=(a=""===c)?
'\x3ccode\x3eabstand(0)\x3c/code\x3e gibt \x3ccode\x3e""\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3eabstand(0)\x3c/code\x3e gibt nicht \x3ccode\x3e""\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eabstand(0)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=abstand(2);b=(a="  "===c)?'\x3ccode\x3eabstand(2)\x3c/code\x3e gibt \x3ccode\x3e"\x26nbsp;\x26nbsp;"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3eabstand(2)\x3c/code\x3e gibt nicht \x3ccode\x3e"\x26nbsp;\x26nbsp;"\x3c/code\x3e, sondern \x3ccode\x3e'+
JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eabstand(2)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]})})();
(function(){jshero.koans.add({id:"dowhile",title:"do...while - Schleife",lesson:"Die \x3ccode\x3edo...while\x3c/code\x3e-Schleife funktioniert \u00e4hnlich wie die \x3ccode\x3ewhile\x3c/code\x3e-Schleife. Der Schleifen-Code wird ausgef\u00fchrt, solange die Schleifenbedingung \x3ccode\x3etrue\x3c/code\x3e ergibt. Einziger Unterschied ist, dass die Schleifenbedingung nach dem Schleifen-Code \u00fcberpr\u00fcft wird. Dadurch ist sichergestellt, dass der Schleifen-Code mindestens einmal durchlaufen wird.\x3cpre\x3e\x3ccode\x3evar restDurch6;\x3cbr\x3evar restDurch8;\x3cbr\x3evar kgV \x3d 0;\x3cbr\x3edo {\x3cbr\x3e  kgV++;\x3cbr\x3e  restDurch6 \x3d kgV % 6;\x3cbr\x3e  restDurch8 \x3d kgV % 8;\x3cbr\x3e} while (restDurch6 !\x3d\x3d 0 || restDurch8 !\x3d\x3d 0)\x3c/code\x3e\x3c/pre\x3eDieser Codeabschnitt berechnet das kleinste gemeinsame Vielfache (kgV) von 6 und 8. Das kgV ist die kleinste Zahl, die sowohl ein Vielfaches von 6 als auch ein Vielfaches von 8 ist. Die Vielfachen von 6 sind 6, 12, 18, 24, 30, ... und die Vielfachen von 8 sind 8, 16, 24, 32, ... . Damit ist das kgV von 6 und 8 die Zahl 24.\x3cbr\x3eUnser Codebeispiel pr\u00fcft beginnend mit \x3ccode\x3e1\x3c/code\x3e, ob \x3ccode\x3ekgV\x3c/code\x3e sowohl durch \x3ccode\x3e6\x3c/code\x3e als auch durch \x3ccode\x3e8\x3c/code\x3e teilbar ist. Die Teilbarkeit wird mithilfe des Modulo-Operators \u00fcberpr\u00fcft. Eine Zahl ist durch 6 bzw. 8 teilbar, wenn sie Modulo 6 bzw. Modulo 8 den Wert 0 liefert. Die Modulo-Berechnung findet im Schleifen-Code statt. In der Schleifenbedingung wird dann \u00fcberpr\u00fcft, ob beide Modulo-Berechnungen \x3ccode\x3e0\x3c/code\x3e ergeben. Ist eine von beiden Modulo-Berechnungen nicht \x3ccode\x3e0\x3c/code\x3e, ist die Schleifenbedingung \x3ccode\x3etrue\x3c/code\x3e und der Schleifen-Code wird mit einem um 1 erh\u00f6hten \x3ccode\x3ekgV\x3c/code\x3e erneut durchlaufen. Ergeben beide Modulo-Berechnungen \x3ccode\x3e0\x3c/code\x3e, ist die Schleifenbedingung \x3ccode\x3efalse\x3c/code\x3e und die Schleife wird beendet. \x3ccode\x3ekgV\x3c/code\x3e hat dann den gew\u00fcnschten Wert (n\u00e4mlich 24), da es die erste Zahl ist, die sowohl durch 6 als auch durch 8 teilbar ist.",task:"Schreibe eine Funktion \x3ccode\x3ekgV\x3c/code\x3e, die zwei nat\u00fcrliche Zahlen als Parameter entgegennimmt und deren kgV berechnet. \x3ccode\x3ekgV(6, 8)\x3c/code\x3e sollte \x3ccode\x3e24\x3c/code\x3e zur\u00fcckgeben.",
beforeTests:function(){"undefined"!==typeof kgV&&(kgV=void 0)},tests:[function(){var a="function"===typeof kgV;return{ok:a,msg:a?"\x3ccode\x3ekgV\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3ekgV\x3c/code\x3e ist keine Funktion."}},function(){var a=2===kgV.length;return{ok:a,msg:a?"\x3ccode\x3ekgV\x3c/code\x3e hat 2 Parameter.":"\x3ccode\x3ekgV\x3c/code\x3e hat nicht 2, sondern "+kgV.length+" Parameter."}},function(){var a,b,d;try{var c=kgV(6,8);b=(a=24===c)?"\x3ccode\x3ekgV(6, 8)\x3c/code\x3e gibt \x3ccode\x3e24\x3c/code\x3e zur\u00fcck.":
"\x3ccode\x3ekgV(6, 8)\x3c/code\x3e gibt nicht \x3ccode\x3e24\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3ekgV(6, 8)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=kgV(5,7);b=(a=35===c)?"\x3ccode\x3ekgV(5, 7)\x3c/code\x3e gibt \x3ccode\x3e35\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3ekgV(5, 7)\x3c/code\x3e gibt nicht \x3ccode\x3e35\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+
"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3ekgV(5, 7)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]})})();
(function(){jshero.koans.add({id:"ggt",title:"ggT",lesson:"Das Gegenst\u00fcck zum kleinsten gemeinsamen Vielfachen ist der gr\u00f6\u00dfte gemeinsamer Teiler (ggT). Der gr\u00f6\u00dfte gemeinsame Teiler zweier Zahlen a und b ist die gr\u00f6\u00dfte Zahl, durch die sich sowohl a als auch b teilen l\u00e4\u00dft.",task:"Schreibe eine Funktion \x3ccode\x3eggT\x3c/code\x3e, die zwei nat\u00fcrliche Zahlen als Parameter entgegennimmt und deren ggT berechnet. \x3ccode\x3eggT(6, 15)\x3c/code\x3e sollte \x3ccode\x3e3\x3c/code\x3e zur\u00fcckgeben.",beforeTests:function(){"undefined"!==
typeof ggT&&(ggT=void 0)},tests:[function(){var a="function"===typeof ggT;return{ok:a,msg:a?"\x3ccode\x3eggT\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eggT\x3c/code\x3e ist keine Funktion."}},function(){var a=2===ggT.length;return{ok:a,msg:a?"\x3ccode\x3eggT\x3c/code\x3e hat 2 Parameter.":"\x3ccode\x3eggT\x3c/code\x3e hat nicht 2, sondern "+ggT.length+" Parameter."}},function(){var a,b,d;try{var c=ggT(6,15);b=(a=3===c)?"\x3ccode\x3eggT(6, 15)\x3c/code\x3e gibt \x3ccode\x3e3\x3c/code\x3e zur\u00fcck.":
"\x3ccode\x3eggT(6, 15)\x3c/code\x3e gibt nicht \x3ccode\x3e3\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eggT(6, 15)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=ggT(5,7);b=(a=1===c)?"\x3ccode\x3eggT(5, 7)\x3c/code\x3e gibt \x3ccode\x3e1\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3eggT(5, 7)\x3c/code\x3e gibt nicht \x3ccode\x3e1\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=
!1,b="Fehler beim Aufruf von \x3ccode\x3eggT(5, 7)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=ggT(7,5);b=(a=1===c)?"\x3ccode\x3eggT(7, 5)\x3c/code\x3e gibt \x3ccode\x3e1\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3eggT(7, 5)\x3c/code\x3e gibt nicht \x3ccode\x3e1\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eggT(7, 5)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=
ggT(2,4);b=(a=2===c)?"\x3ccode\x3eggT(2, 4)\x3c/code\x3e gibt \x3ccode\x3e2\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3eggT(2, 4)\x3c/code\x3e gibt nicht \x3ccode\x3e2\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eggT(2, 4)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=ggT(4,2);b=(a=2===c)?"\x3ccode\x3eggT(4, 2)\x3c/code\x3e gibt \x3ccode\x3e2\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3eggT(4, 2)\x3c/code\x3e gibt nicht \x3ccode\x3e2\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eggT(4, 2)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]})})();
jshero.koans.add({id:"break",title:"break und continue",lesson:'Mit \x3ccode\x3ebreak\x3c/code\x3e wird eine Schleife beendet. Das Programm wird nach der Schleife fortgesetzt. \x3cpre\x3e\x3ccode\x3evar satz \x3d "So ist das.";\x3cbr\x3evar i;\x3cbr\x3efor (i \x3d 0; i \x3c satz.length; i++) {\x3cbr\x3e  if (satz.charAt(i) \x3d\x3d\x3d " ") {\x3cbr\x3e    break;\x3cbr\x3e  }\x3cbr\x3e}\x3cbr\x3evar laengeErstesWort \x3d i;\x3c/code\x3e\x3c/pre\x3eIst das Zeichen mit dem Index \x3ccode\x3ei\x3c/code\x3e in \x3ccode\x3esatz\x3c/code\x3e das Leerzeichen, ist die \x3ccode\x3eif\x3c/code\x3e-Bedingung erf\u00fcllt und der \x3ccode\x3ebreak\x3c/code\x3e-Befehl wird ausgef\u00fchrt. Die Schleife wird beendet und die Codeausf\u00fchrung wird nach der Schleife fortgesetzt. In unserem Beispiel ist das Zeichen mit dem Index \x3ccode\x3e2\x3c/code\x3e das Leerzeichen. Sobald die Schleifenvariable \x3ccode\x3ei\x3c/code\x3e den Wert \x3ccode\x3e2\x3c/code\x3e erreicht hat, wird die Schleife beendet. \x3ccode\x3elaengeErstesWort\x3c/code\x3e bekommt dann den Wert \x3ccode\x3e2\x3c/code\x3e zugewiesen.\x3cbr\x3e\x3cbr\x3eMit \x3ccode\x3econtinue\x3c/code\x3e wird der aktuelle Schleifendurchlauf beendet. Die Programmausf\u00fchrung springt zum Schleifenkopf.\x3cpre\x3e\x3ccode\x3evar summe \x3d 0;\x3cbr\x3efor (var i \x3d 0; i \x3c 10; i++) {\x3cbr\x3e  if (i % 2 \x3d\x3d\x3d 0) {\x3cbr\x3e    continue;\x3cbr\x3e  }\x3cbr\x3e  summe \x3d summe + i;\x3cbr\x3e}\x3cbr\x3e\x3c/code\x3e\x3c/pre\x3eIst \x3ccode\x3ei\x3c/code\x3e eine ungerade Zahl, so gilt: i modulo 2 \x3d 1. Die \x3ccode\x3eif\x3c/code\x3e - Bedingung ist nicht erf\u00fcllt. Die Codeausf\u00fchrung wird nach dem \x3ccode\x3eif\x3c/code\x3e fortgesetzt und \x3ccode\x3ei\x3c/code\x3e wird zu \x3ccode\x3esumme\x3c/code\x3e hinzugez\u00e4hlt. Ist \x3ccode\x3ei\x3c/code\x3e eine gerade Zahl, so gilt: i modulo 2 \x3d 0. Die \x3ccode\x3eif\x3c/code\x3e - Bedingung ist erf\u00fcllt und \x3ccode\x3econtinue\x3c/code\x3e wird ausgef\u00fchrt. Die Code-Ausf\u00fchrung springt direkt zum Schleifenkopf. \x3ccode\x3ei\x3c/code\x3e wird nicht zu \x3ccode\x3esumme\x3c/code\x3e hinzugez\u00e4hlt. So werden alle ungeraden Zahlen kleiner 10 aufaddiert.\x3cbr\x3e\x3ccode\x3ebreak\x3c/code\x3e und \x3ccode\x3econtinue\x3c/code\x3e kann man in allen Schleifen (for, while, do...while) verwenden.',task:"Schreibe eine Funktion \x3ccode\x3eisPrime\x3c/code\x3e. Sie soll pr\u00fcfen, ob eine \u00fcbergebene Zahl eine Primzahl ist oder nicht. Ist die Zahl prim, so soll \x3ccode\x3etrue\x3c/code\x3e zur\u00fcckgegeben werden, im anderen Fall \x3ccode\x3efalse\x3c/code\x3e. Der Aufruf \x3ccode\x3eisPrime(2)\x3c/code\x3e soll \x3ccode\x3etrue\x3c/code\x3e zur\u00fcckgeben, \x3ccode\x3eisPrime(4)\x3c/code\x3e soll \x3ccode\x3efalse\x3c/code\x3e ergeben. Eine Primzahl ist eine nat\u00fcrliche Zahl, die gr\u00f6\u00dfer als 1 und nur durch sich selbst und durch 1 teilbar ist.",
beforeTests:function(){"undefined"!==typeof isPrime&&(isPrime=void 0)},tests:[function(){var a="function"===typeof isPrime;return{ok:a,msg:a?"\x3ccode\x3eisPrime\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eisPrime\x3c/code\x3e ist keine Funktion."}},function(){var a=1===isPrime.length;return{ok:a,msg:a?"\x3ccode\x3eisPrime\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3eisPrime\x3c/code\x3e hat nicht 1, sondern "+isPrime.length+" Parameter."}},function(){var a,b,d;try{var c=isPrime(1);b=(a=!1===c)?
"\x3ccode\x3eisPrime(1)\x3c/code\x3e gibt \x3ccode\x3efalse\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3eisPrime(1)\x3c/code\x3e gibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eisPrime(1)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=isPrime(2);b=(a=!0===c)?"\x3ccode\x3eisPrime(2)\x3c/code\x3e gibt \x3ccode\x3etrue\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3eisPrime(2)\x3c/code\x3e gibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eisPrime(2)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=isPrime(3);b=(a=!0===c)?"\x3ccode\x3eisPrime(3)\x3c/code\x3e gibt \x3ccode\x3etrue\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3eisPrime(3)\x3c/code\x3e gibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eisPrime(3)\x3c/code\x3e.",
d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=isPrime(4);b=(a=!1===c)?"\x3ccode\x3eisPrime(4)\x3c/code\x3e gibt \x3ccode\x3efalse\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3eisPrime(4)\x3c/code\x3e gibt nicht \x3ccode\x3efalse\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eisPrime(4)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=isPrime(11);b=(a=!0===c)?"\x3ccode\x3eisPrime(11)\x3c/code\x3e gibt \x3ccode\x3etrue\x3c/code\x3e zur\u00fcck.":
"\x3ccode\x3eisPrime(11)\x3c/code\x3e gibt nicht \x3ccode\x3etrue\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3eisPrime(11)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
(function(a){jshero.koans.add({id:"bubblesort",title:"Bubblesort",lesson:'H\u00e4ufig m\u00f6chte man Daten der Gr\u00f6\u00dfe nach sortieren. Hierf\u00fcr gibt es verschiedene Sortierverfahren. Ein bekanntes, einfaches, aber auch langsames Verfahren ist \x3ca href\x3d"https://de.wikipedia.org/wiki/Bubblesort" target\x3d"_blank"\x3eBubblesort\x3c/a\x3e. Liegen die zu sortierenden Daten in einem Array der L\u00e4nge n vor und sollen die Daten aufsteigend sortiert werden, so wird in einer sogenannten Bubble-Phase das Array vom 1 \x26apos;ten bis zum n-1 \x26apos;ten Element durchlaufen. Dabei wird in jedem Schritt das aktuelle Element an der Stelle i mit dem nachfolgenden Element an der Stelle i+1 verglichen. Ist das Element an der Stelle i gr\u00f6\u00dfer als das Element an der Stelle i+1, so vertauscht man beide Elemente. Hat man so eine Bubble-Phase durchlaufen, ist das gr\u00f6\u00dfte Element am Ende des Arrays angekommen. Wiederholt man nun eine Bubble-Phase, so steht auch das zweitgr\u00f6\u00dfte Element an der richtigen Stelle. Hat man n-1 Bubble-Phasen durchlaufen, ist das komplette Array sortiert. Um ein Array mit 4 Zahlen zu sortieren, ben\u00f6tigt man also drei Bubble-Phasen:\x3cpre\x3e\x3ccode\x3eErste Bubble-Phase:\x3cbr\x3e[4, 2, 3, 1] -\x3e [2, 4, 3, 1] Das erste Element wird mit dem zweiten verglichen. Sie werden vertauscht, da 4\x3e2 ist.\x3cbr\x3e[2, 4, 3, 1] -\x3e [2, 3, 4, 1] Das zweite Element wird mit dem dritten verglichen. Sie werden vertauscht, da 4\x3e3 ist.\x3cbr\x3e[2, 3, 4, 1] -\x3e [2, 3, 1, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden vertauscht, da 4\x3e1 ist.\x3cbr\x3eDas gr\u00f6\u00dfte Element ist an die richtige Stelle geblubbert.\x3cbr\x3e\x3cbr\x3eZweite Bubble-Phase:\x3cbr\x3e[2, 3, 1, 4] -\x3e [2, 3, 1, 4] Das erste Element wird mit dem zweiten verglichen. Sie werden nicht vertauscht, da 2\x3c3 ist.\x3cbr\x3e[2, 3, 1, 4] -\x3e [2, 1, 3, 4] Das zweite Element wird mit dem dritten verglichen. Sie werden vertauscht, da 3\x3e1 ist.\x3cbr\x3e[2, 1, 3, 4] -\x3e [2, 1, 3, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden nicht vertauscht, da 3\x3c4 ist.\x3cbr\x3eDas zweitgr\u00f6\u00dfte Element ist an die richtige Stelle geblubbert.\x3cbr\x3e\x3cbr\x3eDritte Bubble-Phase:\x3cbr\x3e[2, 1, 3, 4] -\x3e [1, 2, 3, 4] Das erste Element wird mit dem zweiten verglichen. Sie werden vertauscht, da 2\x3e1 ist.\x3cbr\x3e[1, 2, 3, 4] -\x3e [1, 2, 3, 4] Das zweite Element wird mit dem dritten verglichen. Sie werden nicht vertauscht, da 2\x3c3 ist.\x3cbr\x3e[1, 2, 3, 4] -\x3e [1, 2, 3, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden vertauscht, da 3\x3c4 ist.\x3cbr\x3eDas drittgr\u00f6\u00dfte Element ist an die richtige Stelle geblubbert.\x3cbr\x3eDamit ist automatisch auch das kleinste Element an der richtigen Stelle.\x3cbr\x3eDas Array ist aufsteigend sortiert.\x3c/code\x3e\x3c/pre\x3e',task:"Schreibe eine Funktion \x3ccode\x3esort\x3c/code\x3e, die ein mit Zahlen gef\u00fclltes Array entgegennimmt und die diese Zahlen aufsteigend sortiert als Array zur\u00fcckgibt. Wird ein leeres Array \u00fcbergeben, so soll auch ein leeres Array zur\u00fcckgegeben werden. \x3ccode\x3esort([4,\x26nbsp;2,\x26nbsp;3,\x26nbsp;1])\x3c/code\x3e sollte \x3ccode\x3e[1,\x26nbsp;2,\x26nbsp;3,\x26nbsp;4]\x3c/code\x3e ergeben.",
beforeTests:function(){"undefined"!==typeof sort&&(sort=void 0)},tests:[function(){var a="function"===typeof sort;return{ok:a,msg:a?"\x3ccode\x3esort\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3esort\x3c/code\x3e ist keine Funktion."}},function(){var a=1===sort.length;return{ok:a,msg:a?"\x3ccode\x3esort\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3esort\x3c/code\x3e hat nicht 1, sondern "+sort.length+" Parameter."}},function(){var b,d,c;try{var e=sort([]);d=(b=a.isEqual(e,[]))?"\x3ccode\x3esort([])\x3c/code\x3e gibt \x3ccode\x3e[]\x3c/code\x3e zur\u00fcck.":
"\x3ccode\x3esort([])\x3c/code\x3e gibt nicht \x3ccode\x3e[]\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(e)+"\x3c/code\x3e zur\u00fcck."}catch(f){b=!1,d="Fehler beim Aufruf von \x3ccode\x3esort([])\x3c/code\x3e.",c=f}return{ok:b,msg:d,e:c}},function(){var b,d,c;try{var e=sort([1]);d=(b=a.isEqual(e,[1]))?"\x3ccode\x3esort([1])\x3c/code\x3e gibt \x3ccode\x3e[1]\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3esort([1])\x3c/code\x3e gibt nicht \x3ccode\x3e[1]\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(e)+
"\x3c/code\x3e zur\u00fcck."}catch(f){b=!1,d="Fehler beim Aufruf von \x3ccode\x3esort([1])\x3c/code\x3e.",c=f}return{ok:b,msg:d,e:c}},function(){var b,d,c;try{var e=sort([2,1]);d=(b=a.isEqual(e,[1,2]))?"\x3ccode\x3esort([2, 1])\x3c/code\x3e gibt \x3ccode\x3e[1, 2]\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3esort([2, 1])\x3c/code\x3e gibt nicht \x3ccode\x3e[1, 2]\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(e)+"\x3c/code\x3e zur\u00fcck."}catch(f){b=!1,d="Fehler beim Aufruf von \x3ccode\x3esort([2, 1])\x3c/code\x3e.",
c=f}return{ok:b,msg:d,e:c}},function(){var b,d,c;try{var e=sort([2,3,1]);d=(b=a.isEqual(e,[1,2,3]))?"\x3ccode\x3esort([2, 3, 1])\x3c/code\x3e gibt \x3ccode\x3e[1, 2, 3]\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3esort([2, 3, 1])\x3c/code\x3e gibt nicht \x3ccode\x3e[1, 2, 3]\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(e)+"\x3c/code\x3e zur\u00fcck."}catch(f){b=!1,d="Fehler beim Aufruf von \x3ccode\x3esort([2, 3, 1])\x3c/code\x3e.",c=f}return{ok:b,msg:d,e:c}},function(){var b,d,c;try{var e=sort([5,
4,3,2,1]);d=(b=a.isEqual(e,[1,2,3,4,5]))?"\x3ccode\x3esort([5, 4, 3, 2, 1])\x3c/code\x3e gibt \x3ccode\x3e[1, 2, 3, 4, 5]\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3esort([5, 4, 3, 2, 1])\x3c/code\x3e gibt nicht \x3ccode\x3e[1, 2, 3, 4, 5]\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(e)+"\x3c/code\x3e zur\u00fcck."}catch(f){b=!1,d="Fehler beim Aufruf von \x3ccode\x3esort([5, 4, 3, 2, 1])\x3c/code\x3e.",c=f}return{ok:b,msg:d,e:c}}]})})(jshero.array);
jshero.koans.add({id:"comment",title:"Kommentare",lesson:"Neben dem eigentlichen Code kann man Kommentare schreiben. Kommentare dienen dazu, Programme zu erkl\u00e4ren. Sie helfen uns Menschen, Programme zu verstehen und zu verwenden. Computer, die Programme ausf\u00fchren, ignorieren Kommentare. In JavaScript gibt zwei M\u00f6glichkeiten, Kommentare zu schreiben: Zeilen-Kommentare werden mit \x3ccode\x3e//\x3c/code\x3e eingeleitet und gelten immer bis zum Ende der Zeile. Block-Kommentare werden mit \x3ccode\x3e/*\x3c/code\x3e eingeleitet und mit \x3ccode\x3e*/\x3c/code\x3e beendet. Alles dazwischen ist Kommentar. Hier ein paar Beispiele:\x3cpre\x3e\x3ccode\x3e// Das ist ein Zeilenkommentar.\x3cbr\x3e\x3cbr\x3e// Dieser Zeilenkommentar geht\x3cbr\x3e// \u00fcber 2 Zeilen.\x3cbr\x3e\x3cbr\x3e/* Das ist ein Blockkommentar. */\x3cbr\x3e\x3cbr\x3e/* Dieser Blockkommentar geht\x3cbr\x3e\u00fcber mehrere Zeilen. */\x3cbr\x3e\x3cbr\x3e/**\x3cbr\x3e * Auch dies ist ein Blockkommentar.\x3cbr\x3e * Die zus\u00e4tzlichen Sterne zwischen\x3cbr\x3e * dem Beginn und dem Ende des\x3cbr\x3e * Blockkommentars dienen nur zur\x3cbr\x3e * Verzierung. So sieht ein l\u00e4ngerer \x3cbr\x3e * Blockkommentar \u00fcbersichtlicher aus.\x3cbr\x3e */\x3c/code\x3e\x3c/pre\x3eBlock-Kommentare schreibt man gerne \u00fcber Funktionen, Zeilen-Kommentare in den Code-Fluss.\x3cpre\x3e\x3ccode\x3e/**\x3cbr\x3e * Pr\u00fcft, ob eine String kein Zeichen\x3cbr\x3e * au\u00dfer Leerzeichen enth\u00e4lt.\x3cbr\x3e */\x3cbr\x3evar isEmpty \x3d function(string) {\x3cbr\x3e  // Die Methode trim() entfernt Leerzeichen\x3cbr\x3e  // am Anfang und am Ende einer Zeichenfolge.\x3cbr\x3e  var trimmedString \x3d string.trim();\x3cbr\x3e  return trimmedString.length \x3d\x3d\x3d 0;\x3cbr\x3e};\x3c/code\x3e\x3c/pre\x3eDa Kommentare mit den hier verwendeten Tests nicht \u00fcberpr\u00fcfen werden k\u00f6nnen, eine Aufgabe, bei der man vieles von dem bisher Gelernten anwenden muss.",
task:"Schreibe eine Funktion \x3ccode\x3emedian\x3c/code\x3e, die ein Array von aufsteigend sortierten Zahlen entgegennimmt und die den Median dieser Zahlen zur\u00fcckgibt. \x3ccode\x3emedian([1, 2, 10])\x3c/code\x3e sollte \x3ccode\x3e2\x3c/code\x3e ergeben; \x3ccode\x3emedian([1, 2, 10, 100])\x3c/code\x3e sollte \x3ccode\x3e6\x3c/code\x3e ergeben. Der Median einer sortierten Zahlenreihe ist der Wert, der an der mittleren Stelle steht. Ist die Anzahl der Werte gerade, so ist der Median der Mittelwert der beiden mittleren Zahlen.",
beforeTests:function(){"undefined"!==typeof median&&(median=void 0)},tests:[function(){var a="function"===typeof median;return{ok:a,msg:a?"\x3ccode\x3emedian\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3emedian\x3c/code\x3e ist keine Funktion."}},function(){var a=1===median.length;return{ok:a,msg:a?"\x3ccode\x3emedian\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3emedian\x3c/code\x3e hat nicht 1, sondern "+median.length+" Parameter."}},function(){var a,b,d;try{var c=median([1]);b=(a=1===c)?"\x3ccode\x3emedian([1])\x3c/code\x3e gibt \x3ccode\x3e1\x3c/code\x3e zur\u00fcck.":
"\x3ccode\x3emedian([1])\x3c/code\x3e gibt nicht \x3ccode\x3e1\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3emedian([1])\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=median([1,2]);b=(a=1.5===c)?"\x3ccode\x3emedian([1, 2])\x3c/code\x3e gibt \x3ccode\x3e1.5\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3emedian([1, 2])\x3c/code\x3e gibt nicht \x3ccode\x3e1.5\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3emedian([1, 2])\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=median([1,2,10]);b=(a=2===c)?"\x3ccode\x3emedian([1, 2, 10])\x3c/code\x3e gibt \x3ccode\x3e2\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3emedian([1, 2, 10])\x3c/code\x3e gibt nicht \x3ccode\x3e2\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3emedian([1, 2, 10])\x3c/code\x3e.",
d=e}return{ok:a,msg:b,e:d}}]});
(function(a){jshero.koans.add({id:"undefined",title:"undefined",lesson:"Bisher hatten wir Variablen bei der Deklaration immer auch initialisiert.\x3cpre\x3e\x3ccode\x3e// Deklaration und Initialisierung\x3cbr\x3evar x \x3d 1;\x3c/code\x3e\x3c/pre\x3eMan kann eine Varialbe aber auch deklarieren und ihr sp\u00e4ter einen Wert zuweisen.\x3cpre\x3e\x3ccode\x3evar x; // Deklaration\x3cbr\x3ex \x3d 1; // Initialisierung\x3c/code\x3e\x3c/pre\x3eVariablen, die nicht initialisiert wurden, haben den Wert \x3ccode\x3eundefined\x3c/code\x3e (engl.: nicht definiert). In der Praxis kommt das bei Funktionsaufrufen am h\u00e4ufigsten vor. Ruft man eine Funktion, die einen Parameter erwartet, ohne Argument auf, dann erh\u00e4lt der Funktionsparameter den Wert \x3ccode\x3eundefined\x3c/code\x3e.\x3cpre\x3e\x3ccode\x3evar echo \x3d function(x) {\x3cbr\x3e  return x;\x3cbr\x3e};\x3cbr\x3e// Aufruf ohne Argument\x3cbr\x3evar y \x3d echo();\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3eecho\x3c/code\x3e wird ohne Argument aufgerufen. Dem Parameter \x3ccode\x3ex\x3c/code\x3e wird so kein Wert zugewiesen, er erh\u00e4lt den Wert \x3ccode\x3eundefined\x3c/code\x3e. Da \x3ccode\x3eecho\x3c/code\x3e den Parameter \x3ccode\x3ex\x3c/code\x3e einfach nur zur\u00fcckgibt, erh\u00e4lt auch \x3ccode\x3ey\x3c/code\x3e den Wert \x3ccode\x3eundefined\x3c/code\x3e. \x3cbr\x3e\x3cbr\x3eEine Funktion, die einen Parameter erwartet, kann immer auch ohne Argument aufgerufen werden. Man sollte sich beim Schreiben von Funktionen also immer \u00fcberlegen, was in diesem Fall passieren soll. Gute Praxis ist es, in einem solchen Fall dem Parameter einen Default-Wert (engl.: Vorgabe) zuzuweisen. Das hatten wir schon bei der String-Methode \x3ccode\x3echarAt(index)\x3c/code\x3e kennen gelernt. Normalerweise gibt diese Methode den Buchstaben an der Stelle \x3ccode\x3eindex\x3c/code\x3e zur\u00fcck. Rufen wir \x3ccode\x3echarAt\x3c/code\x3e ohne Argument auf, erh\u00e4lt \x3ccode\x3eindex\x3c/code\x3e den Default \x3ccode\x3e0\x3c/code\x3e. Es wird der Buchstabe an der Stelle \x3ccode\x3e0\x3c/code\x3e zur\u00fcckgegeben. Um eine Varaible auf \x3ccode\x3eundefined\x3c/code\x3e zu \u00fcberpr\u00fcfen, verwendet man wie \u00fcblich die strikte Gleichkeit. Die Methode \x3ccode\x3echarAt\x3c/code\x3e k\u00f6nnte also folgenden Code-Ausschnitt enthalten:\x3cpre\x3e\x3ccode\x3eif (index \x3d\x3d\x3d undefined) {\x3cbr\x3e  index \x3d 0;\x3cbr\x3e}\x3cbr\x3e\x3c/code\x3e\x3c/pre\x3e",task:'Schreibe eine Funktion \x3ccode\x3ehallo\x3c/code\x3e, die einen String als Parameter entgegennimmt und \x3ccode\x3e"Hallo \x26lt;Parameter\x26gt;!"\x3c/code\x3e zur\u00fcckgibt. \x3ccode\x3ehallo("Akg\u00fcn")\x3c/code\x3e sollte \x3ccode\x3e"Hallo Akg\u00fcn!"\x3c/code\x3e zur\u00fcckgeben. Wird \x3ccode\x3ehallo\x3c/code\x3e ohne Argument aufgerufen, so soll \x3ccode\x3e"Hallo Welt!"\x3c/code\x3e zur\u00fcckgegeben werden.',
beforeTests:function(){"undefined"!==typeof hallo&&(hallo=void 0)},tests:[function(){var a="function"===typeof hallo;return{ok:a,msg:a?"\x3ccode\x3ehallo\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3ehallo\x3c/code\x3e ist keine Funktion."}},function(){var a=1===hallo.length;return{ok:a,msg:a?"\x3ccode\x3ehallo\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3ehallo\x3c/code\x3e hat nicht 1, sondern "+hallo.length+" Parameter."}},function(){var a,d,c;try{var e=hallo();d=(a="Hallo Welt!"===e)?'\x3ccode\x3ehallo()\x3c/code\x3e gibt \x3ccode\x3e"Hallo Welt!"\x3c/code\x3e zur\u00fcck.':
'\x3ccode\x3ehallo()\x3c/code\x3e gibt nicht \x3ccode\x3e"Hallo Welt!"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(e)+"\x3c/code\x3e zur\u00fcck."}catch(f){a=!1,d="Fehler beim Aufruf von \x3ccode\x3ehallo()\x3c/code\x3e.",c=f}return{ok:a,msg:d,e:c}},function(){var a,d,c;try{var e=hallo("Melek");d=(a="Hallo Melek!"===e)?'\x3ccode\x3ehallo("Melek")\x3c/code\x3e gibt \x3ccode\x3e"Hallo Melek!"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3ehallo("Melek")\x3c/code\x3e gibt nicht \x3ccode\x3e"Hallo Melek!"\x3c/code\x3e, sondern \x3ccode\x3e'+
JSON.stringify(e)+"\x3c/code\x3e zur\u00fcck."}catch(f){a=!1,d='Fehler beim Aufruf von \x3ccode\x3ehallo("Melek")\x3c/code\x3e.',c=f}return{ok:a,msg:d,e:c}}]})})(jshero.date);
jshero.koans.add({id:"stringsplit",title:"String: split()",lesson:'Die Methode \x3ccode\x3esplit\x3c/code\x3e zerlegt einen String anhand eines Trennstrings in Teilstrings. Die Teilstrings werden als Array zur\u00fcckgegeben. Der urspr\u00fcngliche String wird nicht ver\u00e4ndert.\x3cpre\x3e\x3ccode\x3evar date \x3d "31-10-2017";\x3cbr\x3evar parts \x3d date.split("-");\x3cbr\x3evar day \x3d parts[0]; // "31"\x3cbr\x3evar month \x3d parts[1]; // "10"\x3cbr\x3evar year \x3d parts[2]; // "2017"\x3cbr\x3e\x3c/code\x3e\x3c/pre\x3eDer Trennstring ist hier der Bindestrich. Er zerlegt den Datumsstring in drei Teile. Diese drei Teile werden als Array der Variablen \x3ccode\x3eparts\x3c/code\x3e zugewiesen. Anschlie\u00dfend werden die einzelnen Teile aus dem Array ausgelesen und gesonderten Variablen zugewiesen. Die Variable \x3ccode\x3edate\x3c/code\x3e hat weiterhin den Wert \x3ccode\x3e"31-10-2017"\x3c/code\x3e.',task:'Schreibe eine Funktion \x3ccode\x3eadd\x3c/code\x3e, die einen String mit einer Additionsaufgabe entgegennimmt und die das Ergebnis der Addition als Zahl zur\u00fcckgibt. Es sollen endlich viele nat\u00fcrliche Zahlen addiert werden. Die Additionsaufgabe ist ein String der Form "1+19+...+281". So soll \x3ccode\x3eadd("7+12+100")\x3c/code\x3e die Zahl \x3ccode\x3e119\x3c/code\x3e zur\u00fcckgeben.',
beforeTests:function(){"undefined"!==typeof hallo&&(hallo=void 0)},tests:[function(){var a="function"===typeof add;return{ok:a,msg:a?"\x3ccode\x3eadd\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eadd\x3c/code\x3e ist keine Funktion."}},function(){var a=1===add.length;return{ok:a,msg:a?"\x3ccode\x3eadd\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3eadd\x3c/code\x3e hat nicht 1, sondern "+add.length+" Parameter."}},function(){var a,b,d;try{var c=add("1+2");b=(a=3===c)?'\x3ccode\x3eadd("1+2")\x3c/code\x3e gibt \x3ccode\x3e3\x3c/code\x3e zur\u00fcck.':
'\x3ccode\x3eadd("1+2")\x3c/code\x3e gibt nicht \x3ccode\x3e3\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3eadd("1+2")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=add("50000+4000+300+20+1");b=(a=54321===c)?'\x3ccode\x3eadd("50000+4000+300+20+1")\x3c/code\x3e gibt \x3ccode\x3e54321\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3eadd("50000+4000+300+20+1")\x3c/code\x3e gibt nicht \x3ccode\x3e54321\x3c/code\x3e, sondern \x3ccode\x3e'+
JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b='Fehler beim Aufruf von \x3ccode\x3eadd("50000+4000+300+20+1")\x3c/code\x3e.',d=e}return{ok:a,msg:b,e:d}}]});
(function(a){jshero.koans.add({id:"date",title:"Datum und Uhrzeit",lesson:'Um mit Datum und Uhrzeit zu arbeiten, verwendet man \x3ccode\x3eDate\x3c/code\x3e-Objekte. Ein \x3ccode\x3eDate\x3c/code\x3e-Objekt repr\u00e4sentiert einen Zeitpunkt, also ein Datum zusammen mit einer Uhrzeit. Die Uhrzeit wird dabei auf die Millisekunde genau festgelegt. Ein Date-Objekt erzeugt man mit \x3ccode\x3enew Date()\x3c/code\x3e. Es gibt 4 m\u00f6gliche Aufrufe: \x3cpre\x3e\x3ccode\x3e// aktueller Zeitpunkt\x3cbr\x3evar d1 \x3d new Date();\x3c/code\x3e\x3c/pre\x3eOhne Parameter erzeugt \x3ccode\x3enew Date()\x3c/code\x3e ein Date-Objekt, das dem Zeitpunkt seines Aufrufs entspricht. Wird obiges Beispiel am 1. Mai 2017 um 8:15 Uhr aufgerufen, so enth\u00e4lt \x3ccode\x3ed1\x3c/code\x3e eben diesen Zeitpunkt.\x3cbr\x3e\x3cpre\x3e\x3ccode\x3e// Aufruf mit Jahr, Monat, Tag, Stunde,\x3cbr\x3e// Stunde, Minute, Sekunde, Millisekunde\x3cbr\x3evar d2 \x3d new Date(2017, 2, 8, 16, 31, 10, 117);\x3c/code\x3e\x3c/pre\x3eM\u00f6chte man ein Date-Objekt zu einem bestimmten Zeitpunkt erstellen, verwendet man am besten die zweite M\u00f6glichkeit. Hier \u00fcbergibt man als Parameter das Jahr, den Monat, den Tag, die Stunde, die Minute, die Sekunde und die Millisekunde. Das Jahr muss in voller L\u00e4nge \u00fcbergeben werden. \x3ccode\x3e17\x3c/code\x3e ergibt das Jahr 17 n. Chr. und \x3ccode\x3e2017\x3c/code\x3e das Jahr 2017 n. Chr. Bei dem Monat muss man aufpassen. JavaScript nummeriert die Monate von 0 (Januar) bis 11 (Dezember). Alle weiteren Zahlen entsprechen der \u00fcblichen Bedeutung. \x3ccode\x3ed2\x3c/code\x3e repr\u00e4sentiert also den Zeitpunkt 8.3.2017, 16:31:10 Uhr und 117 Millisekunden.\x3cbr\x3eDie Parameter Millisekunde, Sekunde, Minute, Stunde und Tag sind - in dieser Reihenfolge - optional. Man kann sie weglassen. Gibt man sie nicht an, werden die Zeitangaben automatisch auf 0 gesetzt. Der Tag wird auf den Monatsersten gesetzt. Das ist besonders praktisch, wenn man nur mit einem Datum arbeiten m\u00f6chte. Dann l\u00e4\u00dft man einfach alle Zeitangaben weg. \x3ccode\x3enew\x26nbsp;Date(2017, 5, 2)\x3c/code\x3e ist der 2.6.2017, 0:00 Uhr.\x3cbr\x3e\x3cpre\x3e\x3ccode\x3e// Millisekunden seit dem 1.1.1970\x3cbr\x3evar d3 \x3d new Date(86400000);\x3c/code\x3e\x3c/pre\x3eBei der dritten Variante \u00fcbergibt man die vergangenen Millisekunden seit dem 1.1.1970, 0:00 Uhr. Der Bezugspunkt 1.1.1970 f\u00fcr Datumsangaben ist seit den Tagen von Unix und der Programmiersprache C in der IT \u00fcblich geworden. Ein Tag hat 24 * 60 * 60 * 1000 \x3d 86400000 Millisekunden. \x3ccode\x3ed3\x3c/code\x3e ist also der 2.1.1970, 0:00 Uhr.\x3cbr\x3e\x3cpre\x3e\x3ccode\x3e// \u00dcbergabe eines Datumsstrings\x3cbr\x3evar d4 \x3d new Date("2017-3-8T16:31:10.117");\x3c/code\x3e\x3c/pre\x3eBei der vierten Variante wird ein Datumsstring in einem bestimmten Format, d.h. in einer bestimmten Schreibweise, \u00fcbergeben. \x3ccode\x3ed4\x3c/code\x3e entspricht ebenfalls dem Zeitpunkt 8.3.2017, 16:31:10 Uhr und 117 Millisekunden. Diese Varainte ist jedoch nicht zu empfehlen, da verschiedene Browser leichte Unterschiede bei der Bestimmung des Datums aufweisen.',task:"Schreibe eine Funktion \x3ccode\x3enikolaus\x3c/code\x3e, die eine Jahreangabe als Zahl entgegennimmt und  die ein Date-Objekt mit dem 6. Dezember des \u00fcbergebenen Jahres, 0:00 Uhr, zur\u00fcckgibt. \x3ccode\x3enikolaus(2017)\x3c/code\x3e sollte ein Date-Objekt mit dem Zeitpunkt 6.12.2017, 0:00 Uhr zur\u00fcckgeben.",
beforeTests:function(){"undefined"!==typeof nikolaus&&(nikolaus=void 0)},tests:[function(){var a="function"===typeof nikolaus;return{ok:a,msg:a?"\x3ccode\x3enikolaus\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3enikolaus\x3c/code\x3e ist keine Funktion."}},function(){var a=1===nikolaus.length;return{ok:a,msg:a?"\x3ccode\x3enikolaus\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3enikolaus\x3c/code\x3e hat nicht 1, sondern "+nikolaus.length+" Parameter."}},function(){var b,d,c;try{var e=nikolaus(2017);
d=(b=a.isDate(e))?"\x3ccode\x3enikolaus(2017)\x3c/code\x3e gibt ein Date-Objekt zur\u00fcck.":"\x3ccode\x3enikolaus(2017)\x3c/code\x3e gibt kein Date-Objekt zur\u00fcck."}catch(f){b=!1,d="Fehler beim Aufruf von \x3ccode\x3enikolaus(2017)\x3c/code\x3e.",c=f}return{ok:b,msg:d,e:c}},function(){var a,d,c;try{var e=nikolaus(2017);d=(a=e.getTime()===(new Date(2017,11,6)).getTime())?"\x3ccode\x3enikolaus(2017)\x3c/code\x3e gibt den 6.12.2017 zur\u00fcck.":"\x3ccode\x3enikolaus(2017)\x3c/code\x3e gibt nicht den 6.12.2017 zur\u00fcck, sondern den "+
e.toLocaleString()+" zur\u00fcck."}catch(f){a=!1,d="Fehler beim Aufruf von \x3ccode\x3enikolaus(2017)\x3c/code\x3e.",c=f}return{ok:a,msg:d,e:c}},function(){var b,d,c;try{var e=nikolaus(1960);d=(b=a.isDate(e))?"\x3ccode\x3enikolaus(1960)\x3c/code\x3e gibt ein Date-Objekt zur\u00fcck.":"\x3ccode\x3enikolaus(1960)\x3c/code\x3e gibt kein Date-Objekt zur\u00fcck."}catch(f){b=!1,d="Fehler beim Aufruf von \x3ccode\x3enikolaus(1960)\x3c/code\x3e.",c=f}return{ok:b,msg:d,e:c}},function(){var a,d,c;try{var e=
nikolaus(1960);d=(a=e.getTime()===(new Date(1960,11,6)).getTime())?"\x3ccode\x3enikolaus(1960)\x3c/code\x3e gibt den 6.12.1960 zur\u00fcck.":"\x3ccode\x3enikolaus(1960)\x3c/code\x3e gibt nicht den 6.12.1960 zur\u00fcck, sondern den "+e.toLocaleString()+" zur\u00fcck."}catch(f){a=!1,d="Fehler beim Aufruf von \x3ccode\x3enikolaus(1960)\x3c/code\x3e.",c=f}return{ok:a,msg:d,e:c}}]})})(jshero.date);
jshero.koans.add({id:"date2",title:"Datum und Uhrzeit ausgeben",lesson:"Zur Ausgabe der Daten eines Date-Objekts gibt es sieben sogenannte Getter-Methoden:\x3cpre\x3e\x3ccode\x3evar startFastnacht \x3d new Date(2017, 10, 11, 11, 11);\x3cbr\x3evar jahr \x3d startFastnacht.getFullYear();\x3cbr\x3evar monat \x3d startFastnacht.getMonth();\x3cbr\x3evar tag \x3d startFastnacht.getDate();\x3cbr\x3evar stunde \x3d startFastnacht.getHours();\x3cbr\x3evar minute \x3d startFastnacht.getMinutes();\x3cbr\x3evar sekunde \x3d startFastnacht.getSeconds();\x3cbr\x3evar millisekunde \x3d startFastnacht.getMilliseconds();\x3cbr\x3e\x3c/code\x3e\x3c/pre\x3eMan erh\u00e4lt die erwarteten Werte: \x3ccode\x3e2017\x3c/code\x3e f\u00fcr das Jahr, \x3ccode\x3e10\x3c/code\x3e f\u00fcr den Monat, \x3ccode\x3e11\x3c/code\x3e f\u00fcr den Tag, die Stunde und die Minute, sowie \x3ccode\x3e0\x3c/code\x3e f\u00fcr die Sekunde und die Millisekunde. Die Monatsz\u00e4hlung beginnt wie beim Erzeugen eines Date-Objektes mit \x3ccode\x3e0\x3c/code\x3e. \x3ccode\x3e10\x3c/code\x3e steht f\u00fcr den November.",task:'Schreibe eine Funktion \x3ccode\x3etoGerman\x3c/code\x3e, die ein Date-Objekt entgegennimmt und dessen Datum im Format "d.M.YYYY" zur\u00fcckgibt. Mit \x3ccode\x3edate \x3d new Date(2017, 2, 8)\x3c/code\x3e sollte \x3ccode\x3etoGerman(date)\x3c/code\x3e den String \x3ccode\x3e"8.3.2017"\x3c/code\x3e zur\u00fcckgeben.',
beforeTests:function(){"undefined"!==typeof toGerman&&(toGerman=void 0)},tests:[function(){var a="function"===typeof toGerman;return{ok:a,msg:a?"\x3ccode\x3etoGerman\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3etoGerman\x3c/code\x3e ist keine Funktion."}},function(){var a=1===toGerman.length;return{ok:a,msg:a?"\x3ccode\x3etoGerman\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3etoGerman\x3c/code\x3e hat nicht 1, sondern "+toGerman.length+" Parameter."}},function(){var a,b,d;try{var c=toGerman(new Date(2017,
2,8));b=(a="8.3.2017"===c)?'\x3ccode\x3etoGerman(new Date(2017, 2, 8))\x3c/code\x3e gibt \x3ccode\x3e"8.3.2017"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3etoGerman(new Date(2017, 2, 8))\x3c/code\x3e gibt nicht \x3ccode\x3e"8.3.2017"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3etoGerman(new Date(2017, 2, 8))\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=toGerman(new Date(1724,3,22));b=
(a="22.4.1724"===c)?'\x3ccode\x3etoGerman(new Date(1724, 3, 22))\x3c/code\x3e gibt \x3ccode\x3e"22.4.1724"\x3c/code\x3e zur\u00fcck.':'\x3ccode\x3etoGerman(new Date(1724, 3, 22))\x3c/code\x3e gibt nicht \x3ccode\x3e"22.4.1724"\x3c/code\x3e, sondern \x3ccode\x3e'+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3etoGerman(new Date(1724, 3, 22))\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}}]});
(function(a){jshero.koans.add({id:"date3",title:"Datum und Uhrzeit \u00e4ndern",lesson:"Passend zu den sieben Getter-Methoden besitzt das Date-Objekt sieben Setter-Methoden: \x3ccode\x3esetFullYear\x3c/code\x3e, \x3ccode\x3esetMounth\x3c/code\x3e, \x3ccode\x3esetDate\x3c/code\x3e, \x3ccode\x3esetHours\x3c/code\x3e, \x3ccode\x3esetMinutes\x3c/code\x3e, \x3ccode\x3esetSeconds\x3c/code\x3e und \x3ccode\x3esetMilliseconds\x3c/code\x3e. Mit diesen 7 Methoden kann man den entsprechenden Date-Eintrag setzen:\x3cpre\x3e\x3ccode\x3evar today \x3d new Date();\x3cbr\x3etoday.setHours(0);\x3cbr\x3etoday.setMinutes(0);\x3cbr\x3etoday.setSeconds(0);\x3cbr\x3etoday.setMilliseconds(0);\x3cbr\x3e\x3c/code\x3e\x3c/pre\x3e\x3ccode\x3etoday\x3c/code\x3e enth\u00e4lt zun\u00e4chst den Zeitpunkt seiner Erstellung. Anschlie\u00dfend wird mit den vier Setter-Aufrufen die Zeit auf 0:00:00.000 Uhr gesetzt. So enth\u00e4lt \x3ccode\x3etoday\x3c/code\x3e das aktuelle Tagesdatum mit zur\u00fcckgesetzter Uhrzeit.\x3cbr\x3e\x3cbr\x3e\u00dcberschreitet oder unterschreitet man bei einer dieser Methoden den zul\u00e4ssigen Wertebereich, dann rechnen diese Methoden den \u00dcber- oder Untertrag automatisch um:\x3cbr\x3e\x3cpre\x3e\x3ccode\x3evar someDay \x3d new Date(2020, 3, 1);\x3cbr\x3esomeDay.setDate(32);\x3cbr\x3esomeDay.setDate(0);\x3cbr\x3e\x3c/code\x3e\x3c/pre\x3eZun\u00e4chst repr\u00e4sentiert \x3ccode\x3esomeDay\x3c/code\x3e den 1.4.2020. Nun wird der Tag auf den 32. gesetzt. Da der April 30 Tage hat, entspricht das dem 2.5.2020. Wird nun der Tag auf 0 gesetzt, erh\u00e4lt man den 30.4.2020.",
task:"Schreibe eine Funktion \x3ccode\x3eyesterday\x3c/code\x3e, die ein Date-Objekt entgegennimmt, dessen Datum um einen Tag zur\u00fccksetzt und dann dieses Date-Objekt zur\u00fcckgibt. Die Uhrzeit soll dabei nicht ver\u00e4ndert werden. Mit \x3ccode\x3edate \x3d new Date(1965, 8, 14)\x3c/code\x3e sollte \x3ccode\x3eyesterday(date)\x3c/code\x3e ein Date-Objekt zur\u00fcckgeben, das den 13.9.1965 repr\u00e4sentiert.",beforeTests:function(){"undefined"!==typeof yesterday&&(yesterday=void 0)},tests:[function(){var a=
"function"===typeof yesterday;return{ok:a,msg:a?"\x3ccode\x3eyesterday\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3eyesterday\x3c/code\x3e ist keine Funktion."}},function(){var a=1===yesterday.length;return{ok:a,msg:a?"\x3ccode\x3eyesterday\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3eyesterday\x3c/code\x3e hat nicht 1, sondern "+yesterday.length+" Parameter."}},function(){var b,d,c;try{var e=yesterday(new Date(1965,8,14));d=(b=a.isDate(e))?"\x3ccode\x3eyesterday(new Date(1965, 8, 14))\x3c/code\x3e gibt eine Date-Objekt zur\u00fcck.":
"\x3ccode\x3eyesterday(new Date(1965, 8, 14))\x3c/code\x3e gibt kein Date-Objekt zur\u00fcck."}catch(f){b=!1,d="Fehler beim Aufruf von \x3ccode\x3eyesterday(new Date(1965, 8, 14))\x3c/code\x3e.",c=f}return{ok:b,msg:d,e:c}},function(){var b,d,c;try{var e=yesterday(new Date(1965,8,14));d=(b=a.isEqual(e,new Date(1965,8,13)))?"\x3ccode\x3eyesterday(new Date(1965, 8, 14))\x3c/code\x3e gibt eine Date-Objekt zur\u00fcck, das den 13.9.1965 repr\u00e4sentiert. ":"\x3ccode\x3eyesterday(new Date(1965, 8, 14))\x3c/code\x3e gibt eine Date-Objekt zur\u00fcck, das nicht den 13.9.1965 repr\u00e4sentiert, sondern den "+
e.toLocaleString()+"."}catch(f){b=!1,d="Fehler beim Aufruf von \x3ccode\x3eyesterday(new Date(1965, 8, 14))\x3c/code\x3e.",c=f}return{ok:b,msg:d,e:c}},function(){var b,d,c;try{var e=yesterday(new Date(2E3,0,1,12));d=(b=a.isDate(e))?"\x3ccode\x3eyesterday(new Date(2000, 0, 1, 12))\x3c/code\x3e gibt eine Date-Objekt zur\u00fcck.":"\x3ccode\x3eyesterday(new Date(2000, 0, 1, 12))\x3c/code\x3e gibt kein Date-Objekt zur\u00fcck."}catch(f){b=!1,d="Fehler beim Aufruf von \x3ccode\x3eyesterday(new Date(2000, 0, 1, 12))\x3c/code\x3e.",
c=f}return{ok:b,msg:d,e:c}},function(){var b,d,c;try{var e=yesterday(new Date(2E3,0,1,12));d=(b=a.isEqual(e,new Date(1999,11,31,12)))?"\x3ccode\x3eyesterday(new Date(2000, 0, 1, 12))\x3c/code\x3e gibt eine Date-Objekt zur\u00fcck, das den 31.12.1999, 12 Uhr repr\u00e4sentiert. ":"\x3ccode\x3eyesterday(new Date(2000, 0, 1, 12))\x3c/code\x3e gibt eine Date-Objekt zur\u00fcck, das nicht den 31.12.1999, 12 Uhr repr\u00e4sentiert, sondern den "+e.toLocaleString()+"."}catch(f){b=!1,d="Fehler beim Aufruf von \x3ccode\x3eyesterday(new Date(2000, 0, 1, 12))\x3c/code\x3e.",
c=f}return{ok:b,msg:d,e:c}}]})})(jshero.date);
jshero.koans.add({id:"further",title:"Fortsetzung folgt ...",lesson:"JS Hero wird fortgesetzt. Weitere \u00dcbungen folgen. Zum Abschluss noch eine Aufgabe aus dem Gebiet der Mathematik.",task:"Schreibe eine Funktion \x3ccode\x3equersumme\x3c/code\x3e, die die Quersumme einer nat\u00fcrlichen Zahl berechnet. Die Quersumme einer Zahl ist dabei die Summe ihrer Ziffern. \x3ccode\x3equersumme(198)\x3c/code\x3e sollte \x3ccode\x3e18\x3c/code\x3e ergeben.",beforeTests:function(){"undefined"!==typeof quersumme&&
(quersumme=void 0)},tests:[function(){var a="function"===typeof quersumme;return{ok:a,msg:a?"\x3ccode\x3equersumme\x3c/code\x3e ist eine Funktion.":"\x3ccode\x3equersumme\x3c/code\x3e ist keine Funktion."}},function(){var a=1===quersumme.length;return{ok:a,msg:a?"\x3ccode\x3equersumme\x3c/code\x3e hat 1 Parameter.":"\x3ccode\x3equersumme\x3c/code\x3e hat nicht 1, sondern "+quersumme.length+" Parameter."}},function(){var a,b,d;try{var c=quersumme(1);b=(a=1===c)?"\x3ccode\x3equersumme(1)\x3c/code\x3e gibt \x3ccode\x3e1\x3c/code\x3e zur\u00fcck.":
"\x3ccode\x3equersumme(1)\x3c/code\x3e gibt nicht \x3ccode\x3e1\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3equersumme(1)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=quersumme(198);b=(a=18===c)?"\x3ccode\x3equersumme(198)\x3c/code\x3e gibt \x3ccode\x3e18\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3equersumme(198)\x3c/code\x3e gibt nicht \x3ccode\x3e18\x3c/code\x3e, sondern \x3ccode\x3e"+
JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3equersumme(198)\x3c/code\x3e.",d=e}return{ok:a,msg:b,e:d}},function(){var a,b,d;try{var c=quersumme(123456789);b=(a=45===c)?"\x3ccode\x3equersumme(123456789)\x3c/code\x3e gibt \x3ccode\x3e45\x3c/code\x3e zur\u00fcck.":"\x3ccode\x3equersumme(123456789)\x3c/code\x3e gibt nicht \x3ccode\x3e45\x3c/code\x3e, sondern \x3ccode\x3e"+JSON.stringify(c)+"\x3c/code\x3e zur\u00fcck."}catch(e){a=!1,b="Fehler beim Aufruf von \x3ccode\x3equersumme(123456789)\x3c/code\x3e.",
d=e}return{ok:a,msg:b,e:d}}]});
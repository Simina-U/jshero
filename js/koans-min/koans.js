jshero.koans.add({id:'arguments',title:'Das arguments-Objekt',lesson:'Das <code>arguments</code>-Objekt ist eine in jeder Funktion verf\xFCgbare Variable.\nEs ist ein Array \xE4hnliches Objekt, das die \xFCbergebenen Argumente einer Funktion der Reihe nach enth\xE4lt.\n\n<pre><code>var add = function() {\n  var arg0 = arguments[0];\n  var arg1 = arguments[1];\n  return arg0 + arg1;\n};\n\nvar sum = add(1, 2);</code></pre>\n\nHier wird <code>add</code> mit den Argumenten <code>1</code> und <code>2</code> aufgerufen. <code>arguments[0]</code> enth\xE4lt also den Wert <code>1</code>,\n<code>arguments[1]</code> den Wert <code>2</code>.\nMit dem <code>arguments</code>-Objekt kann man ohne Parameter auf die \xFCbergebenen Argumente zugreifen.\nDas ist z.B. dann praktisch, wenn man eine Funktion schreiben m\xF6chte, die eine beliebige Anzahl von Argumenten verarbeiten soll.\n\n<pre><code>var add = function() {\n  var sum = 0;\n  for (var i = 0; i < arguments.length; i++) {\n    sum = sum + arguments[i];\n  }\n  return sum;\n};\n\nvar s1 = add(2, 4);\nvar s2 = add(2, 3, 5, 7);</code></pre>\n\nHier iterieren wir \xFCber alle \xFCbergebenen Argumente und summieren sie auf. <code>arguments.length</code> liefert dabei die Anzahl der \xFCbergebenen Argumente.\nNun k\xF6nnen wir <code>add</code> mit einer beliebigen Anzahl von Argumenten aufrufen.',task:'Schreibe eine Funktion <code>maximum</code>, die beliebig viele Zahlen entgegennimmt und das Maximum dieser Zahlen liefert.\n<code>maximum(12, 68, 3, 52)</code> sollte <code>68</code> ergeben.',beforeTests:function(){if(typeof maximum!=='undefined'){maximum=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('maximum')},function(){return jshero.testutil.assert_functionReturns('maximum(1)',1)},function(){return jshero.testutil.assert_functionReturns('maximum(15, 2)',15)},function(){return jshero.testutil.assert_functionReturns('maximum(1, 15, 3)',15)},function(){return jshero.testutil.assert_functionReturns('maximum(-1, 0, 9, 8)',9)}]});
(function(testutil){jshero.koans.add({id:'array',title:'Arrays anlegen',lesson:'Arrays sind Objekte zur Speicherung vieler, meist \xE4hnlicher Werte. Diese sogenannten Elemente werden\nin einem Array der Reihe nach abgelegt. Arrays erzeugt man am besten mit eckigen Klammern.\n\n<pre><code>var sprachen = ["C", "C++", "Java", "JavaScript"];\nvar primzahlen = [2, 3, 5, 7, 11];\nvar leeresArray = [];\nvar a = "Douglas";\nvar b = 12;\nvar c = true;\nvar allesMoegliche = [a, b, c];</code></pre>\n\nDie Elemente eines Arrays k\xF6nnen, wie das letzte Beispiel zeigt, alle einen anderen Datentyp besitzen.',task:'Schreibe eine Funktion <code>toArray</code>, die 2 Paramter entgegennimmt und diese als Array zur\xFCckgibt.\n<code>toArray(5, 9)</code> sollte das Array <code>[5, 9]</code> ergeben.',hint:'<pre><code>var toArray = function(a, b) {\n  return [...];\n};</code></pre>',solution:'<pre><code>var toArray = function(a, b) {\n  return [a, b];\n};</code></pre>',beforeTests:function(){if(typeof toArray!=='undefined'){toArray=undefined}},tests:[function(){return testutil.assert_isFunction('toArray')},function(){return testutil.assert_functionHasNumOfParameter('toArray',2)},function(){return testutil.assert_functionReturnsType('toArray(1, 2)','Array')},function(){return testutil.assert_functionReturns('toArray(1, 2)',[1,2])},function(){return testutil.assert_functionReturns('toArray("H\xE4nsel", "Gretel")',['H\xE4nsel','Gretel'])},function(){return testutil.assert_functionReturns('toArray(1, "Maus")',[1,'Maus'])}]})})(jshero.testutil);
jshero.koans.add({id:'array2',title:'Array-Elemente lesen',lesson:'Die Elemente eines Arrays werden mit einem Index beginnend mit 0 ausgelesen.\n\n<pre><code>var sprachen = ["C", "C++", "Java", "JavaScript"];\nvar c = sprachen[0];\nvar cPlusPlus = sprachen[1];\nvar java = sprachen[2];\nvar javaScript = sprachen[3];</code></pre>',task:'Schreibe eine Funktion <code>getFirstElement</code>, die ein Array entgegennimmt und die das erste Element des Arrays zur\xFCckgibt.\n<code>getFirstElement([1, 2])</code> sollte <code>1</code> zur\xFCckgeben.',beforeTests:function(){if(typeof getFirstElement!=='undefined'){getFirstElement=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('getFirstElement')},function(){return jshero.testutil.assert_functionHasNumOfParameter('getFirstElement',1)},function(){return jshero.testutil.assert_functionReturns('getFirstElement([1, 2])',1)},function(){return jshero.testutil.assert_functionReturns('getFirstElement(["H\xE4nsel", "Gretel"])','H\xE4nsel')},function(){return jshero.testutil.assert_functionReturns('getFirstElement(["Maus", 1])','Maus')}]});
jshero.koans.add({id:'array3',title:'Array-Elemente schreiben',lesson:'Ebenso wie man Array-Elemente \xFCber einen Index auslesen kann, kann man sie \xFCber diesen Index setzen.\nDabei spielt es keine Rolle, ob das Array vorher gef\xFCllt oder leer war.\n\n<pre><code>var sprachen = [];\nsprachen[0] = "C";\nsprachen[1] = "C++";\nsprachen[2] = "Java";\nsprachen[3] = "JavaScript";</code></pre>\n\nHier wird ein leeres Array nacheinander mit den aufgef\xFChrten Werten gef\xFCllt.',task:'Schreibe eine Funktion <code>setFirstElement</code>, die ein Array und eine beliebige Variable entgegennimmt.\nDie Variable soll als erstes Element in das Array geschrieben werden. Das Array soll dann zur\xFCckgegeben werden.\n<code>setFirstElement([1, 2], 3)</code> sollte <code>[3, 2]</code> zur\xFCckgeben.',beforeTests:function(){if(typeof setFirstElement!=='undefined'){setFirstElement=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('setFirstElement')},function(){return jshero.testutil.assert_functionHasNumOfParameter('setFirstElement',2)},function(){return jshero.testutil.assert_functionReturns('setFirstElement([1, 2], 3)',[3,2])},function(){return jshero.testutil.assert_functionReturns('setFirstElement(["Hein", "Gretel"], "H\xE4nsel")',['H\xE4nsel','Gretel'])},function(){return jshero.testutil.assert_functionReturns('setFirstElement([1, "Maus"], "kleine")',['kleine','Maus'])}]});
jshero.koans.add({id:'arrayindexof',title:'Array: indexOf()',lesson:'Mit der <code>indexOf</code> Methode kann man die Positions des \xFCbergebenen Elements innerhalb eines\nArrays bestimmen. Die Z\xE4hlung beginnt mit 0:\n\n<pre><code>var systems = ["Debian", "Ubuntu", "Mint"];\nvar i1 = systems.indexOf("Mint");\nvar i2 = systems.indexOf("Windows");</code></pre>\n\n<code>i1</code> erh\xE4lt den Wert <code>2</code>, da <code>"Mint"</code> das 2te Element in\n<code>systems</code> ist. <code>i2</code> erh\xE4lt den Wert <code>-1</code>.\nDieser Wert wird zur\xFCckgegeben, wenn sich das \xFCbergebene Element nicht im Array befindet.',task:'Schreibe eine Funktion <code>add</code>, die ein Element an das Ende eines Arrays h\xE4ngt.\nDas Element soll aber nur dann angeh\xE4ngt werden, wenn es sich nicht schon im Array befindet.\n<code>add([1, 2], 3)</code> sollte <code>[1, 2, 3]</code> und <code>add([1, 2], 2)</code>sollte\n<code>[1, 2]</code> zur\xFCckgeben.',beforeTests:function(){if(typeof add!=='undefined'){add=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('add')},function(){return jshero.testutil.assert_functionHasNumOfParameter('add',2)},function(){return jshero.testutil.assert_functionReturns('add(["J"], "S")',['J','S'])},function(){return jshero.testutil.assert_functionReturns('add(["J"], "J")',['J'])},function(){return jshero.testutil.assert_functionReturns('add([1, 2], 3)',[1,2,3])},function(){return jshero.testutil.assert_functionReturns('add([1, 2], 2)',[1,2])}]});
(function(){var random=function(){return Math.round(Math.random()*10)};jshero.koans.add({id:'arraylength',title:'Array: length',lesson:'Die Eigenschaft <code>length</code> hatten wird schon bei Strings kennengelernt. Dort gab sie die Anzahl\nder Zeichen eines Strings zur\xFCck. Bei Arrays gibt sie die Anzahl der Elemente zur\xFCck.\n\n<pre><code>var sprachen = [];\nvar l0 = sprachen.length;\nsprachen[0] = "C";\nvar l1 = sprachen.length;\nsprachen[1] = "C++";\nvar l2 = sprachen.length;</code></pre>\n\nDas leere Array zu Anfang enth\xE4lt keine Elemente. <code>l0</code> ist also <code>0</code>.\nNun f\xFCllen wir das Array nach und nach. <code>l1</code> und <code>l2</code> haben dann die Werte <code>1</code> und <code>2</code>.\nBeachte: Die L\xE4nge eines Arrays ist immer um 1 gr\xF6\xDFer als der h\xF6chste Index des Arrays.',task:'Schreibe eine Funktion <code>getLastElement</code>, die ein Array entgegennimmt und die das letzte Element des Arrays zur\xFCckgibt.\n<code>getLastElement([1, 2])</code> sollte <code>2</code> zur\xFCckgeben.',beforeTests:function(){if(typeof getLastElement!=='undefined'){getLastElement=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('getLastElement')},function(){return jshero.testutil.assert_functionHasNumOfParameter('getLastElement',1)},function(){return jshero.testutil.assert_functionReturns('getLastElement([1, 2])',2)},function(){return jshero.testutil.assert_functionReturns('getLastElement(["H\xE4nsel", "Gretel"])','Gretel')},function(){return jshero.testutil.assert_functionReturns('getLastElement(["a", "b", "c"])','c')},function(){return jshero.testutil.assert_functionReturns('getLastElement(["Maus", 1])',1)},function(){var testArray=new Array;var testArrayString='[';var size=4;for(var i=0;i<size-1;i++){testArray[i]=random();testArrayString+=testArray[i]+', '}testArray[size-1]=random();testArrayString+=testArray[size-1]+']';return jshero.testutil.assert_functionReturns('getLastElement('+testArrayString+')',testArray[size-1])}]})})();
(function(testutil){jshero.koans.add({id:'arraypush',title:'Array: shift() und push()',lesson:'Arrays besitzen eine Reihe von Methoden. Zwei dieser Methoden sind <code>shift</code> und <code>push</code>.\nZur Erinnerung: Methoden sind Funktionen, die auf einem Objekt, hier einem Array, ausgef\xFChrt werden. Methoden werden mit einem Punkt\nan das Objekt angeh\xE4ngt. Wie bei Funktionen \xFCblich folgt dem Methodennamen die runden Klammern, ggf. gef\xFCllt mit Parametern.\n<code>shift</code> hat keine Parameter und verschiebt die Elemente eines Arrays nach links.\nDas 1te Element wird zum 0ten, das 2te zum 1ten, das 3te zum 2ten, usw.\nDas 0te Element wird aus dem Array entfernt und zur\xFCckgegeben. Nach dem <code>shift</code> hat das Array ein Element weniger.\n\n<pre><code>var sprachen = ["C", "Java", "JavaScript"];\nvar naechsteSprache = sprachen.shift();</code></pre>\n\nDas Array <code>sprachen</code> wird mit 3 Programmiersprachen angelegt.\nNach dem <code>shift</code> enth\xE4lt <code>sprachen</code> nur noch 2 Elemente,\nn\xE4mlich <code>["Java", "JavaScript"]</code>. Der Wert <code>"C"</code> ist in der Variablen\n<code>naechsteSprache</code> gelandet.<br>\nMit der h\xE4ufig verwendeten Methode <code>push</code> f\xFCgt man dem Array ein neues Element hinzu.\nDas neue Element wird als Parameter \xFCbergeben und an das Ende des Arrays geh\xE4ngt.\n\n<pre><code>var sprachen = [];\nsprachen.push("C");\nsprachen.push("Java");\nsprachen.push("JavaScript");</code></pre>\n\nHier wird ein leeres Array nacheinander mit den aufgef\xFChrten Werten gef\xFCllt. Am Ende erhalten wir das Array\n<code>["C", "Java", "JavaScript"]</code>. Wir hatten gesehen, dass man ein Array auch per Index f\xFCllen kann.\n<code>sprachen[sprachen.length] = "PHP"</code> ist dasselbe wie <code>sprachen.push("PHP")</code>. Doch schon\nan der L\xE4nge des Codes sieht man, dass die Variante mit <code>push</code> eleganter ist.',task:'Schreibe eine Funktion <code>rotiere</code>, die die Elemente eines Arrays rotiert.\nAlle Elemente des Arrays sollen um eine Position nach links verschoben werden.\nDas 0te Element soll ans Ende des Arrays gestellt werden. Das rotierte Array soll zur\xFCckgegeben werden.\n<code>rotiere(["a", "b", "c"])</code> sollte <code>["b", "c", "a"]</code> ergeben.',hint:'<pre><code>Entferne mit shift das 0te Element.\nF\xFCge mit push das 0te Element wieder hinzu.\n</code></pre>',solution:'<pre><code>var rotiere = function(einArray) {\n  var element0 = einArray.shift();\n  einArray.push(element0);\n  return einArray;\n};</code></pre>',beforeTests:function(){if(typeof rotiere!=='undefined'){rotiere=undefined}},tests:[function(){return testutil.assert_isFunction('rotiere')},function(){return testutil.assert_functionHasNumOfParameter('rotiere',1)},function(){return testutil.assert_functionReturns('rotiere([1, 2])',[2,1])},function(){return testutil.assert_functionReturns('rotiere(["a", "b", "c"])',['b','c','a'])},function(){return testutil.assert_functionReturns('rotiere([1, "b", "c", 37])',['b','c',37,1])}]})})(jshero.testutil);
jshero.koans.add({id:'arraysort',title:'Arrays sortieren',lesson:'Wir k\xF6nnen jetzt Arrays mit vorgegebener L\xE4nge sortieren.',task:'Schreibe eine Funktion <code>sortiere</code>, die ein mit 3 Zahlen gef\xFClltes Array entgegennimmt und die diese 3 Zahlen aufsteigend sortiert als Array  zur\xFCckgibt.\n<code>sortiere([2,&nbsp;3,&nbsp;1])</code> sollte <code>[1,&nbsp;2,&nbsp;3]</code> ergeben.',beforeTests:function(){if(typeof sortiere!=='undefined'){sortiere=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('sortiere')},function(){return jshero.testutil.assert_functionHasNumOfParameter('sortiere',1)},function(){return jshero.testutil.assert_functionReturns('sortiere([1, 2, 3])',[1,2,3])},function(){return jshero.testutil.assert_functionReturns('sortiere([1, 3, 2])',[1,2,3])},function(){return jshero.testutil.assert_functionReturns('sortiere([2, 1, 3])',[1,2,3])},function(){return jshero.testutil.assert_functionReturns('sortiere([2, 3, 1])',[1,2,3])},function(){return jshero.testutil.assert_functionReturns('sortiere([3, 1, 2])',[1,2,3])},function(){return jshero.testutil.assert_functionReturns('sortiere([3, 2, 1])',[1,2,3])}]});
jshero.koans.add({id:"bool",title:"Wahrheitswerte",lesson:"Der dritte wichtige Datentyp neben Strings und Zahlen sind Wahrheitswerte. Sie werden auch boolesche Werte genannt. Boolesche Werte kennen nur zwei Zust\xE4nde: "+"<code>true</code> und <code>false</code>. Mit booleschen Werten kann man \xE4hnlich \"rechnen\" wie mit Zahlen. JavaScript kennt drei boolesche Operatoren: "+"<code>&&</code> (und), <code>||</code> (oder) und <code>!</code> (nicht). Das Ergebnis dieser Operationen ist wieder ein boolescher Wert. "+"<code>&&</code> verkn\xFCpft zwei boolesche Werte. Sind beide Werte <code>true</code>, ist das Ergebnis auch <code>true</code>. In allen anderen F\xE4llen "+"ist es <code>false</code>. Bei <code>||</code> ist das Ergebnis <code>false</code>, wenn beide Eingangswerte auch <code>false</code> sind. In  allen "+"anderen F\xE4llen ist das Ergebnis <code>true</code>. <code>!</code> wird nur auf einen booleschen Wert angewendet und invertiert diesen Wert: aus "+"<code>true</code> wird <code>false</code> und aus <code>false</code> wird <code>true</code>."+"<pre><code>var x1 = true && false;<br>var x2 = !x1;<br>var x3 = x1 || x2;</code></pre>"+"<code>x1</code> ist <code>false</code>,  <code>x2</code> ist <code>true</code> und <code>x3</code> ist ebenfalls <code>true</code>.",task:"Schreibe eine Funktion <code>nand</code>, die zwei boolesche Werte als Parameter entgegennimmt. Die R\xFCckgabe der Funktion soll <code>false</code> sein, "+"wenn beide Paramter <code>true</code> sind. In den anderen F\xE4llen soll die R\xFCckgabe <code>true</code> sein. <code>nand(true, true)</code> "+"soll <code>false</code> liefern, <code>nand(true, false)</code>, <code>nand(false, true)</code> und <code>nand(false, false)</code> sollen <code>true</code> zur\xFCckgeben.",hint:"<pre><code>var nand = function(a, b) {\n  var and = a && b;\n  ...\n};</code></pre>",solution:"<pre><code>var nand = function(a, b) {\n  var and = a && b;\n  return !and;\n};</code></pre>",beforeTests:function(){if(typeof nand!=="undefined"){nand=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("nand")},function(){return jshero.testutil.assert_functionHasNumOfParameter("nand",2)},function(){return jshero.testutil.assert_functionReturns("nand(true, true)",false)},function(){return jshero.testutil.assert_functionReturns("nand(true, false)",true)},function(){return jshero.testutil.assert_functionReturns("nand(false, true)",true)},function(){return jshero.testutil.assert_functionReturns("nand(false, false)",true)}]});
jshero.koans.add({id:'break',title:'break und continue',lesson:'Mit <code>break</code> wird eine Schleife beendet. Das Programm wird nach der Schleife fortgesetzt. '+'<pre><code>var satz = "So ist das.";<br>'+'var i;<br>'+'for (i = 0; i < satz.length; i++) {<br>'+'  if (satz.charAt(i) === " ") {<br>'+'    break;<br>'+'  }<br>'+'}<br>'+'var laengeErstesWort = i;</code></pre>'+'Ist das Zeichen mit dem Index <code>i</code> in <code>satz</code> das Leerzeichen, ist die <code>if</code>-Bedingung erf\xFCllt '+'und der <code>break</code>-Befehl wird ausgef\xFChrt. Die Schleife wird beendet und die Codeausf\xFChrung wird '+'nach der Schleife fortgesetzt. In unserem Beispiel ist das Zeichen mit dem Index <code>2</code> das Leerzeichen. Sobald die Schleifenvariable <code>i</code> '+'den Wert <code>2</code> erreicht hat, wird die Schleife beendet. <code>laengeErstesWort</code> bekommt dann den Wert <code>2</code> zugewiesen.<br><br>'+'Mit <code>continue</code> wird der aktuelle Schleifendurchlauf beendet. Die Programmausf\xFChrung springt zum Schleifenkopf.'+'<pre><code>var summe = 0;<br>'+'for (var i = 0; i < 10; i++) {<br>'+'  if (i % 2 === 0) {<br>'+'    continue;<br>'+'  }<br>'+'  summe = summe + i;<br>'+'}<br></code></pre>'+'Ist <code>i</code> eine ungerade Zahl, so gilt: i modulo 2 = 1. Die <code>if</code> - Bedingung ist nicht erf\xFCllt. '+'Die Codeausf\xFChrung wird nach dem <code>if</code> fortgesetzt und <code>i</code> wird zu <code>summe</code> hinzugez\xE4hlt. '+'Ist <code>i</code> eine gerade Zahl, so gilt: i modulo 2 = 0. Die <code>if</code> - Bedingung ist erf\xFCllt und <code>continue</code> wird ausgef\xFChrt. '+'Die Code-Ausf\xFChrung springt direkt zum Schleifenkopf. <code>i</code> wird nicht zu <code>summe</code> hinzugez\xE4hlt. '+'So werden alle ungeraden Zahlen kleiner 10 aufaddiert.<br>'+'<code>break</code> und <code>continue</code> kann man in allen Schleifen (for, while, do...while) verwenden.',task:'Schreibe eine Funktion <code>isPrime</code>. Sie soll pr\xFCfen, ob eine \xFCbergebene Zahl eine Primzahl ist oder nicht. Ist die '+'Zahl prim, so soll <code>true</code> zur\xFCckgegeben werden, im anderen Fall <code>false</code>. '+'Der Aufruf <code>isPrime(2)</code> soll <code>true</code> zur\xFCckgeben, <code>isPrime(4)</code> soll <code>false</code> ergeben. '+'Eine Primzahl ist eine nat\xFCrliche Zahl, die gr\xF6\xDFer als 1 und nur durch sich selbst und durch 1 teilbar ist.',beforeTests:function(){if(typeof isPrime!=='undefined'){isPrime=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('isPrime')},function(){return jshero.testutil.assert_functionHasNumOfParameter('isPrime',1)},function(){return jshero.testutil.assert_functionReturns('isPrime(1)',false)},function(){return jshero.testutil.assert_functionReturns('isPrime(2)',true)},function(){return jshero.testutil.assert_functionReturns('isPrime(3)',true)},function(){return jshero.testutil.assert_functionReturns('isPrime(4)',false)},function(){return jshero.testutil.assert_functionReturns('isPrime(11)',true)},function(){return jshero.testutil.assert_functionReturns('isPrime(351)',false)},function(){return jshero.testutil.assert_functionReturns('isPrime(281)',true)}]});
(function(ArrayUtil){jshero.koans.add({id:'bubblesort',title:'Bubblesort',lesson:'H\xE4ufig m\xF6chte man Daten der Gr\xF6\xDFe nach sortieren. Hierf\xFCr gibt es verschiedene Sortierverfahren. Ein bekanntes, '+'einfaches, aber auch langsames Verfahren ist <a href="https://de.wikipedia.org/wiki/Bubblesort">Bubblesort</a>. Liegen die zu sortierenden Daten in einem Array der L\xE4nge n vor '+'und sollen die Daten aufsteigend sortiert werden, so wird in einer sogenannten Bubble-Phase das Array vom 1 &apos;ten bis zum n-1 &apos;ten Element durchlaufen. '+'Dabei wird in jedem Schritt das aktuelle Element an der Stelle i mit dem nachfolgenden Element an der Stelle i+1 verglichen. Ist das Element an der Stelle i gr\xF6\xDFer als das '+'Element an der Stelle i+1, so vertauscht man beide Elemente. Hat man so eine Bubble-Phase durchlaufen, ist das gr\xF6\xDFte Element am Ende des Arrays angekommen. '+'Wiederholt man nun eine Bubble-Phase, so steht auch das zweitgr\xF6\xDFte Element an der richtigen Stelle. Hat man n-1 Bubble-Phasen durchlaufen, ist das komplette Array sortiert. '+'Um ein Array mit 4 Zahlen zu sortieren, ben\xF6tigt man also drei Bubble-Phasen:'+'<pre><code>'+'Erste Bubble-Phase:<br>'+'[4, 2, 3, 1] -> [2, 4, 3, 1] Das erste Element wird mit dem zweiten verglichen. Sie werden vertauscht, da 4>2 ist.<br>'+'[2, 4, 3, 1] -> [2, 3, 4, 1] Das zweite Element wird mit dem dritten verglichen. Sie werden vertauscht, da 4>3 ist.<br>'+'[2, 3, 4, 1] -> [2, 3, 1, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden vertauscht, da 4>1 ist.<br>'+'Das gr\xF6\xDFte Element ist an die richtige Stelle geblubbert.<br><br>'+'Zweite Bubble-Phase:<br>'+'[2, 3, 1, 4] -> [2, 3, 1, 4] Das erste Element wird mit dem zweiten verglichen. Sie werden nicht vertauscht, da 2<3 ist.<br>'+'[2, 3, 1, 4] -> [2, 1, 3, 4] Das zweite Element wird mit dem dritten verglichen. Sie werden vertauscht, da 3>1 ist.<br>'+'[2, 1, 3, 4] -> [2, 1, 3, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden nicht vertauscht, da 3<4 ist.<br>'+'Das zweitgr\xF6\xDFte Element ist an die richtige Stelle geblubbert.<br><br>'+'Dritte Bubble-Phase:<br>'+'[2, 1, 3, 4] -> [1, 2, 3, 4] Das erste Element wird mit dem zweiten verglichen. Sie werden vertauscht, da 2>1 ist.<br>'+'[1, 2, 3, 4] -> [1, 2, 3, 4] Das zweite Element wird mit dem dritten verglichen. Sie werden nicht vertauscht, da 2<3 ist.<br>'+'[1, 2, 3, 4] -> [1, 2, 3, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden vertauscht, da 3<4 ist.<br>'+'Das drittgr\xF6\xDFte Element ist an die richtige Stelle geblubbert.<br>'+'Damit ist automatisch auch das kleinste Element an der richtigen Stelle.<br>'+'Das Array ist aufsteigend sortiert.'+'</code></pre>',task:'Schreibe eine Funktion <code>sort</code>, die ein mit Zahlen gef\xFClltes Array entgegennimmt und die diese Zahlen aufsteigend sortiert als Array zur\xFCckgibt. '+'Wird ein leeres Array \xFCbergeben, so soll auch ein leeres Array zur\xFCckgegeben werden. <code>sort([4,&nbsp;2,&nbsp;3,&nbsp;1])</code> sollte <code>[1,&nbsp;2,&nbsp;3,&nbsp;4]</code> ergeben.',beforeTests:function(){if(typeof sort!=='undefined'){sort=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('sort')},function(){return jshero.testutil.assert_functionHasNumOfParameter('sort',1)},function(){return jshero.testutil.assert_functionReturns('sort([])',[])},function(){return jshero.testutil.assert_functionReturns('sort([1])',[1])},function(){return jshero.testutil.assert_functionReturns('sort([3, 1])',[1,3])},function(){return jshero.testutil.assert_functionReturns('sort([3, 1, 2])',[1,2,3])},function(){return jshero.testutil.assert_functionReturns('sort([3, 2, 1])',[1,2,3])},function(){return jshero.testutil.assert_functionReturns('sort([5, 4, 3, 2, 1])',[1,2,3,4,5])},function(){return jshero.testutil.assert_functionReturns('sort(["c", "a", "b"])',['a','b','c'])}]})})(jshero.array);
jshero.koans.add({id:'comment',title:'Kommentare',lesson:'Neben dem eigentlichen Code kann man Kommentare schreiben. Kommentare dienen dazu, Programme zu erkl\xE4ren.\nSie helfen uns Menschen, Programme zu verstehen und zu verwenden.\nComputer, die Programme ausf\xFChren, ignorieren Kommentare. In JavaScript gibt zwei M\xF6glichkeiten, Kommentare zu schreiben:\nZeilen-Kommentare werden mit <code>//</code> eingeleitet und gelten immer bis zum Ende der Zeile.\nBlock-Kommentare werden mit <code>/*</code> eingeleitet und mit <code>*/</code> beendet.\nAlles dazwischen ist Kommentar. Hier ein paar Beispiele:\n<pre><code>// Das ist ein Zeilenkommentar.\n\n// Dieser Zeilenkommentar geht\n// \xFCber 2 Zeilen.\n\n/* Das ist ein Blockkommentar. */\n\n/* Dieser Blockkommentar geht\n\xFCber mehrere Zeilen. */\n\n/**\n * Auch dies ist ein Blockkommentar.\n * Die zus\xE4tzlichen Sterne zwischen\n * dem Beginn und dem Ende des\n * Blockkommentars dienen nur zur\n * Verzierung. So sieht ein l\xE4ngerer\n * Blockkommentar \xFCbersichtlicher aus.\n */</code></pre>\n\n Block-Kommentare schreibt man gerne \xFCber Funktionen, Zeilen-Kommentare in den Code-Fluss.\n\n <pre><code>/**\n * Pr\xFCft, ob eine String kein Zeichen\n * au\xDFer Leerzeichen enth\xE4lt.\n */\nvar isEmpty = function(string) {\n  // Die Methode trim() entfernt Leerzeichen\n  // am Anfang und am Ende einer Zeichenfolge.\n  var trimmedString = string.trim();\n  return trimmedString.length === 0;\n};</code></pre>\n\nDa Kommentare mit den hier verwendeten Tests nicht \xFCberpr\xFCfen werden k\xF6nnen, eine Aufgabe, bei der man vieles von dem bisher Gelernten anwenden muss.',task:'Schreibe eine Funktion <code>median</code>, die ein Array von aufsteigend sortierten Zahlen entgegennimmt und die den Median dieser Zahlen zur\xFCckgibt.\n<code>median([1, 2, 10])</code> sollte <code>2</code> ergeben; <code>median([1, 2, 10, 100])</code> sollte <code>6</code> ergeben.\nDer Median einer sortierten Zahlenreihe ist der Wert, der an der mittleren Stelle steht. Ist die Anzahl der Werte gerade, so ist der Median der Mittelwert\nder beiden mittleren Zahlen.',beforeTests:function(){if(typeof median!=='undefined'){median=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('median')},function(){return jshero.testutil.assert_functionHasNumOfParameter('median',1)},function(){return jshero.testutil.assert_functionReturns('median([1])',1)},function(){return jshero.testutil.assert_functionReturns('median([1, 2])',1.5)},function(){return jshero.testutil.assert_functionReturns('median([1, 2, 10])',2)},function(){return jshero.testutil.assert_functionReturns('median([1, 1, 2, 10, 100, 101])',6)}]});
jshero.koans.add({id:'concat',title:'Array: concat()',lesson:'Mit der <code>concat</code> Methode kann man zwei Arrays aneinanderh\xE4ngen:\n\n<pre><code>var a1 = [1, 2, 3];\nvar a2 = [4, 5, 6];\nvar a3 = a1.concat(a2);</code></pre>\n\n<code>a3</code> enth\xE4lt das Array <code>[1, 2, 3, 4, 5, 6]</code>.\nWichtig ist, dass die beiden urspr\xFCnglichen Arrays <code>a1</code> und <code>a2</code> nicht ver\xE4ndert werden.',task:'Schreibe eine Funktion <code>concatUp</code>, die zwei Arrays zu einem zusammenf\xFChrt.\nDabei soll das l\xE4ngere Array an das k\xFCrzere Array angeh\xE4ngt werden. Sind beide Arrays gleich lang,\nso soll das zweite Array dem ersten Array angeh\xE4ngt werden. <code>concatUp([5, 7], [6])</code> sollte <code>[6, 5, 7]</code>\nund <code>concatUp([5, 7], [6, 8])</code> sollte <code>[5, 7, 6, 8]</code> ergeben.',beforeTests:function(){if(typeof concatUp!=='undefined'){concatUp=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('concatUp')},function(){return jshero.testutil.assert_functionHasNumOfParameter('concatUp',2)},function(){return jshero.testutil.assert_functionReturns('concatUp([5, 7], [6])',[6,5,7])},function(){return jshero.testutil.assert_functionReturns('concatUp(["x"], ["a", "b"])',['x','a','b'])},function(){return jshero.testutil.assert_functionReturns('concatUp([5, 7], [6, 8])',[5,7,6,8])}]});
jshero.koans.add({id:'date',title:'Datum und Uhrzeit',lesson:'Um mit Datum und Uhrzeit zu arbeiten, verwendet man <code>Date</code>-Objekte. Ein <code>Date</code>-Objekt repr\xE4sentiert\neinen Zeitpunkt, also ein Datum zusammen mit einer Uhrzeit. Die Uhrzeit wird dabei auf die Millisekunde genau festgelegt.\nEin Date-Objekt erzeugt man mit <code>new Date()</code>. Es gibt 4 m\xF6gliche Aufrufe:\n\n<pre><code>// aktueller Zeitpunkt\nvar d1 = new Date();</code></pre>\n\nOhne Parameter erzeugt <code>new Date()</code> ein Date-Objekt, das dem Zeitpunkt seines Aufrufs entspricht. Wird obiges Beispiel\nam 1. Mai 2017 um 8:15 Uhr aufgerufen, so enth\xE4lt <code>d1</code> eben diesen Zeitpunkt.\n\n<pre><code>// Aufruf mit Jahr, Monat, Tag, Stunde,\n// Stunde, Minute, Sekunde, Millisekunde\nvar d2 = new Date(2017, 2, 8, 16, 31, 10, 117);</code></pre>\n\nM\xF6chte man ein Date-Objekt zu einem bestimmten Zeitpunkt erstellen, verwendet man am besten die zweite M\xF6glichkeit.\nHier \xFCbergibt man als Parameter das Jahr, den Monat, den Tag, die Stunde, die Minute, die Sekunde und die Millisekunde.\nDas Jahr muss in voller L\xE4nge \xFCbergeben werden. <code>17</code> ergibt das Jahr 17 n. Chr. und <code>2017</code> das Jahr 2017 n. Chr.\nBei dem Monat muss man aufpassen. JavaScript nummeriert die Monate von 0 (Januar) bis 11 (Dezember).\nAlle weiteren Zahlen entsprechen der \xFCblichen Bedeutung. <code>d2</code> repr\xE4sentiert also den\nZeitpunkt 8.3.2017, 16:31:10 Uhr und 117 Millisekunden.<br>\nDie Parameter Millisekunde, Sekunde, Minute, Stunde und Tag sind - in dieser Reihenfolge - optional. Man kann sie weglassen.\nGibt man sie nicht an, werden die Zeitangaben automatisch auf 0 gesetzt. Der Tag wird auf den Monatsersten gesetzt.\nDas ist besonders praktisch, wenn man nur mit einem Datum arbeiten m\xF6chte.\nDann l\xE4\xDFt man einfach alle Zeitangaben weg. <code>new&nbsp;Date(2017, 5, 2)</code> ist der 2.6.2017, 0:00 Uhr.\n\n<pre><code>// Millisekunden seit dem 1.1.1970\nvar d3 = new Date(86400000);</code></pre>\n\nBei der dritten Variante \xFCbergibt man die vergangenen Millisekunden seit dem 1.1.1970, 0:00 Uhr.\nDer Bezugspunkt 1.1.1970 f\xFCr Datumsangaben ist seit den Tagen von Unix und der Programmiersprache C in der IT \xFCblich geworden.\nEin Tag hat 24 * 60 * 60 * 1000 = 86400000 Millisekunden. <code>d3</code> ist also der 2.1.1970, 0:00 Uhr.\n\n<pre><code>// \xDCbergabe eines Datumsstrings\nvar d4 = new Date("2017-3-8T16:31:10.117");</code></pre>\n\nBei der vierten Variante wird ein Datumsstring in einem bestimmten Format, d.h. in einer bestimmten Schreibweise, \xFCbergeben.\n<code>d4</code> entspricht ebenfalls dem Zeitpunkt 8.3.2017, 16:31:10 Uhr und 117 Millisekunden. Diese Varainte ist jedoch nicht zu empfehlen,\nda verschiedene Browser leichte Unterschiede bei der Bestimmung des Datums aufweisen.',task:'Schreibe eine Funktion <code>nikolaus</code>, die eine Jahreangabe als Zahl entgegennimmt und die ein Date-Objekt mit dem 6. Dezember\ndes \xFCbergebenen Jahres, 0:00 Uhr, zur\xFCckgibt. <code>nikolaus(2017)</code> sollte ein Date-Objekt mit dem Zeitpunkt 6.12.2017, 0:00 Uhr zur\xFCckgeben.',beforeTests:function(){if(typeof nikolaus!=='undefined'){nikolaus=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('nikolaus')},function(){return jshero.testutil.assert_functionHasNumOfParameter('nikolaus',1)},function(){return jshero.testutil.assert_functionReturnsType('nikolaus(2017)','Date')},function(){return jshero.testutil.assert_functionReturns('nikolaus(2017)',new Date(2017,11,6))},function(){return jshero.testutil.assert_functionReturnsType('nikolaus(1960)','Date')},function(){return jshero.testutil.assert_functionReturns('nikolaus(1960)',new Date(1960,11,6))}]});
jshero.koans.add({id:'date2',title:'Datum und Uhrzeit ausgeben',lesson:'Zur Ausgabe der Daten eines Date-Objekts gibt es sieben sogenannte Getter-Methoden:\n\n<pre><code>var startFastnacht = new Date(2017, 10, 11, 11, 11);\nvar jahr = startFastnacht.getFullYear();\nvar monat = startFastnacht.getMonth();\nvar tag = startFastnacht.getDate();\nvar stunde = startFastnacht.getHours();\nvar minute = startFastnacht.getMinutes();\nvar sekunde = startFastnacht.getSeconds();\nvar millisekunde = startFastnacht.getMilliseconds();</code></pre>\n\nMan erh\xE4lt die erwarteten Werte: <code>2017</code> f\xFCr das Jahr, <code>10</code> f\xFCr den Monat,\n<code>11</code> f\xFCr den Tag, die Stunde und die Minute, sowie <code>0</code> f\xFCr die Sekunde und die Millisekunde.\nDie Monatsz\xE4hlung beginnt wie beim Erzeugen eines Date-Objektes mit <code>0</code>.\nDie Zahl <code>10</code> steht also f\xFCr den November.',task:'Schreibe eine Funktion <code>toGerman</code>, die ein Date-Objekt entgegennimmt und dessen Datum im Format "d.M.YYYY" zur\xFCckgibt.\nMit <code>date = new Date(2017, 2, 8)</code> sollte <code>toGerman(date)</code> den String <code>"8.3.2017"</code> zur\xFCckgeben.',beforeTests:function(){if(typeof toGerman!=='undefined'){toGerman=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('toGerman')},function(){return jshero.testutil.assert_functionHasNumOfParameter('toGerman',1)},function(){return jshero.testutil.assert_functionReturns('toGerman(new Date(2017, 2, 8))','8.3.2017')},function(){return jshero.testutil.assert_functionReturns('toGerman(new Date(1724, 3, 22))','22.4.1724')}]});
jshero.koans.add({id:'date3',title:'Datum und Uhrzeit \xE4ndern',lesson:'Passend zu den sieben Getter-Methoden besitzt das Date-Objekt sieben Setter-Methoden:\n<code>setFullYear</code>, <code>setMounth</code>, <code>setDate</code>, <code>setHours</code>, <code>setMinutes</code>,\n<code>setSeconds</code> und <code>setMilliseconds</code>.\nMit diesen 7 Methoden kann man den entsprechenden Date-Eintrag setzen:\n\n<pre><code>var today = new Date();\ntoday.setHours(0);\ntoday.setMinutes(0);\ntoday.setSeconds(0);\ntoday.setMilliseconds(0);</code></pre>\n\n<code>today</code> enth\xE4lt zun\xE4chst den Zeitpunkt seiner Erstellung.\nAnschlie\xDFend wird mit den vier Setter-Aufrufen die Zeit auf 0:00:00.000 Uhr gesetzt.\nSo enth\xE4lt <code>today</code> das aktuelle Tagesdatum mit zur\xFCckgesetzter Uhrzeit.<br><br>\n\xDCberschreitet oder unterschreitet man bei einer dieser Methoden den zul\xE4ssigen Wertebereich,\ndann rechnen diese Methoden den \xDCber- oder Untertrag automatisch um:\n\n<pre><code>var someDay = new Date(2020, 3, 1);\nsomeDay.setDate(32);\nsomeDay.setDate(0);</code></pre>\n\nZun\xE4chst repr\xE4sentiert <code>someDay</code> den 1.4.2020. Nun wird der Tag auf den 32. gesetzt.\nDa der April 30 Tage hat, entspricht das dem 2.5.2020. Wird nun der Tag auf 0 gesetzt, erh\xE4lt man den 30.4.2020.',task:'Schreibe eine Funktion <code>yesterday</code>, die ein Date-Objekt entgegennimmt, dessen Datum um einen Tag zur\xFCcksetzt\nund dann dieses Date-Objekt zur\xFCckgibt. Die Uhrzeit soll dabei nicht ver\xE4ndert werden. Mit <code>date = new Date(1965, 8, 14)</code>\nsollte <code>yesterday(date)</code> ein Date-Objekt zur\xFCckgeben, das den 13.9.1965 repr\xE4sentiert.',beforeTests:function(){if(typeof yesterday!=='undefined'){yesterday=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('yesterday')},function(){return jshero.testutil.assert_functionHasNumOfParameter('yesterday',1)},function(){return jshero.testutil.assert_functionReturnsType('yesterday(new Date(2015, 8, 14))','Date')},function(){return jshero.testutil.assert_functionReturns('yesterday(new Date(2015, 8, 14))',new Date(2015,8,13))},function(){return jshero.testutil.assert_functionReturnsType('yesterday(new Date(2018, 0, 1, 12))','Date')},function(){return jshero.testutil.assert_functionReturns('yesterday(new Date(2018, 0, 1, 12))',new Date(2017,11,31,12))}]});
jshero.koans.add({id:'dowhile',title:'do...while-Schleife',lesson:'Die <code>do...while</code>-Schleife funktioniert \xE4hnlich wie die <code>while</code>-Schleife.\nDer Schleifen-Code wird ausgef\xFChrt, solange die Schleifenbedingung <code>true</code> ergibt.\nEinziger Unterschied ist, dass die Schleifenbedingung nach dem Schleifen-Code \xFCberpr\xFCft wird.\nDadurch ist sichergestellt, dass der Schleifen-Code mindestens einmal durchlaufen wird.\n\n<pre><code>var restDurch6;\nvar restDurch8;\nvar kgV = 0;\ndo {\n  kgV++;\n  restDurch6 = kgV % 6;\n  restDurch8 = kgV % 8;\n} while (restDurch6 !== 0 || restDurch8 !== 0)</code></pre>\n\nDieser Codeabschnitt berechnet das\n<a href="https://de.wikipedia.org/wiki/Kleinstes_gemeinsames_Vielfaches">kleinste gemeinsame Vielfache (kgV)</a> von 6 und 8.\nDas kgV ist die kleinste Zahl, die sowohl ein Vielfaches von 6 als auch ein Vielfaches von 8 ist.\nDie Vielfachen von 6 sind 6, 12, 18, 24, 30, ... und die Vielfachen von 8 sind 8, 16, 24, 32, ... .\nDamit ist das kgV von 6 und 8 die Zahl 24.<br>\nUnser Codebeispiel pr\xFCft beginnend mit <code>1</code>, ob <code>kgV</code> sowohl durch <code>6</code> als auch durch <code>8</code> teilbar ist.\nDie Teilbarkeit wird mithilfe des Modulo-Operators \xFCberpr\xFCft. Eine Zahl ist durch 6 bzw. 8 teilbar,\nwenn sie Modulo 6 bzw. Modulo 8 den Wert 0 liefert. Die Modulo-Berechnung findet im Schleifen-Code statt.\nIn der Schleifenbedingung wird dann \xFCberpr\xFCft, ob beide Modulo-Berechnungen <code>0</code> ergeben. Ist eine von beiden\nModulo-Berechnungen nicht <code>0</code>, ist die Schleifenbedingung <code>true</code> und der Schleifen-Code wird mit einem um 1 erh\xF6hten <code>kgV</code>\nerneut durchlaufen. Ergeben beide Modulo-Berechnungen <code>0</code>, ist die Schleifenbedingung <code>false</code> und die Schleife wird beendet.\n<code>kgV</code> hat dann den gew\xFCnschten Wert (n\xE4mlich 24), da es die erste Zahl ist, die sowohl durch 6 als auch durch 8 teilbar ist.',task:'Schreibe eine Funktion <code>kgV</code>, die zwei nat\xFCrliche Zahlen als Parameter entgegennimmt und deren kgV berechnet.\n<code>kgV(6, 8)</code> sollte <code>24</code> zur\xFCckgeben.',beforeTests:function(){if(typeof kgV!=='undefined'){kgV=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('kgV')},function(){return jshero.testutil.assert_functionHasNumOfParameter('kgV',2)},function(){return jshero.testutil.assert_functionReturns('kgV(1, 1)',1)},function(){return jshero.testutil.assert_functionReturns('kgV(1, 2)',2)},function(){return jshero.testutil.assert_functionReturns('kgV(2, 3)',6)},function(){return jshero.testutil.assert_functionReturns('kgV(3, 2)',6)},function(){return jshero.testutil.assert_functionReturns('kgV(4, 6)',12)},function(){return jshero.testutil.assert_functionReturns('kgV(5, 7)',35)},function(){return jshero.testutil.assert_functionReturns('kgV(6, 8)',24)},function(){return jshero.testutil.assert_functionReturns('kgV(10, 20)',20)},function(){return jshero.testutil.assert_functionReturns('kgV(20, 10)',20)}]});
jshero.koans.add({id:'else',title:'if...else',lesson:'Soll ein Codeblock nur dann ausgef\xFChrt werden, wenn eine <code>if</code>-Bedingung\nnicht erf\xFCllt ist, verwendet man zus\xE4tzlich zum <code>if</code> ein <code>else</code> (engl.: sonst).\n\n<pre><code>var mitteilung;\nif (betrag > 1000) {\n  mitteilung = "Keine Auszahlung m\xF6glich!";\n} else {\n  mitteilung = "Der Betrag wird ausgezahlt!";\n}</code></pre>\n\nJe nachdem, ob <code>betrag</code> gr\xF6\xDFer oder kleiner <code>1000</code> ist, wird entweder der\n<code>if</code>-Zweig oder der <code>else</code>-Zweig ausgef\xFChrt.',task:'Schreibe eine Funktion <code>addiereMitZuschlag</code>, die zwei Betr\xE4ge mit Zuschlag addiert.\nF\xFCr jeden Betrag, der kleiner gleich <code>10</code> ist, betr\xE4gt der Zuschlag <code>1</code>.\nF\xFCr jeden Betrag, der gr\xF6\xDFer <code>10</code> ist, betr\xE4gt der Zuschlag <code>2</code>.\nDer Aufruf <code>addiereMitZuschlag(5, 15)</code> sollte <code>23</code> ergeben.',beforeTests:function(){if(typeof addiereMitZuschlag!=='undefined'){addiereMitZuschlag=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('addiereMitZuschlag')},function(){return jshero.testutil.assert_functionHasNumOfParameter('addiereMitZuschlag',2)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(1, 1)',4)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(10, 10)',22)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(11, 10)',24)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(10, 11)',24)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(11, 11)',26)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(15, 27)',46)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(5, 25)',33)}]});
jshero.koans.add({id:'elseif',title:'else if',lesson:'M\xF6chte man mehrere F\xE4lle unterscheiden, kann man ein <code>if</code> mit beliebig vielen <code>else if</code>\nerg\xE4nzen. Zum Schluss kann bei Bedarf noch ein einzelnes <code>else</code> stehen.\n\n<pre><code>var mitteilung;\nif (betrag > 1000) {\n  mitteilung = "Zu gro\xDF. Keine Auszahlung m\xF6glich!";\n} else if (betrag < 10) {\n  mitteilung = "Zu klein. Keine Auszahlung m\xF6glich!";\n} else {\n  mitteilung = "Der Betrag wird ausgezahlt!";\n}</code></pre>\n\nZuerst wird gepr\xFCft, ob <code>betrag</code> gr\xF6\xDFer <code>1000</code> ist. Ist das der Fall, wird die "Zu gro\xDF..."-Mitteilung\ngesetzt und der Code am Ende des gesamten Blocks fortgesetzt. Ist das nicht der Fall, wird die <code>else if</code>-Bedingung\ngepr\xFCft. Ist diese erf\xFCllt, wird die "Zu klein..."-Mitteilung gesetzt und der Code am Ende des gesamten Blocks fortgesetzt.\nErst wenn keine Bedingung erf\xFCllt ist, wird der abschlie\xDFenden <code>else</code>-Block ausgef\xFChrt.',task:'Schreibe eine Funktion <code>addiereMitZuschlag</code>, die zwei Betr\xE4ge mit Zuschlag addiert.\nF\xFCr jeden Betrag, der kleiner gleich <code>10</code> ist, betr\xE4gt der Zuschlag <code>1</code>. F\xFCr jeden\nBetrag, der gr\xF6\xDFer <code>10</code> und kleiner gleich <code>20</code> ist, betr\xE4gt der Zuschlag <code>2</code>.\nF\xFCr jeden Betrag, der gr\xF6\xDFer <code>20</code> ist, betr\xE4gt der Zuschlag <code>3</code>. <code>addiereMitZuschlag(10, 30)</code>\nsollte <code>44</code> ergeben.',beforeTests:function(){if(typeof addiereMitZuschlag!=='undefined'){addiereMitZuschlag=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('addiereMitZuschlag')},function(){return jshero.testutil.assert_functionHasNumOfParameter('addiereMitZuschlag',2)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(1, 1)',4)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(10, 9)',21)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(11, 10)',24)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(10, 11)',24)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(13, 20)',37)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(20, 13)',37)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(15, 27)',47)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(27, 15)',47)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(25, 5)',34)},function(){return jshero.testutil.assert_functionReturns('addiereMitZuschlag(5, 25)',34)}]});
jshero.koans.add({id:'equals',title:'Strikte Gleichheit',lesson:'Zwei Werte kann man auf strikte Gleichheit \xFCberpr\xFCfen. Das Ergebnis eines solchen Vergleichs ist entweder\n<code>true</code>, die beiden Werte sind gleich, oder <code>false</code>, die beiden Werte sind ungleich.\nDer Operator f\xFCr strikte Gleichheit ist <code>===</code>.\n\n<pre><code>var sprache = "JavaScript";\nvar x = 10;\nvar v1 = sprache === "Java";\nvar v2 = x === 10;\nvar v3 = x === "10";</code></pre>\n\n<code>v1</code> bekommt das Ergebnis des Vergleichs der Variablen <code>sprache</code> mit dem Wert\n<code>"Java"</code> zugewiesen. Da <code>sprache</code> zuvor den Wert <code>JavaScript</code> erhalten hat und\ndiese beiden Werte verschieden sind, hat <code>v1</code> den Wert <code>false</code>. <code>v2</code> ist\n<code>true</code>, da der Wert von <code>x</code> gleich <code>10</code> ist. Bei der strikten Gleichheit kommt es\nauch darauf an, dass die Datentypen der beiden verglichenen Werte gleich sind. <code>v3</code> ist <code>false</code>,\nda hier unterschiedliche Typen verglichen werden. Auf der linken Seite des Vergleichs steht eine Zahl, auf der\nrechten Seite ein String.',task:'Schreibe eine Funktion <code>gleich</code>, die zwei Werte auf strikte Gleichheit \xFCberpr\xFCft.\n<code>gleich(1, 1)</code> soll <code>true</code> zur\xFCckgeben, <code>gleich(1, 2)</code> soll\n<code>false</code> ergeben.',hint:'<pre><code>var gleich = function(a, b) {\n  return ...\n};</code></pre>',solution:'<pre><code>var gleich = function(a, b) {\n  return a === b;\n};</code></pre>',beforeTests:function(){if(typeof gleich!=='undefined'){gleich=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('gleich')},function(){return jshero.testutil.assert_functionHasNumOfParameter('gleich',2)},function(){return jshero.testutil.assert_functionReturns('gleich(1, 1)',true)},function(){return jshero.testutil.assert_functionReturns('gleich(1, "1")',false)},function(){return jshero.testutil.assert_functionReturns('gleich(1, 2)',false)},function(){return jshero.testutil.assert_functionReturns('gleich("klein", "klein")',true)},function(){return jshero.testutil.assert_functionReturns('gleich("Links", "Rechts")',false)}]});
jshero.koans.add({id:'equals2',title:'Drei gleiche Werte',lesson:'Die folgende Aufgabe soll das Zusammenspiel von strikter Gleichheit und booleschen Operatoren vertiefen.',task:'Schreibe eine Funktion <code>gleich</code>, die 3 Werte auf strikte Gleichheit \xFCberpr\xFCft. Die Funktion soll nur '+'dann <code>true</code> ergeben, wenn alle 3 Werte strikt gleich sind. <code>gleich(1, 1, 1)</code> soll '+'<code>true</code> zur\xFCckgeben, <code>gleich(1, 1, 2)</code> soll <code>false</code> ergeben.',beforeTests:function(){if(typeof gleich!=='undefined'){gleich=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('gleich')},function(){return jshero.testutil.assert_functionHasNumOfParameter('gleich',3)},function(){return jshero.testutil.assert_functionReturns('gleich(1, 1, 1)',true)},function(){return jshero.testutil.assert_functionReturns('gleich(1, 1, 2)',false)},function(){return jshero.testutil.assert_functionReturns('gleich("1", 1, 1)',false)},function(){return jshero.testutil.assert_functionReturns('gleich(1, "1", 1)',false)},function(){return jshero.testutil.assert_functionReturns('gleich(1, 1, "1")',false)},function(){return jshero.testutil.assert_functionReturns('gleich("klein", "klein", "klein")',true)},function(){return jshero.testutil.assert_functionReturns('gleich("klein", "klein", "gro\xDF")',false)}]});
jshero.koans.add({id:'even',title:'Gerade Zahlen',lesson:'Diese Aufgabe soll das Zusammenspiel von strikter Gleichheit und dem Modulo-Operator vertiefen.',task:'Schreibe eine Funktion <code>istGerade</code>, die angibt, ob eine \xFCbergebene Zahl gerade oder ungerade ist.\nIst die \xFCbergebene Zahl gerade, so soll die Funktion <code>true</code> zur\xFCckgeben, andernfalls <code>false</code>.\n<code>istGerade(6)</code> soll <code>true</code> ergeben und <code>istGerade(7)</code> soll <code>false</code> zur\xFCckgeben.',beforeTests:function(){if(typeof istGerade!=='undefined'){istGerade=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('istGerade')},function(){return jshero.testutil.assert_functionHasNumOfParameter('istGerade',1)},function(){return jshero.testutil.assert_functionReturns('istGerade(0)',true)},function(){return jshero.testutil.assert_functionReturns('istGerade(1)',false)},function(){return jshero.testutil.assert_functionReturns('istGerade(2)',true)},function(){return jshero.testutil.assert_functionReturns('istGerade(37)',false)},function(){return jshero.testutil.assert_functionReturns('istGerade(208)',true)}]});
jshero.koans.add({id:"fahrenheit",title:"Fahrenheit",lesson:"Die folgende Aufgabe ist dem <a href=\"https://www.freecodecamp.org\">freeCodeCamp</a> entnommen.",task:"Schreibe eine Funktion <code>toFahrenheit</code>, die eine Temperaturangabe von\n<a href=\"https://de.wikipedia.org/wiki/Grad_Celsius\">Grad Celsius</a> in\n<a href=\"https://de.wikipedia.org/wiki/Grad_Fahrenheit\">Grad Fahrenheit</a> umrechnet. Ist C die Temperatur in Grad Celsius\nund F die Temperatur in Grad Fahrenheit, so gilt: F = 1.8 * C + 32. <code>toFahrenheit(0)</code> sollte <code>32</code> ergeben.",hint:"<pre><code>var toFahrenheit = function(celsius) {\n  return ...\n};",solution:"<pre><code>var toFahrenheit = function(celsius) {\n  return 1.8 * celsius + 32;\n};",beforeTests:function(){if(typeof add!=="undefined"){add=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("toFahrenheit")},function(){return jshero.testutil.assert_functionHasNumOfParameter("toFahrenheit",1)},function(){return jshero.testutil.assert_functionReturns("toFahrenheit(0)",32)},function(){return jshero.testutil.assert_functionReturns("toFahrenheit(10)",50)},function(){return jshero.testutil.assert_functionReturns("toFahrenheit(40)",104)},function(){return jshero.testutil.assert_functionReturns("toFahrenheit(100)",212)}]});
(function(testutil){jshero.koans.add({id:'for1',title:'for-Schleife',lesson:'Mit Schleifen k\xF6nnen Code-Abschnitte mehrmals durchlaufen werden. JavaScript kennt mehrere Schleifenarten.\nDie einfachste ist die <code>for</code>-Schleife.\n\n<pre><code>var summe = 0;\nfor (var i = 1; i < 3; i++) {\n  summe = summe + i;\n}</code></pre>\n\nDie <code>for</code>-Schleife besteht aus drei Steuer-Anweisungen und dem Schleifen-Code. Die drei Anweisungen folgen dem <code>for</code> in runden Klammern.\nSie werden durch Semikolons voneinander getrennt. Die erste Anweisung ist die Start-Anweisung. Sie wird einmal zu Beginn der Schleife ausgef\xFChrt.\nHier wird normalerweise eine Variable, die sogenannte Schleifenvariable, initialisiert. Die zweite Anweisung ist die Schleifen-Bedingung.\nSie wird vor jedem Schleifendurchlauf zu <code>true</code> oder <code>false</code> ausgewertet.\nIst der Ausdruck <code>true</code>, wird der Schleifen-Code ausgef\xFChrt.\nIst er <code>false</code>, wird die Schleife beendet und die Programmausf\xFChrung wird nach der Schleife fortgesetzt.\nNach jedem Schleifen-Durchlauf wird die dritte Anweisung, die sogenannten End-Anweisung, ausgef\xFChrt.\nHier wird normalerweise die Schleifenvariable erh\xF6ht.\nAnschlie\xDFend beginnt ein neuer Schleifendurchlauf mit erneuter Auswertung der Schleifen-Bedingung.\nDer Schleifen-Code folgt in Mengenklammern den drei Steueranweisungen.\nIn unserem Beispiel hat <code>summe</code> zun\xE4chst den Wert <code>0</code>. In der Start-Anweisung wird <code>i</code> mit <code>1</code> initialisiert.\nDie Schleifenbedingung <code>1 < 3</code> ist erf\xFCllt, also wird der Schleifen-Code ausgef\xFChrt.\n<code>summe</code> erh\xE4lt den Wert <code>0 + 1</code>, also <code>1</code>.\nNun wird in der End-Anweisung <code>i</code> um <code>1</code> erh\xF6ht (<code>i++</code> ist identisch mit <code>i = i + 1</code>).\nEs erh\xE4lt also den Wert <code>2</code>. Der zweite Schleifendurchlauf startet mit Auswertung der Schleifenbedingung.\nDiese Bedingung (<code>2 < 3</code>) ist immer noch erf\xFCllt.\nDer Schleifen-Code wird erneut ausgef\xFChrt und <code>summe</code> erh\xE4lt jetzt den Wert <code>1 + 2</code>, also <code>3</code>.\n<code>i</code> wird abermals erh\xF6ht und hat nun den Wert <code>3</code>.\nDie Schleifenbedingung <code>3 < 3</code> ist jetzt nicht mehr erf\xFCllt. Die Schleife wird beendet und die Programmausf\xFChrung wird nach der Schleife fortgesetzt.\nUnser Codebeispiel hat also alle nat\xFCrlichen Zahlen echt kleiner 3 addiert.',task:'Schreibe eine Funktion <code>addiereBis</code>, die eine Zahl als Parameter entgegennimmt und die\nalle nat\xFCrlichen Zahlen kleiner gleich dem Paramter aufaddiert. Das Ergebnis der Addition soll zur\xFCckgegeben werden.\n<code>addiereBis(3)</code> sollte <code>1+2+3</code> = <code>6</code> ergeben.',hint:'<pre><code>var addiereBis = function(n) {\n  var summe = 0;\n  for (var i = 0; i <= n; i++) {\n    ...\n  }\n  return summe;\n};</pre></code>',solution:'<pre><code>var addiereBis = function(n) {\n  var summe = 0;\n  for (var i = 0; i <= n; i++) {\n    summe = summe + i;\n  }\n  return summe;\n};</pre></code>',beforeTests:function(){if(typeof addiereBis!=='undefined'){addiereBis=undefined}},tests:[function(){return testutil.assert_isFunction('addiereBis')},function(){return testutil.assert_functionHasNumOfParameter('addiereBis',1)},function(){return testutil.assert_functionReturns('addiereBis(0)',0)},function(){return testutil.assert_functionReturns('addiereBis(1)',1)},function(){return testutil.assert_functionReturns('addiereBis(2)',3)},function(){return testutil.assert_functionReturns('addiereBis(3)',6)},function(){return testutil.assert_functionReturns('addiereBis(9)',45)}]})})(jshero.testutil);
jshero.koans.add({id:'for2',title:'Schleifen und Arrays',lesson:'<code>for</code>-Schleifen eignen sich besonders gut zum Durchlaufen von Arrays.\nIm folgenden Beispiel werden die Elemente eines Arrays aufaddiert:\n\n<pre><code>var sum = 0;\nfor (var i = 0; i < myArray.length; i++) {\n  sum = sum + myArray[i];\n}</code></pre>',task:'Schreibe eine Funktion <code>mean</code>, die ein Array gef\xFCllt mit Zahlen entgegennimmt und den\nDurchschnitt dieser Zahlen zur\xFCckgibt. Tipp: Um den Durchschnitt von n Zahlen zu berechnen,\nmu\xDFt du die Zahlen aufaddieren und die erhaltene Summe durch n teilen.\n<code>mean([1, 2, 3])</code> sollte <code>(1+2+3)/3</code> = <code>2</code> ergeben.',beforeTests:function(){if(typeof mean!=='undefined'){mean=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('mean')},function(){return jshero.testutil.assert_functionHasNumOfParameter('mean',1)},function(){return jshero.testutil.assert_functionReturns('mean([0])',0)},function(){return jshero.testutil.assert_functionReturns('mean([1, 2])',1.5)},function(){return jshero.testutil.assert_functionReturns('mean([1, 2, 3])',2)},function(){return jshero.testutil.assert_functionReturns('mean([-2, -4, 17, 34])',11.25)}]});
(function(testutil){jshero.koans.add({id:"function",title:"Funktionen",lesson:"Eine Funktion ist ein Block von Anweisungen, der beliebig oft ausgef\xFChrt werden kann. Eine Funktion kann\nParameter entgegennehmen und eine Funktion kann einen Wert zur\xFCckgeben. Funktionen werden mit dem Schl\xFCsselwort\n<code>function</code> definiert. Darauf folgen in runden Klammern eingeschlossen die Parameter und anschlie\xDFend,\neingeschlossen in geschweiften Klammern, die Anweisungen. Mit dem Schl\xFCsselwort <code>return</code> kann ein Wert\nzur\xFCckgegeben werden. Gleichzeitig beendet <code>return</code> die Funktion. Anweisungen nach einem <code>return</code>\nwerden nicht mehr ausgef\xFChrt. Funktionen kann man Variablen zuordnen. Mit\n\n<pre><code>var farbe = function() {\n  return \"gr\xFCn\";\n};</code></pre>\n\ndefinieren wir eine Funktion, die <code>\"gr\xFCn\"</code> zur\xFCckgibt. Die Funktion nimmt keine Paramter entgegen\n(die runde Klammer ist leer) und sie enth\xE4lt genau eine Anweisung, die R\xFCckgabe. Die Funktion wird der Variablen\n<code>farbe</code> zugeordnet. \xDCber diese Variable wird die Funktion aufgerufen:\n\n<pre><code>var ergebnis = farbe();</code></pre>\n\nJetzt wird die Funktion ausgef\xFChrt. Ihre R\xFCckgabe wird der Variablen <code>ergebnis</code> zugewiesen.\n<code>ergebnis</code> hat dann den Wert <code>\"gr\xFCn\"</code>.",task:"Deklariere eine Variable <code>hallo</code> und weise ihr eine Funktion zu, die <code>\"Hallo Welt!\"</code> zur\xFCckgibt.",hint:"<pre><code>var hallo = function() {\n  ...\n};</code></pre>",solution:"<pre><code>var hallo = function() {\n  return \"Hallo Welt!\";\n};</code></pre>",beforeTests:function(){if(typeof hallo!=="undefined"){hallo=undefined}},tests:[function(){return testutil.assert_isFunction("hallo")},function(){return testutil.assert_functionReturns("hallo()","Hallo Welt!")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"function2",title:"Mehrere Funktionen",lesson:"Wir definieren nun mehr als eine Funktion.\n  Zur Erinnerung: So wird eine Funktion mit Namen <code>farbe</code> definiert, die den Wert <code>\"rot\"</code>\n  zur\xFCckgibt:\n\n<pre><code>var farbe = function() {\n  return \"rot\";\n};</code></pre>",task:"Definiere zwei Funktionen. Die erste Funktion <code>a</code> soll <code>\"Hallo a!\"</code>\nzur\xFCckgeben. Die zweite Funktion <code>b</code> soll <code>\"Hallo b!\"</code> zur\xFCckgeben.",beforeTests:function(){a=undefined;b=undefined},tests:[function(){return testutil.assert_isFunction("a")},function(){return testutil.assert_isFunction("b")},function(){return testutil.assert_functionReturns("a()","Hallo a!")},function(){return testutil.assert_functionReturns("b()","Hallo b!")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"functioncall",title:"Funktionsaufrufe",lesson:"Wichtig ist der Unterschied zwischen der Definition und dem Aufruf einer Funktion.\nMit der Definition, z. B.\n\n<pre><code>var f = function() {\n  return \"hallo\";\n};</code></pre>\n\nwird festgelegt, was die Funktion machen soll. Sie wird dabei nicht ausgef\xFChrt. Sie wird lediglich zur Ausf\xFChrung bereitgestellt.\nErst mit ihrem Aufruf\n\n<pre><code>var x = f();</code></pre>\n\nwird die Funktion ausgef\xFChrt. Dann werden die Anweisungen im Funktionsblock der Reihe nach abgearbeitet.\nDie R\xFCckgabe der Funktion wird in diesem Beispiel der Variablen <code>x</code> zugewiesen.\nDefiniert werden Funktionen mit dem Schl\xFCsselwort <code>function</code>.\nIst die Funktion einer Variablen zugewiesen, geschieht der Aufruf der Funktion \xFCber diese Variable.\nFunktionen werden einmal definiert, um sie dann an verschiedenen Programmstellen durch ihren Aufruf mehrfach zu benutzen.",task:"1. Definiere eine Funktion <code>begruesse</code>, die den Wert <code>\"Moin!\"</code> zur\xFCckgibt.\n<br/>\n2. Deklariere eine Variable <code>begruessung</code>. Rufe die Funktion <code>begruesse</code> auf und weise der Variablen\n<code>begruessung</code> die R\xFCckgabe dieses Aufrufs zu.",hint:"<pre><code>var begruesse = function() {\n  ...\n};\n\nvar begruessung = ...</code></pre>",solution:"<pre><code>var begruesse = function() {\n  return \"Moin!\";\n};\n\nvar begruessung = begruesse();</code></pre>",beforeTests:function(){begruesse=undefined;begruessung=undefined},tests:[function(){return testutil.assert_isFunction("begruesse")},function(){return testutil.assert_functionReturns("begruesse()","Moin!")},function(){return testutil.assert_variableDefined("begruessung")},function(){return testutil.assert_variableHasValue("begruessung","Moin!")}]})})(jshero.testutil);
jshero.koans.add({id:"further",title:"Fortsetzung folgt ...",lesson:"JS Hero wird fortgesetzt. Weitere \xDCbungen folgen. Zum Abschluss noch eine Aufgabe aus dem Gebiet der Mathematik.",task:"Schreibe eine Funktion <code>quersumme</code>, die die Quersumme einer nat\xFCrlichen Zahl berechnet.\nDie Quersumme einer Zahl ist dabei die Summe ihrer Ziffern. <code>quersumme(198)</code> sollte <code>18</code> ergeben.",beforeTests:function(){if(typeof quersumme!=="undefined"){quersumme=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("quersumme")},function(){return jshero.testutil.assert_functionHasNumOfParameter("quersumme",1)},function(){return jshero.testutil.assert_functionReturns("quersumme(1)",1)},function(){return jshero.testutil.assert_functionReturns("quersumme(198)",18)},function(){return jshero.testutil.assert_functionReturns("quersumme(123456789)",45)}],hint:"<pre><code>var quersumme = function(zahl) {\n// Extrahiere in einer Schleife\n// mit Modulo jeweils die\n// Einer-Stelle und addiere \n// sie auf.\n};</code></pre>",solution:"<pre><code>var quersumme = function(zahl) {\n  var sum = 0;\n  var rest = zahl;\n  while (rest > 0) {\n    var einer = rest % 10;\n    sum = sum + einer;\n    rest = (rest - einer)/10;\n  }\n  return sum;\n};</code></pre>"});
jshero.koans.add({id:'gettime',title:'Date: getTime()',lesson:'Die Date-Methode <code>getTime</code> liefert die Millisekunden, die zwischen dem 1.1.1970, 0:00 UTC\nund dem Zeitpunkt des Datumsobjekts liegen.\n\n<pre><code>var date = new Date(Date.UTC(1970, 0, 1, 0, 1));\nvar time = date.getTime();</code></pre>\n\nZwischen dem 1.1.1970, 0:00:00 UTC und dem 1.1.1970, 0:00:01 UTC liegen 1000 Millisekunden.\n<code>time</code> erh\xE4lt den Wert <code>1000</code>.',task:'Schreibe eine Funktion <code>days</code>, die die Differenz in Tagen zwischen zwei Date-Objekten berechnet.\nEs sollen nur volle Tage gez\xE4hlt werden.\n<code>days(new Date(2018, 0, 1), new Date(2018, 0, 2))</code> und\n<code>days(new Date(2018, 0, 1), new Date(2018, 0, 2, 12))</code> sollten <code>1</code> zur\xFCckgeben.',beforeTests:function(){if(typeof days!=='undefined'){days=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('days')},function(){return jshero.testutil.assert_functionHasNumOfParameter('days',2)},function(){return jshero.testutil.assert_functionReturns('days(new Date(2018, 0, 0), new Date(2018, 0, 0))',0)},function(){return jshero.testutil.assert_functionReturns('days(new Date(2018, 0, 1), new Date(2018, 0, 2))',1)},function(){return jshero.testutil.assert_functionReturns('days(new Date(2018, 0, 1), new Date(2018, 0, 3))',2)},function(){return jshero.testutil.assert_functionReturns('days(new Date(2018, 0, 1), new Date(2018, 0, 4))',3)},function(){return jshero.testutil.assert_functionReturns('days(new Date(2018, 0, 1), new Date(2018, 0, 4, 23, 59))',3)},function(){return jshero.testutil.assert_functionReturns('days(new Date(2018, 0, 1), new Date(2019, 0, 1))',365)}]});
jshero.koans.add({id:'ggt',title:'ggT',lesson:'Das Gegenst\xFCck zum kleinsten gemeinsamen Vielfachen (kgV) ist der\n<a href="https://de.wikipedia.org/wiki/Gr%C3%B6%C3%9Fter_gemeinsamer_Teiler">gr\xF6\xDFte gemeinsamer Teiler (ggT)</a>.\nDer gr\xF6\xDFte gemeinsame Teiler zweier Zahlen a und b ist die gr\xF6\xDFte Zahl, durch die sich sowohl a als auch b teilen l\xE4\xDFt.',task:'Schreibe eine Funktion <code>ggT</code>, die zwei nat\xFCrliche Zahlen als Parameter entgegennimmt und deren ggT berechnet.\n<code>ggT(6, 15)</code> sollte <code>3</code> zur\xFCckgeben.',beforeTests:function(){if(typeof ggT!=='undefined'){ggT=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('ggT')},function(){return jshero.testutil.assert_functionHasNumOfParameter('ggT',2)},function(){return jshero.testutil.assert_functionReturns('ggT(1, 1)',1)},function(){return jshero.testutil.assert_functionReturns('ggT(1, 2)',1)},function(){return jshero.testutil.assert_functionReturns('ggT(2, 3)',1)},function(){return jshero.testutil.assert_functionReturns('ggT(2, 4)',2)},function(){return jshero.testutil.assert_functionReturns('ggT(6, 15)',3)},function(){return jshero.testutil.assert_functionReturns('ggT(12, 18)',6)},function(){return jshero.testutil.assert_functionReturns('ggT(18, 12)',6)},function(){return jshero.testutil.assert_functionReturns('ggT(15, 45)',15)},function(){return jshero.testutil.assert_functionReturns('ggT(45, 15)',15)}]});
jshero.koans.add({id:'greaterthan',title:'Zahlen vergleichen',lesson:'Zahlen kann man mit den aus der Mathematik bekannten Zeichen\n<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code> und <code>&lt;=</code>\nauf gr\xF6\xDFer, gr\xF6\xDFer gleich, kleiner und kleiner gleich vergleichen.\nIm folgenden Beispiel liefern alle Ausdr\xFCcke den Wert <code>true</code>:\n<pre><code>var v1 = 5 > 4;\nvar v2 = 5 >= 5;\nvar v3 = 5 < 6;\nvar v4 = 5 <= 5;</code></pre>',task:'Schreibe eine Funktion <code>istDreistellig</code>, die pr\xFCft, ob eine Zahl gr\xF6\xDFer gleich 100 und kleiner 1000 ist.\n<code>istDreistellig(500)</code> sollte <code>true</code> zur\xFCckgeben, <code>istDreistellig(50)</code> sollte <code>false</code> ergeben.',beforeTests:function(){istDreistellig=undefined},tests:[function(){return jshero.testutil.assert_isFunction('istDreistellig')},function(){return jshero.testutil.assert_functionHasNumOfParameter('istDreistellig',1)},function(){return jshero.testutil.assert_functionReturns('istDreistellig(100)',true)},function(){return jshero.testutil.assert_functionReturns('istDreistellig(999)',true)},function(){return jshero.testutil.assert_functionReturns('istDreistellig(99)',false)},function(){return jshero.testutil.assert_functionReturns('istDreistellig(1000)',false)}]});
jshero.koans.add({id:'if',title:'if',lesson:'H\xE4ufig soll Code nur dann ausgef\xFChrt werden, wenn eine bestimmte Bedingung erf\xFCllt ist.\nDazu verwendet man die <code>if</code>-Anweisung.\n\n<pre><code>var gewinn = 0;\nif (wuerfelzahl === 6) {\n  gewinn = 100;\n}</code></pre>\n\nDiese Anweisung besteht aus dem Schl\xFCsselwort <code>if</code> (engl: wenn) gefolgt von runden Klammern. In den runden\nKlammern steht ein Ausdruck - die Bedingung -, der zu <code>true</code> oder <code>false</code> ausgewertet wird.\nErgibt die Bedingung <code>true</code>, werden alle Anweisungen in dem durch die geschweiften Klammern begrenzten Block\nausgef\xFChrt. Ergibt die Bedingung <code>false</code>, wird der durch die geschweiften Klammern begrenzte Block \xFCbersprungen.\nHat in unserem Beispiel die Variable <code>wuerfelzahl</code> den Wert <code>6</code>, so wird <code>gewinn</code> auf\n<code>100</code> gesetzt. Hat <code>wuerfelzahl</code> nicht den Wert <code>6</code>, bleibt <code>gewinn</code> bei\n<code>0</code>.',task:'Schreibe eine Funktion <code>gleich</code>, die 2 Werte auf strikte Gleichheit \xFCberpr\xFCft. Sind die beiden Werte\ngleich, so soll der String <code>"GLEICH"</code> zur\xFCckgegeben werden. Sind sie ungleich, so soll man\n<code>"UNGLEICH"</code> erhalten.',hint:'<pre><code>var gleich = function(a, b) {\n// Initialisiere eine Variable\n// mit "UNGLEICH". Verwende "if",\n// um die Variable ggf. auf\n// "GLEICH" zu setzen. Gebe die\n// Variable zur\xFCck.\n};</code></pre>',solution:'<pre><code>var gleich = function(a, b) {\n  var ergebnis = "UNGLEICH";\n  if (a === b) {\n    ergebnis = "GLEICH";\n  }\n  return ergebnis;\n};</code></pre>',beforeTests:function(){if(typeof gleich!=='undefined'){gleich=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('gleich')},function(){return jshero.testutil.assert_functionHasNumOfParameter('gleich',2)},function(){return jshero.testutil.assert_functionReturns('gleich(1, 1)','GLEICH')},function(){return jshero.testutil.assert_functionReturns('gleich(1, 2)','UNGLEICH')},function(){return jshero.testutil.assert_functionReturns('gleich(1, "1")','UNGLEICH')},function(){return jshero.testutil.assert_functionReturns('gleich("klein", "klein")','GLEICH')},function(){return jshero.testutil.assert_functionReturns('gleich("Links", "Rechts")','UNGLEICH')}]});
jshero.koans.add({id:'if2',title:'Zwei return-Anweisungen',lesson:'Mit der <code>if</code>-Anweisung hat man die M\xF6glichkeit, Funktionen mit zwei <code>return</code>-Anweisungen\nzu schreiben:\n\n<pre><code>var gewinn = function(zahl) {\n  if (zahl === 6) {\n    return 100;\n  }\n  return 0;\n};</code></pre>\n\nHat <code>zahl</code> den Wert <code>6</code>, so ist die <code>if</code>-Bedingung erf\xFCllt und die erste\n<code>return</code>-Anweisung wird ausgef\xFChrt. Die Funktion wird beendet und gibt <code>100</code> zur\xFCck.\nHat <code>zahl</code> nicht den Wert <code>6</code>, so ist die <code>if</code>-Bedingung nicht erf\xFCllt.\nDie Codeausf\xFCfrung wird hinter dem zur <code>if</code>-Anweisung geh\xF6rigen Block fortgesetzt. Die zweite\n<code>return</code>-Anweisung wird ausgef\xFChrt. Die Funktion gibt <code>0</code> zur\xFCck.<br><br>\nAber Achtung: Zwei oder auch mehr <code>return</code>-Anweisungen in einer Funktion sollte man sorgsam verwenden.\nAndernfalls wird der Code un\xFCbersichtlich.',task:'Schreibe eine Funktion <code>schnapszahl</code>, die feststellt, ob eine zweistellige Zahl eine Schnapszahl ist\noder nicht. Ist die Zahl eine Schnapszahl, soll <code>"Schnaps!"</code> zur\xFCckgegeben werden, andernfalls\n<code>"Kein Schnaps!"</code>. <code>schnapszahl(22)</code> sollte <code>"Schnaps!"</code> und\n<code>schnapszahl(23)</code> sollte <code>"Kein Schnaps!"</code> zur\xFCckgeben.\n<br><br>\nEine <a href="https://de.wikipedia.org/wiki/Schnapszahl">Schnapszahl</a> ist eine mehrstellige Zahl, die ausschlie\xDFlich\ndurch identische Ziffern dargestellt wird.',hint:'<pre><code>var schnapszahl = function(n) {\n// Berechne die Einerstelle\n// von n mit Modulo 10.\n// Berechne die Zehnerstelle\n// von n mit Division\n// durch 10 und Abrunden.\n// Vergleiche Einer- und\n// Zehnerstelle.\n};</code></pre>',solution:'<pre><code>var schnapszahl = function(n) {\n  var einer = n % 10;\n  var zehner = Math.floor(n / 10);\n  if (einer === zehner) {\n    return "Schnaps!";\n  }\n  return "Kein Schnaps!";\n};</code></pre>',beforeTests:function(){if(typeof schnapszahl!=='undefined'){schnapszahl=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('schnapszahl')},function(){return jshero.testutil.assert_functionHasNumOfParameter('schnapszahl',1)},function(){return jshero.testutil.assert_functionReturns('schnapszahl(11)','Schnaps!')},function(){return jshero.testutil.assert_functionReturns('schnapszahl(55)','Schnaps!')},function(){return jshero.testutil.assert_functionReturns('schnapszahl(99)','Schnaps!')},function(){return jshero.testutil.assert_functionReturns('schnapszahl(10)','Kein Schnaps!')},function(){return jshero.testutil.assert_functionReturns('schnapszahl(12)','Kein Schnaps!')},function(){return jshero.testutil.assert_functionReturns('schnapszahl(98)','Kein Schnaps!')}]});
jshero.koans.add({id:'join',title:'Array: join()',lesson:'Mit <code>join</code> verbindet man alle Elemente eines Arrays zu einem String:\n\n<pre><code>var words = ["Sex", "Drugs", "Rock", "Roll"];\nvar l1 = words.join();\nvar l2 = words.join(" & ");\nvar l3 = words.join(" and ");</code></pre>\n\nOhne Argument f\xFCgt <code>join</code> die Elemente kommasepariert zusammen.\n<code>l1</code> ergibt <code>"Sex,Drugs,Rock,Roll"</code>.\nAnsonsten gibt das \xFCbergebene Argument das Trennzeichen vor.\n<code>l2</code> ergibt <code>"Sex & Drugs & Rock & Roll"</code> und\n<code>l3</code> den String <code>"Sex and Drugs and Rock and Roll"</code>.',task:'Schreibe eine Funktion <code>list</code>, die W\xF6rter in einem Array zu einer Aufz\xE4hlung zusammenf\xFChrt.\n<code>list(["Sonne", "Mond", "Sterne"])</code> soll <code>"Sonne, Mond und Sterne"</code> ergeben.\nDas \xFCbergebene Array enth\xE4lt mindestens zwei W\xF6rter.',beforeTests:function(){if(typeof list!=='undefined'){list=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('list')},function(){return jshero.testutil.assert_functionHasNumOfParameter('list',1)},function(){return jshero.testutil.assert_functionReturns('list(["Ernie", "Bert"])','Ernie und Bert')},function(){return jshero.testutil.assert_functionReturns('list(["Sonne", "Mond", "Sterne"])','Sonne, Mond und Sterne')},function(){return jshero.testutil.assert_functionReturns('list(["C", "C++", "Python", "PHP"])','C, C++, Python und PHP')}]});
(function(testutil){jshero.koans.add({id:"log",title:"Loggen und Strings",lesson:"Jetzt wollen wir das Loggen zusammen mit dem Verketten von Strings \xFCben.",task:"Schreibe eine Funktion <code>rufe</code>, die einen String als Parameter entgegennimmt und diesen String verdoppelt zur\xFCckgibt.\n  Gleichzeitig soll die R\xFCckgabe geloggt werden. Der Aufruf <code>rufe(\"Werder\")</code>\n  sollte <code>\"WerderWerder\"</code> zur\xFCckgeben und er sollte <code>\"WerderWerder\"</code> loggen.",hint:"<pre><code>var rufe = function(name) {\n  var ruf = name + name;\n  ...\n};",solution:"<pre><code>var rufe = function(name) {\n  var ruf = name + name;\n  console.log(ruf);\n  return ruf;\n};",beforeTests:function(){if(typeof rufe!=="undefined"){rufe=undefined}},tests:[function(){return testutil.assert_isFunction("rufe")},function(){return testutil.assert_functionHasNumOfParameter("rufe",1)},function(){return testutil.assert_functionReturns("rufe(\"Werder\")","WerderWerder")},function(){return testutil.assert_functionReturns("rufe(\"Kickers\")","KickersKickers")},function(){return testutil.assert_functionLogs("rufe(\"Werder\")","WerderWerder")},function(){return testutil.assert_functionLogs("rufe(\"Kickers\")","KickersKickers")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"log1",title:"Logging",lesson:"Programmieren beinhaltet immer auch die Suche nach Fehlern.\nEine M\xF6glichkeit Fehler zu finden ist das <a href=\"https://de.wikipedia.org/wiki/Logging\">Loggen</a>.\nMan macht w\xE4hrend der Programmausf\xFChrung gezielte Ausgaben.\nIn JavaScript verwendet man daf\xFCr die Funktion <code>console.log</code>:\n\n<pre><code>console.log(\"Hallo Konsole!\");</code></pre>\n\nHier wird der String <code>\"Hallo Konsole!\"</code> mit <code>console.log</code> ausgegeben.\nWo man die Ausgabe zu sehen bekommt, h\xE4ngt von der JavaScript-Umgebung ab.\nIn Browsern sieht man die Log-Ausgabe im normalen Betrieb nicht.\nDoch die meisten Desktop-Browser besitzen sogenannte <a href=\"https://de.wikipedia.org/wiki/Entwicklerwerkzeuge_in_Webbrowsern\"> Entwicklerwerkzeuge</a>.\nDas sind m\xE4chtige Tools zur Unterst\xFCtzung von Webentwicklern. Eines dieser Tools ist die Konsole.\nDort wird das Log ausgegeben. Wie man die Entwickler-Werkzeuge \xF6ffnet h\xE4ngt vom jeweiligen Browser ab.\nBei vielen Desktop-Browsern wird sie mit der Taste F12 ge\xF6ffnet.\nDie Konsole kannst du dann als Reiter ausw\xE4hlen. Alternativ kann man die Konsole \xFCber das Browser-Men\xFC \xF6ffnen.\nAuf mobilen Ger\xE4ten stehen die Entwickler-Werkzeuge nicht zur Verf\xFCgung.\nDeshalb schreibt JS Hero das Log zus\xE4tzlich in die Testausgabe.",task:"Schreibe eine Funktion <code>logge</code>, die den String <code>\"Hallo Konsole!\"</code> loggt.\nArbeitest du mit einem Desktop-Browser \xF6ffne zus\xE4tzlich die Entwickler-Tools, um auch dort die Ausgabe zu sehen.",hint:"<pre><code>var logge = function() {\n  console.log(...);\n};",solution:"<pre><code>var logge = function() {\n  console.log(\"Hallo Konsole!\");\n};",beforeTests:function(){if(typeof logge!=="undefined"){logge=undefined}},tests:[function(){return testutil.assert_isFunction("logge")},function(){return testutil.assert_functionLogs("logge()","Hallo Konsole!")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"log2",title:"Variablen loggen",lesson:"Nun wollen wir Variablen loggen:\n\n<pre><code>var informatiker = \"Ken Thompson\";\nconsole.log(informatiker);</code></pre>\n\nHier wird die Variable <code>informatiker</code> mit <code>console.log</code> geloggt.\nIn der Konsole erscheint <code>\"Ken Thompson\"</code>. Das ist der Wert der Variablen <code>informatiker</code>.",task:"Schreibe eine Funktion <code>logge</code>, die einen Parameter entgegennimmt und diesen Parameter loggt.\nDer Aufruf von <code>logge(\"Ken Thompson\")</code> sollte <code>\"Ken Thompson\"</code> loggen.",hint:"<pre><code>var logge = function(wert) {\n  ...\n};",solution:"<pre><code>var logge = function(wert) {\n  console.log(wert);\n};",beforeTests:function(){if(typeof logge!=="undefined"){logge=undefined}},tests:[function(){return testutil.assert_isFunction("logge")},function(){return testutil.assert_functionHasNumOfParameter("logge",1)},function(){return testutil.assert_functionLogs("logge(\"Ken Thompson\")","Ken Thompson")},function(){return testutil.assert_functionLogs("logge(\"Dennis Ritchie\")","Dennis Ritchie")}]})})(jshero.testutil);
jshero.koans.add({id:"math",title:"Math",lesson:"Viele mathematische Funktionen sind in dem Objekt <code>Math</code> zusammengefasst.\nSo gibt <code>Math.sqrt(x)</code> die Quadratwurzel (engl.: square root) zur\xFCck\nund mit <code>Math.pow(x, y)</code> berechnet man die Potenz (engl.: power) x hoch y.\n\n<pre><code>var y1 = Math.sqrt(9);\nvar y2 = Math.pow(10, 3);</code></pre>\n\n<code>y1</code> hat den Wert <code>3</code> und <code>y2</code> den Wert <code>1000</code> (10&sup3; = 10 * 10 * 10 = 1000).",task:"Schreibe eine Funktion <code>hypotenuse</code>, die die L\xE4nge der Hypotenuse eines rechtwinkligen Dreiecks berechnet.\n\xDCbergeben wird der Funktion als Parameter die L\xE4ngen der beiden Katheten. Tipp: In einem rechtwinkligen Dreieck gilt der Satz\ndes Pythagoras. Sind a, b die L\xE4ngen der beiden Katheten und c die L\xE4nge der Hypotenuse, so gilt: a&sup2; + b&sup2; = c&sup2;.\nDa 3&sup2; + 4&sup2; = 5&sup2; gilt, sollte <code>hypotenuse(3, 4)</code> den Wert <code>5</code> liefern.",hint:"<pre><code>var hypotenuse = function(a, b) {\n  var cQuadrat = a * a + b * b;\n  return ...\n};</code></pre>",solution:"<pre><code>var hypotenuse = function(a, b) {\n  var cQuadrat = a * a + b * b;\n  return Math.sqrt(cQuadrat);\n};</code></pre>",beforeTests:function(){if(typeof hypotenuse!=="undefined"){hypotenuse=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("hypotenuse")},function(){return jshero.testutil.assert_functionHasNumOfParameter("hypotenuse",2)},function(){return jshero.testutil.assert_functionReturns("hypotenuse(3, 4)",5)},function(){return jshero.testutil.assert_functionReturns("hypotenuse(5, 12)",13)},function(){return jshero.testutil.assert_functionReturns("hypotenuse(1, 1)",Math.sqrt(2))}]});
jshero.koans.add({id:"mean",title:"Klammern",lesson:"Ebenso wie in der Mathematik gilt in JavaScript die Punkt-vor-Strichrechnung. Multiplikation und Division\nwerden vor Addition und Subtraktion ausgef\xFChrt. M\xF6chte man zuerst die Strichrechnung ausf\xFChren, verwendet man genauso\nwie in der Mathematik Klammern.\n\n<pre><code>var x1 = 3 + 4 * 2;\nvar x2 = (3 + 4) * 2;</code></pre>\n\n<code>x1</code> hat den Wert <code>11</code>, der Wert von <code>x2</code> ist <code>14</code>.",task:"Schreibe eine Funktion <code>mittelwert</code>, die zwei Zahlen als Parameter entgegennimmt und deren\nMittelwert zur\xFCckgibt. <code>mittelwert(1, 2)</code> sollte <code>1.5</code> ergeben.",hint:"<pre><code>Der Mittelwert zweier Zahlen\nx und y ist (x + y) / 2.</code></pre>",solution:"<pre><code>var mittelwert = function(x, y) {\n  return (x + y) / 2;\n};</code></pre>",beforeTests:function(){if(typeof mittelwert!=="undefined"){mittelwert=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("mittelwert")},function(){return jshero.testutil.assert_functionHasNumOfParameter("mittelwert",2)},function(){return jshero.testutil.assert_functionReturns("mittelwert(1, 2)",1.5)},function(){return jshero.testutil.assert_functionReturns("mittelwert(0, 0)",0)},function(){return jshero.testutil.assert_functionReturns("mittelwert(3, -1)",1)}]});
jshero.koans.add({id:"minmax",title:"Min und Max",lesson:"Das Minimum und Maximum einer Reihe von Zahlen bestimmt man mit\n<code>Math.min()</code> und <code>Math.max()</code>:\n\n<pre><code>var min = Math.min(5, 7);\nvar max = Math.max(3, 9, 2);</code></pre>\n\n<code>min</code> erh\xE4lt den Wert <code>5</code> und <code>max</code> den Wert <code>9</code>.\nDas Besondere: Beide Funktionen k\xF6nnen mit einer beliebigen Anzahl von Argumenten aufgerufen werden.",task:"Schreibe eine Funktion <code>bereichsmittel</code>, die das Bereichsmittel von 3 Zahlen berechnet.\nDas <a href=\"https://de.wikipedia.org/wiki/Mittelwert#Bereichsmittel\">Bereichsmittel</a>\neiner Reihe von Zahlen ist der Mittelwert der kleinsten und gr\xF6\xDFten Zahl.\n<code>bereichsmittel(3, 9, 1)</code> sollte <code>(9+1)/2</code> = <code>5</code> ergeben.",beforeTests:function(){if(typeof bereichsmittel!=="undefined"){bereichsmittel=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("bereichsmittel")},function(){return jshero.testutil.assert_functionHasNumOfParameter("bereichsmittel",3)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(3, 9, 1)",5)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(3, 0, 8)",4)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(7, 4, 0)",3.5)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(-6, -5, -2)",-4)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(5, -5, 2)",0)},function(){return jshero.testutil.assert_functionReturns("bereichsmittel(10, 20, 17)",15)}]});
jshero.koans.add({id:"modulo",title:"Modulo",lesson:"Ein weiterer arithmetischer Operator ist Modulo. Er berechnet den Rest einer Division und wird mit dem Prozentzeichen <code>%</code> notiert."+"<pre><code>var x = 7 % 2;<br>"+"var y = 20 % 3;</code></pre>"+"7 geteilt durch 2 ergibt 3 Rest 1. <code>x</code> ist also <code>1</code>.<br>"+"20 geteilt durch 3 ergibt 6 Rest 2. <code>y</code> ist also <code>2</code>.",task:"Schreibe eine Funktion <code>einer</code>, die eine nat\xFCrliche Zahl entgegenimmt und die Ziffer der Einer-Stelle zur\xFCckgibt. "+"<code>einer(2674)</code> sollte <code>4</code> zur\xFCckgeben.",hint:"<pre><code>var einer = function(n) {\n// Benutze Modulo 10.  \n};</code></pre>",solution:"<pre><code>var einer = function(n) {\n  return n % 10;\n};</code></pre>",beforeTests:function(){if(typeof einer!=="undefined"){einer=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("einer")},function(){return jshero.testutil.assert_functionHasNumOfParameter("einer",1)},function(){return jshero.testutil.assert_functionReturns("einer(3)",3)},function(){return jshero.testutil.assert_functionReturns("einer(17)",7)},function(){return jshero.testutil.assert_functionReturns("einer(210)",0)},function(){return jshero.testutil.assert_functionReturns("einer(2674)",4)}]});
(function(testutil){jshero.koans.add({id:"nan",title:"NaN",lesson:"<code>NaN</code> repr\xE4sentiert den Wert Not-A-Number (engl.: Keine-Zahl). Numerische Operationen oder Funktionen geben <code>NaN</code> zur\xFCck, "+"wenn sie keinen Wert berechnen k\xF6nnen. Wir hatten dies bei <code><a href=\"main.html?koan=parseint\">parseInt</a></code> kennengelernt. "+"<code>parseInt</code> gibt <code>NaN</code> zur\xFCck, wenn es keine Zahl parsen kann. Ein weiteres Beispiel ist die Berechnung der Wurzel aus einer negativen Zahl. "+"<pre><code>"+"var age = parseInt(\"Babylon\");<br>"+"var length = Math.sqrt(-1);"+"</code></pre>"+"Sowohl <code>age</code> als auch <code>length</code> haben den Wert <code>NaN</code>. "+"M\xF6chte man testen, ob <code>NaN</code> vorliegt, kann man leider nicht <code>===</code> verwenden. <code>age === NaN</code> ergibt auch dann <code>false</code>, "+"wenn <code>age</code> den Wert <code>NaN</code> besitzt. <code>NaN</code> ist der einzige Wert in JavaScript, der nicht mit sich selbst "+"gleich ist. Stattdessen verwendet man die Funktion <code>isNaN</code>."+"<pre><code>"+"var message;<br>"+"var age = parseInt(\"Babylon\");<br>"+"if ( isNaN(alter) ) {<br>"+"  message = \"Du hast keine Zahl eingegeben.\";<br>"+"}"+"</code></pre>",task:"Schreibe eine Funktion <code>parseFirstInt</code>, die einen String entgegennimmt und die die erste in dem String vorkommende ganze Zahl zur\xFCckgibt. "+"<code>parseFirstInt(\"Sonnebornstr. 27\")</code> sollte <code>27</code> zur\xFCckgeben. <code>parseFirstInt(\"Babylon\")</code> sollte <code>NaN</code> ergeben.",beforeTests:function(){if(typeof parseFirstInt!=="undefined"){parseFirstInt=undefined}},tests:[function(){return testutil.assert_isFunction("parseFirstInt")},function(){return testutil.assert_functionHasNumOfParameter("parseFirstInt",1)},function(){return testutil.assert_functionReturns("parseFirstInt(\"Sonnebornstr. 2\")",2)},function(){return testutil.assert_functionReturns("parseFirstInt(\"28.12.05\")",28)},function(){return testutil.assert_functionReturns("parseFirstInt(\"Willi ist 22 Jahre alt.\")",22)},function(){return testutil.assert_functionReturns("parseFirstInt(\"Ohne Zahl\")",NaN)}]})})(jshero.testutil);
jshero.koans.add({id:"nor",title:"NOR",lesson:"In der letzten Aufgabe hast du ein sogenanntes NAND-Gatter (engl.: Not AND - nicht und) programmiert.\nNAND-Gatter sind in der Digitaltechnik ein sogenannter Standardbaustein.\nMit ihm lassen sich alle logischen Verkn\xFCpfungen zusammenstellen.\nHier sollst du einen weiteren Standardbaustein, das NOR-Gatter (engl.: Not OR - nicht oder), kennen lernen.",task:"Schreibe eine Funktion <code>nor</code>, die zwei boolesche Werte als Parameter entgegennimmt.\nDie R\xFCckgabe der Funktion soll genau dann <code>true</code> sein, wenn beide Paramter <code>false</code> sind.\nIn den anderen F\xE4llen soll die R\xFCckgabe <code>false</code> sein. <code>nor(false, false)</code> soll <code>true</code> liefern,\n<code>nor(false, true)</code>, <code>nor(true, false)</code> und <code>nor(true, true)</code> sollen <code>false</code> zur\xFCckgeben.",beforeTests:function(){if(typeof nor!=="undefined"){nor=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("nor")},function(){return jshero.testutil.assert_functionHasNumOfParameter("nor",2)},function(){return jshero.testutil.assert_functionReturns("nor(false, false)",true)},function(){return jshero.testutil.assert_functionReturns("nor(false, true)",false)},function(){return jshero.testutil.assert_functionReturns("nor(true, false)",false)},function(){return jshero.testutil.assert_functionReturns("nor(true, true)",false)}]});
jshero.koans.add({id:'notequals',title:'Strikte Ungleichtheit',lesson:'Mit <code>!==</code> vergleicht man zwei Werte auf strikte Ungleichheit.\n\n<pre><code>var v1 = "lauf" !== "Lauf";\nvar v2 = 10 !== "10";</code></pre>\n\nBeide Vergleiche ergeben <code>true</code>. Der erste, weil sich die beiden\nStrings in der Gro\xDF- und Kleinschreibung unterscheiden.\nDer zweite, weil sich die beiden Werte von Typ her unterscheiden.',task:'Schreibe eine Funktion <code>ungleich</code>, die 3 Werte auf strikte Ungleichheit \xFCberpr\xFCft.\nDie Funktion soll nur dann <code>true</code> ergeben, wenn alle drei Parameter unterschiedlich sind.\n<code>ungleich(1, 2, 3)</code> soll <code>true</code> liefern, <code>ungleich(1, 1, 2)</code> soll\n<code>false</code> ergeben.',beforeTests:function(){if(typeof ungleich!=='undefined'){ungleich=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('ungleich')},function(){return jshero.testutil.assert_functionHasNumOfParameter('ungleich',3)},function(){return jshero.testutil.assert_functionReturns('ungleich(1, 2, 3)',true)},function(){return jshero.testutil.assert_functionReturns('ungleich(1, 2, 1)',false)},function(){return jshero.testutil.assert_functionReturns('ungleich(2, 1, 1)',false)},function(){return jshero.testutil.assert_functionReturns('ungleich("2", 2, 2)',false)},function(){return jshero.testutil.assert_functionReturns('ungleich("kLein", "klein", "kleiN")',true)},function(){return jshero.testutil.assert_functionReturns('ungleich("1", 1, true)',true)},function(){return jshero.testutil.assert_functionReturns('ungleich("klein", "klein", "kIein")',false)}]});
jshero.koans.add({id:"number",title:"Zahlen",lesson:"Zahlen werden in JavaScript durch einfache Ziffern dargestellt. Sie k\xF6nnen einen\nDezimalpunkt und ein Minuszeichen besitzen.\n\n<pre><code>var x1 = 1;\nvar x2 = 1.0;\nvar x3 = 3.14;\nvar x4 = -1;</code></pre>\n\n<code>1</code> und <code>1.0</code> sind dieselbe Zahl. Mit Zahlen kann man rechnen. Die\nvier Grundrechenarten Addieren, Subtrahieren, Multiplizieren und Dividieren werden durch\n<code>+ - *</code> und <code>/</code> dargestellt.\n\n<pre><code>var x1 = 6;\nvar x2 = 2;\nvar x3 = x1 + x2;\nvar x4 = x1 - x2;\nvar x5 = x1 * x2;\nvar x6 = x1 / x2;</code></pre>\n\nDie Variablen <code>x3</code> bis <code>x6</code> haben so die Werte <code>8</code>,\n<code>4</code>, <code>12</code> und <code>3</code>.",task:"Schreibe eine Funktion <code>add</code>, die zwei Zahlen als Parameter entgegennimmt\nund deren Summe zur\xFCckgibt. <code>add(1, 2)</code> sollte <code>3</code> ergeben.",hint:"<pre><code>var add = function(x, y) {\n  return ...\n};</code></pre>",solution:"<pre><code>var add = function(x, y) {\n  return x + y;\n};</code></pre>",beforeTests:function(){if(typeof add!=="undefined"){add=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("add")},function(){return jshero.testutil.assert_functionHasNumOfParameter("add",2)},function(){return jshero.testutil.assert_functionReturns("add(0, 0)",0)},function(){return jshero.testutil.assert_functionReturns("add(2, 3)",5)},function(){return jshero.testutil.assert_functionReturns("add(-1, 3)",2)}]});
jshero.koans.add({id:"numbertostring",title:"Number: toString()",lesson:"Die Number-Methode <code>toString</code> wandelt eine Zahl in den entsprechenden String um. Der Dezimalpunkt wird dabei als Punkt dargestellt. "+"Das kann man z.B. dazu verwenden, eine Zahl im deutschen Format, also mit Komma als Dezimalpunkt, auszugeben:"+"<code><pre>"+"var number = 7.25;<br>"+"var numberInEnglish = number.toString();<br>"+"var numberInGerman = numberInEnglish.replace(\".\", \",\");"+"</code></pre>"+"<code>numberInEnglish</code> enth\xE4lt den String <code>\"7.25\"</code>. Da wir jetzt unsere Zahl als String vorliegen haben, k\xF6nnen wir auf ihr die String-Methode "+"<code>replace</code> anwenden. <code>numberInGerman</code> enth\xE4lt so den String <code>\"7,25\"</code>.",task:"Schreibe eine Funktion <code>digitLength</code>, die eine nat\xFCrliche Zahl entgegennimmt und die Anzahl der Ziffern zur\xFCckgibt. "+"<code>digitLength(709)</code> sollte 3 zur\xFCckgeben.",beforeTests:function(){if(typeof digitLength!=="undefined"){digitLength=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("digitLength")},function(){return jshero.testutil.assert_functionHasNumOfParameter("digitLength",1)},function(){return jshero.testutil.assert_functionReturns("digitLength(1)",1)},function(){return jshero.testutil.assert_functionReturns("digitLength(709)",3)},function(){return jshero.testutil.assert_functionReturns("digitLength(123456)",6)}]});
(function(testutil){jshero.koans.add({id:"parameter",title:"Parameter",lesson:"Jetzt lernen wir Funktionen mit Parametern kennen. Mit\n\n  <pre><code>var gebe = function(eingabe) {\n  return eingabe;\n};</code></pre>\n\ndefinieren wir eine Funktion, die den \xFCbergebenen Parameter <code>eingabe</code> einfach wieder zur\xFCckgibt.\nParameter sind Variablen. Sie stehen in der runden Klammer und ben\xF6tigen nicht das Schl\xFCsselwort <code>var</code> zu\nihrer Deklaration. Mit\n\n<pre><code>var ergebnis = gebe(\"Apfel\");</code></pre>\n\nwird die Funktion mit dem Argument <code>\"Apfel\"</code> aufgerufen. Jetzt wird unsere zuvor definierte Funktion\nausgef\xFChrt. Dabei wird zun\xE4chst das Argument <code>\"Apfel\"</code> dem Parameter <code>eingabe</code> zugewiesen.\n<code>eingabe</code> hat jetzt den Wert <code>\"Apfel\"</code>. In der einzigen Codezeile der Funktion wird nun die\nVariable <code>eingabe</code> mit der <code>return</code>-Anweisung zur\xFCckgegeben. Diese R\xFCckgabe wird der Variablen\n<code>ergebnis</code> zugewiesen. <code>ergebnis</code> hat dann auch den Wert <code>\"Apfel\"</code>.",task:"Schreibe eine Funktion <code>echo</code>, die ebenfalls den \xFCbergebenen Parameter wieder zur\xFCckgibt.",hint:"<pre><code>var echo = function(ton) {\n  ...\n};",solution:"<pre><code>var echo = function(ton) {\n  return ton;\n};",beforeTests:function(){if(typeof echo!=="undefined"){echo=undefined}},tests:[function(){return testutil.assert_isFunction("echo")},function(){return testutil.assert_functionHasNumOfParameter("echo",1)},function(){return testutil.assert_functionReturns("echo(\"Hallo Welt!\")","Hallo Welt!")},function(){return testutil.assert_functionReturns("echo(\"Franz\")","Franz")}]})})(jshero.testutil);
jshero.koans.add({id:"parameter2a",title:"Parameternamen",lesson:"Bitte achte darauf, dass du eventuelle Parameter deiner Funktion anders nennst als die Funktion selbst.\nDie Funktion <code>f1</code> zum Beispiel\n\n<pre><code>var f1 = function(f1) {\n  return f1;\n};</code></pre>\n\nmacht das gleiche wie diese Funktion:\n\n<pre><code>var f2 = function(eingabe) {\n  return eingabe;\n};</code></pre>\n\nDie zweite Funktionsdefinition ist aber besser, weil der Parameter <code>eingabe</code> hei\xDFt\nund damit anders als die Funktion selbst.",task:"Schreibe eine Funktion <code>ping</code>, die einen Parameter hat und dessen Wert einfach zur\xFCckgibt.\nAchte darauf, dass der Parameter anders hei\xDFt, als die Funktion selbst.",beforeTests:function(){ping=undefined},tests:[function(){return jshero.testutil.assert_isFunction("ping")},function(){return jshero.testutil.assert_functionHasNumOfParameter("ping",1)},function(){return jshero.testutil.assert_functionReturns("ping(\"Test\")","Test")},function(){return jshero.testutil.assert_functionReturns("ping(\"Hallo Welt!\")","Hallo Welt!")}]});
jshero.koans.add({id:"parseint",title:"parseInt",lesson:"H\xE4ufig m\xF6chte man eine Zahl, die als String vorliegt, in eine Zahl vom Typ Number umwandeln. "+"F\xFCr das Umwandeln von ganzen Zahlen (..., -2, -1, 0, 1, 2, ..) gibt es in JavaScript die Funktion <code>parseInt</code>. "+"Folgende Beispiele geben <code>19</code> oder <code>-19</code> zur\xFCck: "+"<pre><code>"+"var n1 = parseInt(\"19\", 10);<br>"+"var n2 = parseInt(\"+19\", 10);<br>"+"var n3 = parseInt(\"-19\", 10);<br>"+"var n4 = parseInt(\"19 Grad\", 10);<br>"+"var n5 = parseInt(\"19.1\", 10);<br>"+"var n6 = parseInt(\"019\", 10);<br>"+"var n7 = parseInt(\" 19\", 10);<br>"+"</code></pre>"+"Neben dem direkten Einlesen von ganzen Zahlen mit oder ohne Vorzeichen (n1, n2, n3) beherrscht <code>parseInt</code> auch einige komplexe F\xE4lle. Nicht-numerische Zeichen nach "+"der ganzen Zahl (n4, n5) sowie Nullen (n6) und Leerzeichen (n7) vor der Zahl werden ignoriert.<br><br>"+"In allen Beispielen ist der zweite an <code>parseInt</code> \xFCbergebene Parameter <code>10</code>. Dieser Paramter gibt an, zu welcher Basis die Zahl "+"interpretiert werden soll. <code>10</code> steht f\xFCr das \xFCbliche Dezimalsystem. L\xE4\xDFt man den zweiten Paramter weg, wird normalerweise das Dezimalsystem als Default verwendet. "+"Da es aber von dieser Regel Ausnahmen gibt und diese Ausnahmen in verschiedenen Browsern auch noch unterschiedlich gehandhabt werden, sollte man immer die Basis mit angeben!<br><br>"+"Kann <code>parseInt</code> keine Zahl einlesen, gibt sie den Wert <code>NaN</code> (engl.: Not a Number) zur\xFCck:"+"<pre><code>"+"var n1 = parseInt(\"Nur Text\", 10);<br>"+"var n2 = parseInt(\"Nr. 8\", 10);<br>"+"</code></pre>"+"Im ersten Fall ist \xFCberhaupt keine Zahl vorhanden. Im zweiten Fall gibt es nicht-numerische Zeichen vor der eigentlichen Zahl. Auch das ist nicht zul\xE4ssig und f\xFChrt zur R\xFCckgabe "+"<code>NaN</code>.",task:"Schreibe eine Funktion <code>add</code>, die einen String mit einer Additionsaufgabe entgegennimmt und die das Ergebnis der Addition als Zahl zur\xFCckgibt. "+"Es sollen zwei nat\xFCrliche Zahlen addiert werden. Die Additionsaufgabe ist ein String der Form \"zahl1+zahl2\". So soll <code>add(\"100+19\")</code> die Zahl <code>119</code> zur\xFCckgeben.",beforeTests:function(){if(typeof add!=="undefined"){add=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("add")},function(){return jshero.testutil.assert_functionHasNumOfParameter("add",1)},function(){return jshero.testutil.assert_functionReturns("add(\"1+2\")",3)},function(){return jshero.testutil.assert_functionReturns("add(\"100123+456\")",100579)},function(){return jshero.testutil.assert_functionReturns("add(\"-10+6\")",-4)}]});
jshero.koans.add({id:"pi",title:"Math.PI",lesson:"Neben Funktionen bietet <code>Math</code> auch einige mathematische Konstanten an. "+"<code>Math.PI</code> liefert die Kreiszahl &pi; (gerundet 3.14) und <code>Math.E</code> die Eulersche Zahl e (gerundet 2.71). "+"Beachte: Die Konstanten werden im Gegensatz zu Funktionen ohne anschlie\xDFende Klammern aufgerufen.",task:"Schreibe eine Funktion <code>flaeche</code>, die die Fl\xE4che eines Kreises berechnet. "+"\xDCbergeben wird der Funktion als Parameter der Radius des Kreises. Tipp: Die Fl\xE4che eines Kreises ist &pi; * r&sup2;. "+"Dabei ist r der Radius des Kreises.",beforeTests:function(){if(typeof flaeche!=="undefined"){flaeche=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("flaeche")},function(){return jshero.testutil.assert_functionHasNumOfParameter("flaeche",1)},function(){return jshero.testutil.assert_functionReturns("flaeche(4)",Math.PI*4*4)},function(){return jshero.testutil.assert_functionReturns("flaeche(1)",Math.PI)},function(){return jshero.testutil.assert_functionReturns("flaeche(0)",0)}]});
(function(testutil,evaluator){var evalDice=function(){return evaluator.evalTest('dice()')};var isOneToSix=function(x){return x===1||x===2||x===3||x===4||x===5||x===6};var throwA=function(x){var result;for(var i=0;i<1000;i++){result=evalDice();if(result===x){return true}}return false};var testWith=function(x){var ok,msg,e;try{ok=throwA(x);if(ok){msg='<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>'+x+'</code> zur\xFCck.'}else{msg='<code>dice()</code> gab bei 1000 Aufrufen keine <code>'+x+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>dice()</code>.';e=exc}return{ok:ok,msg:msg,e:e}};jshero.koans.add({id:'random',title:'Zufallszahlen',lesson:'Mit <code>Math.random()</code> erzeugt man eine Pseudozufallszahl zwischen 0 (inklusive) und 1 (exklusive).\n\n<pre><code>var x = Math.random();</code></pre>\n\n<code>x</code> k\xF6nnte z.B. den Wert <code>0.6206372241429993</code> erhalten.\nJeder Aufruf von <code>Math.random()</code> generiert eine neue Pseudozufallszahl.\nDie Zahlen sind zwischen 0 und 1 gleichverteilt. Sie hei\xDFen Pseudozufallszahlen,\nweil sie zuf\xE4llig aussehen, aber dennoch berechnet werden.\nM\xF6chte man Zufallszahlen in einem anderen Wertebereich oder mit einer anderen Verteilung erhalten,\nmuss man die von <code>Math.random()</code> generierten Zahlen\ngeeignet umrechnen. Das soll jetzt gleich ge\xFCbt werden.',task:'Schreibe eine Funktion <code>dice</code>, die wie ein W\xFCrfel eine Zufallszahl zwischen 1 und 6 zur\xFCckgibt.',beforeTests:function(){if(typeof dice!=='undefined'){dice=undefined}},tests:[function(){return testutil.assert_isFunction('dice')},function(){return testutil.assert_functionHasNumOfParameter('dice',0)},function(){var ok,msg,e;try{ok=true;var result;for(var i=0;i<1000;i++){result=evalDice();if(!isOneToSix(result)){ok=false;break}}if(ok){msg='<code>dice()</code> gab bei 1000 Aufrufen nur nat\xFCrliche Zahlen zwischen <code>1</code> und <code>6</code> zur\xFCck.'}else{msg='<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>'+JSON.stringify(result)+'</code> zur\xFCck. Dies ist keine nat\xFCrliche Zahl zwischen <code>1</code> und <code>6</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>dice()</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){return testWith(1)},function(){return testWith(2)},function(){return testWith(3)},function(){return testWith(4)},function(){return testWith(5)},function(){return testWith(6)}]})})(jshero.testutil,jshero.evaluator);
(function(testutil){jshero.koans.add({id:"regex1",title:"Regex: Zeichenliterale",lesson:"<a href=\"https://de.wikipedia.org/wiki/Regul%C3%A4rer_Ausdruck\">Regul\xE4re Ausdr\xFCcke</a>,\nkurz Regex (engl.: regular expression), sind Muster zum Beschreiben von Zeichenketten.\nSie bilden eine kleine, eigenst\xE4ndige Sprache, die Teil von JavaScript\nund vielen weiteren Sprachen (Python, Perl, ...) und Programmen (LibreOffice, Emacs, ...) ist.\nRegul\xE4re Ausdr\xFCcke sind leistungsstark, aber auch sehr kryptisch.\n<br><br>\nIn JavaScript werden regul\xE4re Ausdr\xFCcke zwischen Schr\xE4gstrichen notiert:\n\n<pre><code>var pruefeAufOF = /OF/;</code></pre>\n\nHier ist <code>OF</code> der regul\xE4rer Ausdruck. Es ist ein sogenanntes Zeichenliteral und steht f\xFCr sich selbst.\nMit ihm kann man testen, ob ein anderer String die Zeichenfolge <code>OF</code> enth\xE4lt:\n\n<pre><code>var t1 = /OF/.test(\"OF-C 79\");\nvar t2 = /OF/.test(\"B-OF 61\")\nvar t3 = /OF/.test(\"HB-F 42\");\nvar t4 = /OF/.test(\"Ofen\");</code></pre>\n\n<code>test()</code> ist eine Regex-Methode. Sie gibt <code>true</code> zur\xFCck, wenn\nder ihr \xFCbergebene String das durch den Regex beschriebene Muster enth\xE4lt.\nIn unserem Fall ist das Muster die Zeichenfolge <code>OF</code>. <code>\"OF-C 79\"</code> und\n<code>\"B-OF 61\"</code> enthalten <code>OF</code>, also erhalten <code>t1</code> und <code>t2</code>\nden Wert <code>true</code>. Der String <code>\"HB-F 42\"</code> enth\xE4lt nicht <code>OF</code>.\n<code>t3</code> ist <code>false</code>.\n<br>\nRegul\xE4re Ausdr\xFCcke unterscheiden zwischen Gro\xDF- und Kleinschreibung.\n<code>\"Ofen\"</code> enth\xE4lt zwar <code>Of</code>, aber nicht <code>OF</code>.\n<code>t4</code> ist <code>false</code>.",task:"Schreibe eine Funktion <code>enthaeltRose</code>, die pr\xFCft, ob ein String den Teilstring\n<code>\"Rose\"</code> enth\xE4lt. <code>enthaeltRose(\"eine Rose\")</code> sollte <code>true</code> und\n<code>enthaeltRose(\"ein Blatt\")</code> sollte <code>false</code> ergeben.",hint:"<pre><code>Benutze den Regex /Rose/.</pre></code>",solution:"<pre><code>var enthaeltRose = function(s) {\n  return /Rose/.test(s);\n};</pre></code>",beforeTests:function(){enthaeltRose=undefined},tests:[function(){return testutil.assert_isFunction("enthaeltRose")},function(){return testutil.assert_functionHasNumOfParameter("enthaeltRose",1)},function(){return testutil.assert_functionReturns("enthaeltRose(\"eine Rose\")",true)},function(){return testutil.assert_functionReturns("enthaeltRose(\"zwei Rosen\")",true)},function(){return testutil.assert_functionReturns("enthaeltRose(\"ein Blatt\")",false)},function(){return testutil.assert_functionReturns("enthaeltRose(\"zwei Bl\xE4tter\")",false)}]})})(jshero.testutil);
jshero.koans.add({id:"regex2",title:"Regex: Beliebiges Zeichen",lesson:"Neben einfachen Zeichenliteralen kennen regul\xE4re Ausdr\xFCcke eine\nReihe von Zeichen mit besonderer Bedeutung, sogenannte Metazeichen.\nEin solches Metazeichen ist der Punkt. Er steht f\xFCr genau ein beliebiges Zeichen ausgenommen den Zeilenumbruch: \n\n<pre><code>var t1 = /M.ier/.test(\"Maier\");\nvar t2 = /M.ier/.test(\"Meierei\");\nvar t3 = /M.ier/.test(\"Baier\");\nvar t4 = /M.ier/.test(\"Mier\");\nvar t5 = /M.ier/.test(\"M-ier\");</code></pre>\n\nDer regul\xE4rer Ausdruck <code>/M.ier/</code> steht f\xFCr alle Zeichenketten, die mit\n<code>M</code> beginnen, ein beliebiges zweites Zeichen besitzen und anschlie\xDFend mit\n<code>ier</code> enden. Damit k\xF6nnen wir testen, ob ein String <code>Maier</code> oder\n<code>Meier</code> enth\xE4lt. Das ist in den ersten beiden Beispielzeilen der Fall.\n<code>t1</code> und <code>t2</code> sind <code>true</code>. Der String <code>\"Baier\"</code> enth\xE4lt\nkein Pattern, dass mit <code>M</code> beginnt. <code>t3</code> ist <code>false</code>.\nAuch <code>t4</code> ist <code>false</code>, da zwischen <code>M</code> und <code>ier</code>\ngenau ein Zeichen liegen muss. Das ist hier nicht der Fall. Da der Punkt f\xFCr jedes beliebige Zeichen\nsteht, trifft <code>\"M-ier\"</code> auch auf unser Pattern zu. <code>t5</code> ist <code>true</code>.\n<br><br>\nDer Punkt kann auch mehrmals in einem Pattern verwendet werden.\n<code>/H..s/</code> steht f\xFCr alle Zeichenketten, die mit <code>H</code> beginnen, anschlie\xDFend\nzwei beliebige Zeichen besitzen und mit <code>s</code> enden. <code>Hans</code> und <code>Haus</code>\ntreffen auf dieses Pattern zu, <code>His</code> und <code>Heros</code> nicht.",task:"Schreibe eine Funktion <code>pruefe</code>, die feststellt, ob ein String zwei in\neinfache Anf\xFChrungszeichen eingeschlossene Zeichen besitzt.  \n<code>pruefe(\"'Wo'\")</code> sollte <code>true</code> und\n<code>pruefe(\"'Was'\")</code> sollte <code>false</code> ergeben.",beforeTests:function(){pruefe=undefined},tests:[function(){return jshero.testutil.assert_isFunction("pruefe")},function(){return jshero.testutil.assert_functionHasNumOfParameter("pruefe",1)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"'Ja'\")",true)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"-'Oh'-\")",true)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"'A'\")",false)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"'Was'\")",false)}]});
jshero.koans.add({id:"regex3",title:"Regex: Zeichenauswahl",lesson:"Die letzte Lektion f\xFChrte als Metazeichen den Punkt ein.\nEr steht f\xFCr ein beliebiges Zeichen. So steht <code>/M.ier/</code> sowohl f\xFCr <code>Maier</code>\nals auch f\xFCr <code>Meier</code>. Er steht aber auch f\xFCr <code>Mxier</code>.\nM\xF6chte man letzteres ausschlie\xDFen, so muss man die Zeichenauswahl auf <code>a</code>\nund <code>e</code> begrenzen. Dazu schreibt man die gew\xFCnschte Auswahl in eckige Klammern:\n\n<pre><code>var var t1 = /M[ae]ier/.test(\"Maier\");\nvar t2 = /M[ae]ier/.test(\"Meier\");\nvar t3 = /M[ae]ier/.test(\"Mxier\");\nvar t4 = /M[ae]ier/.test(\"Maeier\");</code></pre>\n\nDer Ausdruck in eckigen Klammern steht f\xFCr genau ein Zeichen aus diesem Ausdruck.\n<code>/[ae]/</code> steht also f\xFCr ein Zeichen, das ein <code>a</code> oder ein <code>e</code> ist.\n<code>/M[ae]ier/</code> steht dann f\xFCr <code>Maier</code> oder <code>Meier</code>.\nDie Variablen <code>t1</code> sowie <code>t2</code> sind <code>true</code> und <code>t3</code>\nist <code>false</code>. Da <code>/[ae]/</code> f\xFCr genau ein Zeichen steht, ist <code>t4</code>\nauch <code>false</code>.<br><br>\nDie Auswahl kann beliebig viele Zeichen enthalten. <code>/[abc]/</code> steht f\xFCr a, b oder c\nund <code>/[123456]/</code> steht f\xFCr eine Ziffer von 1 bis 6.",task:"Schreibe eine Funktion <code>pruefe</code>, die feststellt, ob ein String den Namen\nMeier in einer der 4 Schreibweisen Maier, Meier, Mayer oder Meyer enth\xE4lt.\n<code>pruefe(\"Frau Mayer\")</code> sollte <code>true</code> und\n<code>pruefe(\"Herr Mezer\")</code> sollte <code>false</code> ergeben.",hint:"<pre><code>var pruefe = function(s) {\n// Verwende die Zeichenauswahl\n// zweimal.\n};</code></pre>",solution:"<pre><code>var pruefe = function(s) {\n  return /M[ae][iy]er/.test(s);\n};</code></pre>",beforeTests:function(){pruefe=undefined},tests:[function(){return jshero.testutil.assert_isFunction("pruefe")},function(){return jshero.testutil.assert_functionHasNumOfParameter("pruefe",1)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"Maier\")",true)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"Meier\")",true)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"Mayer\")",true)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"Meyer\")",true)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"Mazer\")",false)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"Moyer\")",false)}]});
jshero.koans.add({id:"regex4",title:"Regex: Bereiche",lesson:"M\xF6chte man mit der Zeichenauswahl alle Ziffern zulassen, so kann man\ndaf\xFCr <code>/[0123456789]/</code> verwenden. Das ist aber recht umst\xE4ndlich. \nMit einem Bindestrich kann man gr\xF6\xDFere, zusammenh\xE4ngende Zeichenbereiche leicht darstellen:\n\n<pre><code>var pruefeZiffer = /[0-9]/;\nvar pruefe1Bis6 = /[1-6]/;\nvar pruefeABisZ = /[A-Z]/;\nvar pruefeaBisz = /[a-z]/; \nvar pruefeDeutschesAlphabet = /[a-z\xE4\xF6\xFC\xDF]/;\nvar pruefeABisz = /[A-Za-z]/;\nvar pruefeMBisT = /[M-T]/;</code></pre>\n\n<code>/[0-9]/</code> steht wie der Regex oben f\xFCr genau eine Ziffer.\nDen Ziffernbereich kann man, wie <code>/[1-6]/</code> zeigt, leicht auf eine gew\xFCnschte Auswahl\n(z.B. Schulnote) einschr\xE4nken. Der Bindestrich funktioniert aber nicht nur f\xFCr Ziffern,\nsondern auch f\xFCr Buchstaben. Dabei muss man zwischen Klein- und\nGro\xDFbuchstaben unterscheiden. <code>/[A-Z]/</code> steht f\xFCr einen der 26 Gro\xDFbuchstaben und\n<code>/[a-z]/</code> f\xFCr einen Kleinbuchstaben. Wichtig ist, dass hier\n\xE4, \xF6, \xFC und \xDF nicht mit erfasst werden. M\xF6chte man das, so muss man diese Buchstaben gesondert\nauff\xFChren. Dazu schreibt man die Umlaute und das Eszett wie bei einer gew\xF6hnlichen Auswahl\neinfach vor oder hinter den Bereich (<code>/[a-z\xE4\xF6\xFC\xDF]/</code>). Ebenso kann man zwei Bereiche\nhintereinander auff\xFChren. <code>/[A-Za-z]/</code> steht f\xFCr genau einen Klein- oder Gro\xDFbuchstaben.\nDen Buchstabenbereich kann man wie bei Ziffern beliebig einschr\xE4nken (<code>/[M-T]/</code>).",task:"Schreibe eine Funktion <code>pruefe</code>, die testet, ob ein String eine\nZeichenfolge wie \"Klasse 2b\" enth\xE4lt. Dabei sind Klassen von 1 bis 6 und a bis d\nzul\xE4ssig. <code>pruefe(\"Die Klasse 1a\")</code> sollte <code>true</code> ergeben.",hint:"<pre><code>var pruefe = function(s) {\n// Verwende Literale\n// und Bereiche.  \n};</code></pre>",solution:"<pre><code>var pruefe = function(s) {\n  return /Klasse [1-6][a-d]/.test(s);\n};</code></pre>",beforeTests:function(){pruefe=undefined},tests:[function(){return jshero.testutil.assert_isFunction("pruefe")},function(){return jshero.testutil.assert_functionHasNumOfParameter("pruefe",1)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"Klasse 1a\")",true)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"Klasse 6d\")",true)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"Klasse 0a\")",false)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"Klasse 1e\")",false)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"Klasse 7d\")",false)},function(){return jshero.testutil.assert_functionReturns("pruefe(\"Kasse 1a\")",false)}]});
jshero.koans.add({id:"regex5",title:"Regex: Zeichenklassen",lesson:"F\xFCr einige besondere Zeichenbereiche gibt es Buchstaben als Abk\xFCrzung.\n<code>/\\d/</code> steht f\xFCr eine Ziffer (engl.: digit) und ist identisch mit\n<code>/[0-9]/</code>. Der Regex <code>/\\w/</code> steht f\xFCr ein alphanumerisches Zeichen oder\nden Unterstrich (engl.: word character). <code>/\\w/</code> ist identisch mit <code>/[0-9a-zA-Z_]/</code>.\nDer Abk\xFCrzung ist ein Backslash vorangestellt, damit sie nicht als normaler Buchstabe\ngelesen wird. Abk\xFCrzungen kann man auch innerhalb einer Zeichenauswahl verwenden.\n<code>/[\\da-z]/</code> steht f\xFCr eine Ziffer oder einen Kleinbuchstaben.",task:"Schreibe eine Funktion <code>hatPLZ</code>, die pr\xFCft, ob ein String eine\ndeutsche Postleitzahl enth\xE4llt. Eine deutsche Postleitzahl ist eine Zahl mit 5 Ziffern.\n<code>hatPLZ(\"28205\")</code> sollte <code>true</code> ergeben.",hint:"<pre><code>var hatPLZ = function(s) {\n// Verwende \\d f\xFCnfmal.\n};</code></pre>",solution:"<pre><code>var hatPLZ = function(s) {\n  return /\\d\\d\\d\\d\\d/.test(s);\n};</code></pre>",beforeTests:function(){hatPLZ=undefined},tests:[function(){return jshero.testutil.assert_isFunction("hatPLZ")},function(){return jshero.testutil.assert_functionHasNumOfParameter("hatPLZ",1)},function(){return jshero.testutil.assert_functionReturns("hatPLZ(\"28205 Bremen\")",true)},function(){return jshero.testutil.assert_functionReturns("hatPLZ(\"06493 Neudorf\")",true)},function(){return jshero.testutil.assert_functionReturns("hatPLZ(\"2805 Bremen\")",false)},function(){return jshero.testutil.assert_functionReturns("hatPLZ(\"06 493 Neudorf\")",false)}]});
(function(testutil){jshero.koans.add({id:"regex5a",title:"Regex: Anfangs- und Endezeichen",lesson:"Pattern, die wir bisher betrachtet haben, konnten an jeder beliebigen Stelle im zu durchsuchenden String\nstehen. Mit <code>^</code> und <code>$</code> kann man festlegen, dass das Pattern am Anfang bzw. am Ende des zu\ndurchsuchenden Strings stehen soll. <code>/^d/</code> trifft auf alle Zeichenketten zu, die mit einer Ziffer beginnen und\n<code>/d$/</code> trifft auf alle Zeichenketten zu, die mit einer Ziffer enden. Verwendet man sowohl das Anfangs-\nals auch das Endezeichen, beschreibt das Pattern den zu untersuchenden String vollst\xE4ndig. <code>/^dd$/</code> trifft\nauf alle Zeichenketten zu, die aus genau zwei Ziffern bestehen.",task:"Schreibe eine Funktion <code>isTime</code>, die pr\xFCft, ob ein String eine Zeitangabe der Form\nhh:mm:ss ist. hh steht dabei f\xFCr die Stunden, mm f\xFCr die Minuten und ss f\xFCr die Sekunden.\nEs sind alle Zeitangaben von 00:00:00 bis 99:59:59 zugelassen. Bei einstelligen Stunden, Minuten oder Sekunden ist eine\nf\xFChrende Null obligatorisch. <code>isTime(\"02:15:25\")</code> sollte <code>true</code> und\n<code>isTime(\"x02:15:25x\")</code> sollte <code>false</code> ergeben.",hint:"<pre><code>var isTime = function(s) {\n// Verwende ^, $ und\n// Bereiche.\n};</code></pre>",solution:"<pre><code>var isTime = function(s) {\n  return /^\\d\\d:[0-5]\\d:[0-5]\\d$/.test(s);      \n};</code></pre>",beforeTests:function(){isTime=undefined},tests:[function(){return testutil.assert_isFunction("isTime")},function(){return testutil.assert_functionHasNumOfParameter("isTime",1)},function(){return testutil.assert_functionReturns("isTime(\"00:00:00\")",true)},function(){return testutil.assert_functionReturns("isTime(\"99:59:59\")",true)},function(){return testutil.assert_functionReturns("isTime(\"02:15:25\")",true)},function(){return testutil.assert_functionReturns("isTime(\"000:00:00\")",false)},function(){return testutil.assert_functionReturns("isTime(\"00:00:000\")",false)},function(){return testutil.assert_functionReturns("isTime(\"00:60:00\")",false)},function(){return testutil.assert_functionReturns("isTime(\"00:00:60\")",false)},function(){return testutil.assert_functionReturns("isTime(\"0:00:00\")",false)},function(){return testutil.assert_functionReturns("isTime(\"00:0:00\")",false)},function(){return testutil.assert_functionReturns("isTime(\"00:00:0\")",false)}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"regex6",title:"Regex: ?",lesson:"In vielen Pattern ist das Vorkommen eines Zeichens variabel. Autokennzeichen\nbestehen aus einer variablen Anzahl von Buchstaben und Ziffern. F\xFCr solche Pattern stehen eine Reihe\nsogenannter Quantoren bereit. Ein elementarer Quantor ist das <code>?</code>. Er bedeutet,\ndass der voranstehende Ausdruck kein- oder einmal vorkommt. <code>/ab?c/</code> steht\nf\xFCr <code>ac</code> (b kommt keinmal vor) oder f\xFCr <code>abc</code> (b kommt einmal vor).\n<code>/[1-9]?[0-9]/</code> steht f\xFCr eine ein- oder zweistellige Zahl.",task:"Schreibe eine Funktion <code>pruefe</code>, die feststellt, ob ein String den\n<a href=\"https://de.wikipedia.org/wiki/Meier_(Familienname)\">Familiennamen Meier</a> in einer\nder 8 Schreibweisen Maier, Meier, Mayer, Meyer, Mair, Meir, Mayr oder Meyr enth\xE4lt.\n<code>pruefe(\"Mayer\")</code> und <code>pruefe(\"Mayr\")</code> sollte <code>true</code>\nergeben.",hint:"<pre><code>var pruefe = function(s) {\n// Benutze e?\n};</code></pre>",solution:"<pre><code>var pruefe = function(s) {\n  return /M[ae][iy]e?r/.test(s);\n};</code></pre>",beforeTests:function(){pruefe=undefined},tests:[function(){return testutil.assert_isFunction("pruefe")},function(){return testutil.assert_functionHasNumOfParameter("pruefe",1)},function(){return testutil.assert_functionReturns("pruefe(\"Maier\")",true)},function(){return testutil.assert_functionReturns("pruefe(\"Mair\")",true)},function(){return testutil.assert_functionReturns("pruefe(\"Mayer\")",true)},function(){return testutil.assert_functionReturns("pruefe(\"Mayr\")",true)},function(){return testutil.assert_functionReturns("pruefe(\"Meier\")",true)},function(){return testutil.assert_functionReturns("pruefe(\"Meir\")",true)},function(){return testutil.assert_functionReturns("pruefe(\"Meyer\")",true)},function(){return testutil.assert_functionReturns("pruefe(\"Meyr\")",true)},function(){return testutil.assert_functionReturns("pruefe(\"aye\")",false)},function(){return testutil.assert_functionReturns("pruefe(\"Mai\")",false)},function(){return testutil.assert_functionReturns("pruefe(\"Maior\")",false)},function(){return testutil.assert_functionReturns("pruefe(\"Mayeer\")",false)}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"regex7",title:"Regex: beliebige Wiederholung",lesson:"Zwei weitere wichtige Quantoren sind <code>*</code> und <code>+</code>. Beide bedeuten, dass\nder voranstehende Ausdruck beliebig oft vorkommen darf. Bei <code>*</code> darf er auch keinmal vorkommen.\nBei <code>+</code> muss er mindestens einmal vorkommen.\n<code>b\xE4h*</code> steht f\xFCr b\xE4, b\xE4h, b\xE4hh und so weiter. <code>[01]+</code> steht f\xFCr\neine beliebige <a href=\"https://de.wikipedia.org/wiki/Dualsystem\">bin\xE4re Zahl</a> wie zum Beispiel\n0, 1, 001, 10111 oder 11001100.",task:"Schreibe eine Funktion <code>hasQuote</code>, die feststellt, ob ein String ein mit einfachen\nAnf\xFChrungszeichen gekennzeichnetes Zitat enth\xE4lt. Innerhalb des Zitats sind beliebige Zeichen\nzul\xE4ssig. Ein leeres Zitat ist auch zugelassen. Das Zitat soll nicht \xFCber mehrere Zeilen gehen.\nEin Zeilenumbruch innerhalb des Zitats ist also nicht zul\xE4ssig.\n<code>hasQuote(\"'Ja!'\")</code> sollte <code>true</code> und\n<code>hasQuote(\"Ku'damm\")</code> sollte <code>false</code> ergeben.",hint:"<pre><code>var hasQuote = function(s) {\n// Benutze .*\n};</code></pre>",solution:"<pre><code>var hasQuote = function(s) {\n  return /'.*'/.test(s);\n};</code></pre>",beforeTests:function(){hasQuote=undefined},tests:[function(){return testutil.assert_isFunction("hasQuote")},function(){return testutil.assert_functionHasNumOfParameter("hasQuote",1)},function(){return testutil.assert_functionReturns("hasQuote(\"''\")",true)},function(){return testutil.assert_functionReturns("hasQuote(\"'Topp!'\")",true)},function(){return testutil.assert_functionReturns("hasQuote(\"Stimme: 'Ist gerettet!'\")",true)},function(){return testutil.assert_functionReturns("hasQuote(\"Du\")",false)},function(){return testutil.assert_functionReturns("hasQuote(\"Ku'damm\")",false)}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"regex8",title:"Regex: {n, m}",lesson:"Mit einen Ausdruck der Form <code>{n}</code>, <code>{n,m}</code> oder <code>{n,}</code> kann man die\nAnzahl der Wiederholungen genauer festlegen. <code>{n}</code> steht f\xFCr genau n Wiederholungen, <code>{n,m}</code>\nf\xFCr mindestens n und h\xF6chstens m Wiederholungen und <code>{n,}</code> f\xFCr mindestens n Wiederholungen.\nSo steht <code>/\\d{5}/</code> f\xFCr genau 5 aufeinanderfolgende Ziffern, <code>/.{6,20}/</code> f\xFCr mindestens 6 und\nh\xF6chsten 20 beliebige Zeichen und <code>/\\[a-zA-Z]{5,}/</code> f\xFCr mindestens 5 aufeinanderfolgende Buchstaben.",task:"Schreibe eine Funktion <code>pruefe</code>, die feststellt, ob ein String ein deutsches\nKfz-Kennzeichen ist. Ein solches Kennzeichen soll dem Schema 'XXX YY NNNN' gen\xFCgen. Dabei steht XXX f\xFCr 1 bis 3\nbeliebige Gro\xDFbuchstaben, YY f\xFCr 1 bis 2 beliebige Gro\xDFbuchstaben und NNNN f\xFCr eine maximal 4stellige Zahl. F\xFChrende\nNullen sind bei der Zahl nicht zugelassen. <code>pruefe(\"OF C 709\")</code> sollte <code>true</code> und\n<code>pruefe(\"OF 709\")</code> sollte <code>false</code> ergeben.",hint:"<pre><code>var pruefe = function(s) {\n  return /^[A-Z]{1,3}...\n};</code></pre>",solution:"<pre><code>var pruefe = function(s) {\n  return /^[A-Z]{1,3} [A-Z]{1,2} [1-9][0-9]{0,3}$/.test(s);\n};</code></pre>",beforeTests:function(){hasQuote=undefined},tests:[function(){return testutil.assert_isFunction("pruefe")},function(){return testutil.assert_functionHasNumOfParameter("pruefe",1)},function(){return testutil.assert_functionReturns("pruefe(\"F A 1\")",true)},function(){return testutil.assert_functionReturns("pruefe(\"F A 9999\")",true)},function(){return testutil.assert_functionReturns("pruefe(\"F AA 1\")",true)},function(){return testutil.assert_functionReturns("pruefe(\"LUP A 1\")",true)},function(){return testutil.assert_functionReturns("pruefe(\"F A 0\")",false)},function(){return testutil.assert_functionReturns("pruefe(\"F A 01\")",false)},function(){return testutil.assert_functionReturns("pruefe(\"F A 12345\")",false)},function(){return testutil.assert_functionReturns("pruefe(\"F A\")",false)},function(){return testutil.assert_functionReturns("pruefe(\"F 1\")",false)},function(){return testutil.assert_functionReturns("pruefe(\"F AAA 1\")",false)},function(){return testutil.assert_functionReturns("pruefe(\"FFFF A 1\")",false)}]})})(jshero.testutil);
jshero.koans.add({id:'replace',title:'String: replace()',lesson:'Die Methode <code>replace</code> ersetzt einen Teilstring durch einen anderen:\n\n<pre><code>var str = "Hallo Marcel!";\nvar newstr = str.replace("Marcel", "Robert");</code></pre>\n\n"Marcel" wird durch "Robert" ersetzt. <code>newstr</code> hat also den Wert <code>"Hallo Robert!"</code>.\nDer urspr\xFCngliche String bleibt unver\xE4ndert. Nur das erste Vorkommen wird ersetzt:\n\n<pre><code>var newname = "Peter".replace("e", "a");</code></pre>\n\n<code>newname</code> enth\xE4lt den Wert <code>"Pater"</code> und nicht <code>"Patar"</code>.\nEin Spezialfall ergibt sich, wenn der ersetzende String der Leerstring ist:\n\n<pre><code>var nurso = "sowie so".replace("wie", "");</code></pre>\n\nDer zu ersetzende String wird entfernt. <code>nurso</code> enth\xE4lt den Wert <code>"so so"</code>.\nKommt der zu ersetzende String nicht vor, so wird der urspr\xFCngliche String zur\xFCckgegeben.',task:'Schreibe eine Funktion <code>convert</code>, die einen Datumsstring in englischer Schreibweise (20-05-2017 oder 20/05/2017) in\ndeutsche Schreibweise (20.05.2017) umwandet. Sowohl <code>convert("20-05-2017")</code> als auch <code>convert("20/05/2017")</code>\nsollten <code>"20.05.2017"</code> ergeben.',hint:'<pre><code>var convert = function(s1, s2) {\n// Verwende replace viermal.\n};',solution:'<pre><code>var convert = function(dateEn) {\n  var dateDe = dateEn.replace("-", ".");\n  dateDe = dateDe.replace("-", ".");\n  dateDe = dateDe.replace("/", ".");\n  dateDe = dateDe.replace("/", ".");\n  return dateDe;\n};',beforeTests:function(){if(typeof convert!=='undefined'){convert=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('convert')},function(){return jshero.testutil.assert_functionHasNumOfParameter('convert',1)},function(){return jshero.testutil.assert_functionReturns('convert("10-07-1871")','10.07.1871')},function(){return jshero.testutil.assert_functionReturns('convert("8/11/1922")','8.11.1922')}]});
jshero.koans.add({id:"round",title:"Runden",lesson:"M\xF6chte man eine Dezimalzahl auf- oder abrunden, stehen einem die Funktionen <code>Math.round()</code>,\n<code>Math.floor()</code> (engl.: Boden) und <code>Math.ceil()</code> (engl: Decke) zur Verf\xFCgung.\n\n<pre><code>var a = Math.round(5.49);\nvar b = Math.round(4.5);\nvar c = Math.floor(5.99);\nvar d = Math.ceil(4.01);</code></pre>\n\n<code>Math.round()</code> rundet kaufm\xE4nnisch. Zahlen mit der ersten Dezimalstelle kleiner gleich 4 werden abgerundet, alle anderen aufgerundet.\n<code>Math.floor()</code> rundet immer ab und <code>Math.ceil()</code> rundet immer auf. Die Variablen <code>a</code> bis <code>d</code>\nerhalten also alle den Wert <code>5</code>.",task:"Schreibe eine Funktion <code>round100</code>, die eine Dezimalzahl kaufm\xE4nnisch auf die Hunderterstelle rundet.\n<code>round100(1749)</code> sollte <code>1700</code> und <code>round100(856.123)</code> sollte <code>900</code> ergeben.\nTipp:&nbsp;Verwende neben <code>Math.round()</code> noch Multiplikation und Division.",beforeTests:function(){if(typeof round100!=="undefined"){round100=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("round100")},function(){return jshero.testutil.assert_functionHasNumOfParameter("round100",1)},function(){return jshero.testutil.assert_functionReturns("round100(49.999)",0)},function(){return jshero.testutil.assert_functionReturns("round100(50)",100)},function(){return jshero.testutil.assert_functionReturns("round100(349)",300)},function(){return jshero.testutil.assert_functionReturns("round100(350)",400)},function(){return jshero.testutil.assert_functionReturns("round100(4649)",4600)},function(){return jshero.testutil.assert_functionReturns("round100(4650)",4700)}]});
jshero.koans.add({id:'slice',title:'Array: slice()',lesson:'Mit <code>slice</code> kopiert man aus einem Array ein Teilarray:\n\n<pre><code>var abcd = ["a", "b", "c", "d"];\nvar ab = abcd.slice(0, 2);\nvar bc = abcd.slice(1, 3);\nvar bcd = abcd.slice(1, 4);</code></pre>\n\nDer erste Parameter gibt den Startindex (einschlie\xDFlich), der zweite den Endindex (ausschlie\xDFlich) an.\nDas urspr\xFCngliche Array wird nicht ver\xE4ndert.',task:'Schreibe eine Funktion <code>halve</code>, die aus einem Array die erste H\xE4lfte kopiert.\nBei einer ungeraden Anzahl von Array-Elementen soll das mittlere Element zu der ersten H\xE4lfte geh\xF6ren.\n<code>halve([1,&nbsp;2,&nbsp;3,&nbsp;4])</code> sollte <code>[1,&nbsp;2]</code> zur\xFCckgeben.',beforeTests:function(){if(typeof halve!=='undefined'){halve=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('halve')},function(){return jshero.testutil.assert_functionHasNumOfParameter('halve',1)},function(){return jshero.testutil.assert_functionReturns('halve([1, 2])',[1])},function(){return jshero.testutil.assert_functionReturns('halve([1, 2, 3])',[1,2])},function(){return jshero.testutil.assert_functionReturns('halve([1, 2, 3, 4])',[1,2])},function(){return jshero.testutil.assert_functionReturns('halve([1, 2, 3, 4, 5])',[1,2,3])}]});
jshero.koans.add({id:"string",title:"Strings",lesson:"Wir haben gesehen, dass eine Variable ein Beh\xE4lter f\xFCr einen Wert ist. Werte besitzen dabei einen Typ.\nSo kann ein Wert eine Zahl wie <code>7.12</code> sein. Der Typ von <code>7.12</code> ist Zahl. Oder ein Wert kann\nein Text wie <code>\"Hallo Welt!\"</code> sein. Der Typ von <code>\"Hallo Welt!\"</code> ist Text. Diesen Typ bezeichnet\nman auch als Zeichenkette oder String. Strings schreibt man immer in einfachen oder doppelten Anf\xFChrungszeichen.\nSo ist \"Hallo Welt!\" derselbe String wie 'Hallo Welt!'.<br>Mit Strings kann man arbeiten. Man kann sie zum Beispiel\nverketten. Dies macht man mit dem <code>+</code> Zeichen. So liefert <code>\"Blau\" + \"meier\"</code> den String\n<code>\"Blaumeier\"</code>.<br>Die folgende Funktion h\xE4ngt an dem \xFCbergebenen Parameter einen Text an und\ngibt den zusammengesetzten Text zur\xFCck:\n\n<pre><code>var lobe = function(name) {\n  return name + \" ist toll!\";\n};</code></pre>\n\nSo liefert <code>lobe(\"JavaScript\")</code> den Wert <code>\"JavaScript ist toll!\"</code>.",task:"Schreibe eine Funktion <code>begruesse</code>, die einen Parameter entgegennimmt und die\n<code>\"Hallo &lt;Parameter&gt;!\"</code> zur\xFCckgibt. \xDCbergibt man der Funktion <code>\"Maria\"</code>,\nso sollte die Funktion <code>\"Hallo Maria!\"</code> zur\xFCckgeben. \xDCbergibt man der Funktion <code>\"Franz\"</code>,\nso sollte die R\xFCckgabe <code>\"Hallo Franz!\"</code> sein.",hint:"<pre><code>var begruesse = function(name) {\n  return ...\n};",solution:"<pre><code>var begruesse = function(name) {\n  return \"Hallo \" + name + \"!\";\n};",beforeTests:function(){begruesse=undefined},tests:[function(){return jshero.testutil.assert_isFunction("begruesse")},function(){return jshero.testutil.assert_functionHasNumOfParameter("begruesse",1)},function(){return jshero.testutil.assert_functionReturns("begruesse(\"Maria\")","Hallo Maria!")},function(){return jshero.testutil.assert_functionReturns("begruesse(\"Franz\")","Hallo Franz!")}]});
jshero.koans.add({id:'stringcharat',title:'String: charAt()',lesson:'Um aus einem String das Zeichen an einer bestimmten Stelle zu erhalten, verwendet man die Methode\n<code>charAt(index)</code>. Der Paramter <code>index</code> gibt die Stelle des Zeichens innerhalb der Zeichenkette an.\nDabei hat das erste Zeichen einer Zeichenkette den Index 0:\n\n<pre><code>var n1 = "Maria".charAt(0);\nvar n2 = "Maria".charAt(1);\nvar n3 = "Maria".charAt(5);\nvar n4 = "Maria".charAt();</code></pre>\n\n<code>n1</code> hat den Wert <code>"M"</code> und <code>n2</code> hat den Wert <code>"a"</code>. Ist der Index gr\xF6\xDFer\nals der Index des letzten Zeichens, wird der leere String zur\xFCckgegeben. <code>n3</code> hat also den Wert <code>""</code>.\nWird kein Parameter \xFCbergeben, so wird das Zeichen mit dem Index <code>0</code> zur\xFCckgegeben. Man sagt: der Default-Wert\nf\xFCr <code>index</code> ist <code>0</code>. Der Wert von <code>n4</code> ist also auch <code>"M"</code>.',task:'Schreibe eine Funktion <code>abkuerzung</code>, die zwei Strings als Parameter entgegennimmt und als R\xFCckgabe die Anfangsbuchstaben\ndieser Strings zur\xFCckgibt. <code>abkuerzung("Hansestadt", "Bremen")</code> sollte <code>"HB"</code> zur\xFCckliefern.',hint:'<pre><code>var abkuerzung = function(s1, s2) {\n  ...\n};',solution:'<pre><code>var abkuerzung = function(s1, s2) {\n  return s1.charAt(0) + s2.charAt(0);\n};',beforeTests:function(){if(typeof abkuerzung!=='undefined'){abkuerzung=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('abkuerzung')},function(){return jshero.testutil.assert_functionHasNumOfParameter('abkuerzung',2)},function(){return jshero.testutil.assert_functionReturns('abkuerzung("Hansestadt", "Bremen")','HB')},function(){return jshero.testutil.assert_functionReturns('abkuerzung("Java", "Script")','JS')}]});
jshero.koans.add({id:'stringindexof',title:'String: indexOf()',lesson:'Um die Position eines Strings innerhalb eines anderen Strings zu bestimmen, verwendet man die Methode <code>indexOf</code>:\n\n<pre><code>var n1 = "Bit".indexOf("it");\nvar n2 = "Bit".indexOf("js");\nvar n3 = "Bit".indexOf("IT");</code></pre>\n\n<code>n1</code> ist <code>1</code>, da <code>"it"</code> in <code>"Bit"</code> an der 1. Stelle beginnt.\nWie \xFCblich beginnt die Z\xE4hlung mit 0.\nKommt das Suchwort im aufrufenden String nicht vor, wird <code>-1</code> zur\xFCckgegeben. <code>n2</code> ist also <code>-1</code>.\nDie Methode <code>indexOf()</code> unterscheidet zwischen Gro\xDF- und Kleinschreibung. <code>n3</code> ist also auch <code>-1</code>.',task:'Schreibe eine Funktion <code>indexOfIgnoreCase</code>, die 2 Strings entgegennimmt und wie die Methode\n<code>indexOf</code> die Position des zweiten Strings im ersten String bestimmt. Im Unterschied zur Methode\n<code>indexOf</code> soll die Gro\xDF- oder Kleinschreibung keine Rolle spielen. Sowohl <code>indexOfIgnoreCase("JS", "JS")</code>\nals auch <code>indexOfIgnoreCase("JS", "js")</code> sollten <code>0</code> ergeben.',hint:'<pre><code>var indexOfIgnoreCase = function(s1, s2) {\n// Wandle s1 und s2 zuerst\n// in Kleinbuchstaben um.\n// Verwende dann die\n// indexOf-Methode. \n};',solution:'<pre><code>var indexOfIgnoreCase = function(s1, s2) {\n  var s1Klein = s1.toLowerCase();\n  var s2Klein = s2.toLowerCase();\n  return s1Klein.indexOf(s2Klein);\n};',beforeTests:function(){if(typeof indexOfIgnoreCase!=='undefined'){indexOfIgnoreCase=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('indexOfIgnoreCase')},function(){return jshero.testutil.assert_functionHasNumOfParameter('indexOfIgnoreCase',2)},function(){return jshero.testutil.assert_functionReturns('indexOfIgnoreCase("JS", "js")',0)},function(){return jshero.testutil.assert_functionReturns('indexOfIgnoreCase("JavaScript", "Script")',4)},function(){return jshero.testutil.assert_functionReturns('indexOfIgnoreCase("Fred Feuerstein", "FEUER")',5)},function(){return jshero.testutil.assert_functionReturns('indexOfIgnoreCase("WILMA FEUERSTEIN", "feuer")',6)}]});
jshero.koans.add({id:'stringindexof2',title:'String: indexOf(), 2. Parameter',lesson:'Der Methode <code>indexOf</code> kann man als zweiten Parameter noch die Stelle mitgeben,\nab der der Suchstring im aufrufenden String gesucht werden soll.\n\n<pre><code>var n1 = "Fred Feuerstein".indexOf("e", 2);\nvar n2 = "Fred Feuerstein".indexOf("e", 3);\nvar n3 = "Fred Feuerstein".indexOf("e", 7);</code></pre>\n\nDas erste <code>"e"</code> befindet sich in <code>"Fred Feuerstein"</code> an 2. Stelle. Es wird bei einer Suche ab der 2. Stelle gefunden. <code>n1</code>\nist also 2. Das zweite <code>"e"</code> in <code>"Fred Feuerstein"</code> befindet sich an der 6. Stelle. Es wird bei der Suche ab der 3. Stelle gefunden.\n<code>n2</code> ist <code>6</code>. Mit der dritten Codezeile wird das dritte <code>"e"</code> in <code>"Fred Feuerstein"</code> gefunden.\n<code>n3</code> ist <code>8</code>.',task:'Schreibe eine Funktion <code>secondIndexOf</code>, die 2 Strings entgegennimmt und die zweite Position des\nzweiten Strings im ersten String bestimmt. Kommt der Suchstring nicht zweimal vor, so soll <code>-1</code> zur\xFCckgegeben werden.\n<code>secondIndexOf("Ida-Ida", "Ida")</code> soll <code>4</code> zur\xFCckgeben.\n<br/>Tipp: Falls Du Hilfe brauchst, lies dir auch die Beschreibung in\n<a href="https://wiki.selfhtml.org/wiki/JavaScript/Objekte/String/indexOf">SELFHTML</a> durch.',hint:'<pre><code>var secondIndexOf = function(s1, s2) {\n// Verwende indexOf zweimal.\n// Zuerst ohne, dann mit\n// zweitem Parameter. \n};',solution:'<pre><code>var secondIndexOf = function(s1, s2) {\n  var firstIndex = s1.indexOf(s2);\n  return s1.indexOf(s2, firstIndex + 1);\n};',beforeTests:function(){if(typeof secondIndexOf!=='undefined'){secondIndexOf=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('secondIndexOf')},function(){return jshero.testutil.assert_functionHasNumOfParameter('secondIndexOf',2)},function(){return jshero.testutil.assert_functionReturns('secondIndexOf("AA", "A")',1)},function(){return jshero.testutil.assert_functionReturns('secondIndexOf("Ida-Ida", "Ida")',4)},function(){return jshero.testutil.assert_functionReturns('secondIndexOf("a rose is a rose", "rose")',12)},function(){return jshero.testutil.assert_functionReturns('secondIndexOf("There is no there there.", "there")',18)},function(){return jshero.testutil.assert_functionReturns('secondIndexOf("There is no there there.", "There")',-1)}]});
jshero.koans.add({id:"stringlength",title:"String: length",lesson:"Strings besitzen die Eigenschaft <code>length</code>. Diese Eigenschaft liefert die Anzahl der Zeichen eines Strings. "+"Dazu muss man dem String  oder der Variablen, die den String enth\xE4lt, <code>.length</code> anh\xE4ngen:"+"<pre><code>var anzahl = \"Franz\".length;</code/></pre>"+"<code>\"Franz\"</code> hat 5 Zeichen. Also hat <code>anzahl</code> jetzt den Wert <code>5</code>."+"<pre><code>var stadt = \"Prag\";<br>anzahl = stadt.length;</code/></pre>"+"<code>\"Prag\"</code> hat 4 Zeichen. <code>anzahl</code> hat jetzt den Wert <code>4</code>."+"<pre><code>anzahl = \"\".length;</code/></pre>"+"Der Leerstring besitzt keine Zeichen. Der Wert von <code>anzahl</code> ist jetzt <code>0</code>.",task:"Schreibe eine Funktion <code>laenge</code>, die bei \xDCbergabe eines Strings die Anzahl der Zeichen dieses Strings zur\xFCckgibt. "+"<code>laenge(\"Franz\")</code> sollte <code>5</code> zur\xFCckgeben.",hint:"<pre><code>var laenge = function(s) {\n...\n};",solution:"<pre><code>var laenge = function(s) {\n  return s.length;\n};",beforeTests:function(){if(typeof laenge!=="undefined"){laenge=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("laenge")},function(){return jshero.testutil.assert_functionHasNumOfParameter("laenge",1)},function(){return jshero.testutil.assert_functionReturns("laenge(\"Hallo Welt!\")",11)},function(){return jshero.testutil.assert_functionReturns("laenge(\"\")",0)}]});
jshero.koans.add({id:'stringsplit',title:'String: split()',lesson:'Die Methode <code>split</code> zerlegt einen String anhand eines Trennstrings in Teilstrings. Die Teilstrings werden als Array zur\xFCckgegeben. '+'Der urspr\xFCngliche String wird nicht ver\xE4ndert.'+'<pre><code>'+'var date = "31-10-2017";<br>'+'var parts = date.split("-");<br>'+'var day = parts[0]; // "31"<br>'+'var month = parts[1]; // "10"<br>'+'var year = parts[2]; // "2017"<br>'+'</code></pre>'+'Der Trennstring ist hier der Bindestrich. Er zerlegt den Datumsstring in drei Teile. Diese drei Teile werden als Array der Variablen <code>parts</code> zugewiesen. '+'Anschlie\xDFend werden die einzelnen Teile aus dem Array ausgelesen und gesonderten Variablen zugewiesen. Die Variable <code>date</code> hat weiterhin den Wert <code>"31-10-2017"</code>.',task:'Schreibe eine Funktion <code>add</code>, die einen String mit einer Additionsaufgabe entgegennimmt und die das Ergebnis der Addition als Zahl zur\xFCckgibt. '+'Es sollen endlich viele nat\xFCrliche Zahlen addiert werden. Die Additionsaufgabe ist ein String der Form "1+19+...+281". '+'So soll <code>add("7+12+100")</code> die Zahl <code>119</code> zur\xFCckgeben.',beforeTests:function(){if(typeof add!=='undefined'){add=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('add')},function(){return jshero.testutil.assert_functionHasNumOfParameter('add',1)},function(){return jshero.testutil.assert_functionReturns('add("1+2")',3)},function(){return jshero.testutil.assert_functionReturns('add("12+5+1+10")',28)},function(){return jshero.testutil.assert_functionReturns('add("50000+4000+300+20+1")',54321)},function(){return jshero.testutil.assert_functionReturns('add("13+2+4+100+3")',122)}]});
jshero.koans.add({id:'stringsubstr',title:'String: substr()',lesson:'Die Methode <code>substr</code> extrahiert aus einen String einen Teilstring:\n\n<pre><code>var see = "see and stop".substr(0, 3);\nvar and = "see and stop".substr(4, 3);\nvar stop = "see and stop".substr(8);</code></pre>\n\nDer erste Parameter gibt an, von welcher Stelle an der Substring extrahiert werden soll.\nDer zweite Parameter gibt an, wieviel Zeichen ab der festgelegten Stelle extrahiert werden sollen.\nIst der zweite Paramter nicht angegeben, so wird immer bis zum Ende des urspr\xFCglichen Strings extrahiert.',task:'Schreibe eine Funktion <code>firstWord</code>, die einen String entgegennimmt und das erste Wort\nin diesem String zur\xFCckgibt. Das erste Wort sind dabei alle Zeichen bis zum ersten Leerzeichen.\n<code>firstWord("Wo ist hier")</code> sollte <code>"Wo"</code> zur\xFCckgeben.',hint:'<pre><code>var firstWord = function(s) {\n// Bestimme mit indexOf\n// die Position des\n// ersten Leerzeichens.\n// Verwende dann die\n// substr-Methode.\n};',solution:'<pre><code>var firstWord = function(s) {\n  var firstBlank = s.indexOf(" ");\n  return s.substr(0, firstBlank);\n};',beforeTests:function(){if(typeof firstWord!=='undefined'){firstWord=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('firstWord')},function(){return jshero.testutil.assert_functionHasNumOfParameter('firstWord',1)},function(){return jshero.testutil.assert_functionReturns('firstWord("Wo ist hier")','Wo')},function(){return jshero.testutil.assert_functionReturns('firstWord("Irres Licht")','Irres')}]});
jshero.koans.add({id:'stringupper',title:'String: toUpperCase()',lesson:'Neben der Eigenschaft <code>length</code> besitzen Strings noch eine Reihe von Methoden.\nDas sind Funktionen, die direkt auf dem String angewendet werden. Wie die Eigenschaft <code>length</code>\nwerden diese Methoden mit einem Punkt direkt dem String oder einer Variablen, die einen String enth\xE4lt, angeh\xE4ngt.\nDa Methoden Funktionen sind, folgen in runden Klammern eingeschlossen die Argumente.\nZwei dieser String-Methoden sind die parameterlosen Methoden <code>toUpperCase</code> und <code>toLowerCase</code>.\nSie geben den String, auf dem sie angewendet werden, in Gro\xDF- bzw. Kleinbuchstaben zur\xFCck. Wichtig ist,\ndass der eigentliche String unver\xE4ndert bleibt. Die R\xFCckgabe dieser Methoden ist der in Gro\xDF- bzw. Kleinbuchstaben\numgewandelte String.\n<pre><code>var stadt = "Prag";\nvar ausgabe = stadt.toUpperCase();</code/></pre>\n<code>ausgabe</code> erh\xE4lt den Wert <code>"PRAG"</code>. <code>stadt</code> hat weiterhin den Wert <code>"Prag"</code>.\n<pre><code>ausgabe = stadt.toLowerCase();</code/></pre>\nJetzt hat <code>ausgabe</code> den Wert <code>"prag"</code>.\n<pre><code>ausgabe = "Flug 714".toUpperCase();</code/></pre>\nHier wird <code>toUpperCase()</code> direkt auf einen String angewendet. Der Wert von <code>ausgabe</code> ist\n<code>"FLUG 714"</code>. Zahlen und auch Sonderzeichen werden nicht ver\xE4ndert.',task:'Schreibe eine Funktion <code>toCase</code>, die bei \xDCbergabe eines Strings diesen aneinandergeh\xE4ngt\nin Klein- und in Gro\xDFschreibung zur\xFCckgibt. Das Trennzeichen zwischen der Klein- und Gro\xDFschreibung soll\n<code>-</code> sein. <code>toCase("Ida")</code> sollte <code>"ida-IDA"</code> zur\xFCckgeben.',hint:'<pre><code>var toCase = function(text) {\n  return ... + "-" + ...;\n};',solution:'<pre><code>var toCase = function(text) {\n  return text.toLowerCase() + "-" + text.toUpperCase();\n};',beforeTests:function(){if(typeof toCase!=='undefined'){toCase=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('toCase')},function(){return jshero.testutil.assert_functionHasNumOfParameter('toCase',1)},function(){return jshero.testutil.assert_functionReturns('toCase("Ida")','ida-IDA')},function(){return jshero.testutil.assert_functionReturns('toCase("Paris")','paris-PARIS')}]});
(function(testutil){jshero.koans.add({id:'subfunction',title:'Funktionen benutzen Funktionen',lesson:'Funktionen k\xF6nnen weitere Funktionen aufrufen:\n<pre><code>var brutto = function(netto) {\n  var steuersatz = 19;\n  var steuer = netto * steuersatz / 100;\n  return netto + steuer;\n};\n\nvar addiereMitMehrwertsteuer = function(nettoX, nettoY) {\n  var bruttoX = brutto(nettoX);\n  var bruttoY = brutto(nettoY);\n  return bruttoX + bruttoY;\n};</code></pre>\n\n<code>addiereMitMehrwertsteuer</code> nimmt 2 Nettobetr\xE4ge entgegen und gibt die Summe der Bruttobetr\xE4ge zur\xFCck.\n<code>brutto</code>berechnet aus einem Nettobetrag den Bruttobetrag. Dabei wird eine Mehrwertsteuer von 19% zugrunde\ngelegt. Anstatt den Bruttobetrag selbst zu berechnen, ruft <code>addiereMitMehrwertsteuer</code> die Funktion\n<code>brutto</code> auf. Das hat zwei Vorteile: Der Code ist besser lesbar und die Bruttoberechnung wird zentral\nan einer Stelle durchgef\xFChrt.',task:'Schreibe eine Funktion <code>sum</code>, die ein Array gef\xFCllt mit Zahlen entgegennimmt und die Summe dieser\nZahlen zur\xFCckgibt. Schreibe eine Funktion <code>mean</code>, die ein Array gef\xFCllt mit Zahlen entgegennimmt und den\nDurchschnitt dieser Zahlen zur\xFCckgibt. Die Funktion <code>mean</code> soll dabei die Funktion <code>sum</code> benutzen.',beforeTests:function(){if(typeof sum!=='undefined'){mean=undefined}if(typeof mean!=='undefined'){mean=undefined}},tests:[function(){return testutil.assert_isFunction('sum')},function(){return testutil.assert_functionHasNumOfParameter('sum',1)},function(){return testutil.assert_functionReturns('sum([0])',0)},function(){return testutil.assert_functionReturns('sum([1, 2])',3)},function(){return testutil.assert_functionReturns('sum([1, 4, 10, 85])',100)},function(){return testutil.assert_functionReturns('sum([-2, -4, 17, 34])',45)},function(){return testutil.assert_isFunction('mean')},function(){return testutil.assert_functionHasNumOfParameter('mean',1)},function(){return testutil.assert_functionReturns('mean([0])',0)},function(){return testutil.assert_functionReturns('mean([1, 2])',1.5)},function(){return testutil.assert_functionReturns('mean([1, 4, 10, 85])',25)},function(){return testutil.assert_functionReturns('mean([-2, -4, 17, 34])',11.25)}]})})(jshero.testutil);
jshero.koans.add({id:"trim",title:"String: trim()",lesson:"Die Methode <code>trim</code> entfernt Leerzeichen an beiden Enden eines Strings.\nDer an den Enden um Leerzeichen bereinigte String wird zur\xFCckgegeben.\nDer urspr\xFCgliche String bleibt unver\xE4ndert.\n\n<pre><code>var eingabe = \" Rosa Parks \";\nvar name = eingabe.trim();</code></pre>\n\n<code>name</code> enth\xE4lt den String <code>\"Rosa Parks\"</code>. \nWie angedeutet werden h\xE4ufig Benutzereingaben vor der Verarbeitung getrimmt.",task:"Schreibe eine Funktion <code>firstChar</code>, die bei \xDCbergabe eines Strings das erste Zeichen,\ndas kein Leerzeichen ist, zur\xFCckgibt. <code>firstChar(\" Rosa\")</code> sollte <code>\"R\"</code> zur\xFCckgeben.",hint:"<pre><code>var firstChar = function(text) {\n// Trimme zuerst text.\n// Verwende dann die\n// charAt-Methode.\n};",solution:"<pre><code>var firstChar = function(text) {\n  var textGetrimmt = text.trim();\n  return textGetrimmt.charAt(0);\n};",beforeTests:function(){if(typeof firstChar!=="undefined"){firstChar=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("firstChar")},function(){return jshero.testutil.assert_functionHasNumOfParameter("firstChar",1)},function(){return jshero.testutil.assert_functionReturns("firstChar(\"Rosa\")","R")},function(){return jshero.testutil.assert_functionReturns("firstChar(\" Louise\")","L")},function(){return jshero.testutil.assert_functionReturns("firstChar(\"  Parks\")","P")}]});
(function(dateUtil){jshero.koans.add({id:'undefined',title:'undefined',lesson:'Bisher hatten wir Variablen bei der Deklaration immer auch initialisiert.\n\n<pre><code>// Deklaration und Initialisierung\nvar x = 1;</code></pre>\n\nMan kann eine Varialbe aber auch deklarieren und ihr sp\xE4ter einen Wert zuweisen.\n\n<pre><code>var x; // Deklaration\nx = 1; // Initialisierung</code></pre>\n\nVariablen, die nicht initialisiert wurden, haben den Wert <code>undefined</code> (engl.: nicht definiert).\nIn der Praxis kommt das bei Funktionsaufrufen am h\xE4ufigsten vor. Ruft man eine Funktion, die einen Parameter erwartet, ohne Argument auf,\ndann erh\xE4lt der Funktionsparameter den Wert <code>undefined</code>.\n\n<pre><code>var echo = function(x) {\n  return x;\n};\n// Aufruf ohne Argument\nvar y = echo();</code></pre>\n\n<code>echo</code> wird ohne Argument aufgerufen. Dem Parameter <code>x</code> wird so kein Wert zugewiesen,\ner erh\xE4lt den Wert <code>undefined</code>.\nDa <code>echo</code> den Parameter <code>x</code> einfach nur zur\xFCckgibt,\nerh\xE4lt auch <code>y</code> den Wert <code>undefined</code>. <br><br>\nEine Funktion, die einen Parameter erwartet, kann immer auch ohne Argument aufgerufen werden.\nMan sollte sich beim Schreiben von Funktionen also immer \xFCberlegen,\nwas in diesem Fall passieren soll. Gute Praxis ist es, in einem solchen Fall dem Parameter einen Default-Wert (engl.: Vorgabe) zuzuweisen.\nDas hatten wir schon bei der String-Methode <code>charAt(index)</code> kennen gelernt.\nNormalerweise gibt diese Methode den Buchstaben an der Stelle <code>index</code>\nzur\xFCck. Rufen wir <code>charAt</code> ohne Argument auf, erh\xE4lt <code>index</code> den Default <code>0</code>.\nEs wird der Buchstabe an der Stelle <code>0</code> zur\xFCckgegeben.\nUm eine Varaible auf <code>undefined</code> zu \xFCberpr\xFCfen, verwendet man wie \xFCblich die strikte Gleichkeit.\nDie Methode <code>charAt</code> k\xF6nnte also folgenden Code-Ausschnitt enthalten:\n\n<pre><code>if (index === undefined) {\n  index = 0;\n}</code></pre>',task:'Schreibe eine Funktion <code>hallo</code>, die einen String als Parameter entgegennimmt und <code>"Hallo &lt;Parameter&gt;!"</code> zur\xFCckgibt.\n<code>hallo("Akg\xFCn")</code> sollte <code>"Hallo Akg\xFCn!"</code> zur\xFCckgeben.\nWird <code>hallo</code> ohne Argument aufgerufen, so soll <code>"Hallo Welt!"</code> zur\xFCckgegeben werden.',beforeTests:function(){if(typeof hallo!=='undefined'){hallo=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('hallo')},function(){return jshero.testutil.assert_functionHasNumOfParameter('hallo',1)},function(){return jshero.testutil.assert_functionReturns('hallo("Melek")','Hallo Melek!')},function(){return jshero.testutil.assert_functionReturns('hallo("Stefan")','Hallo Stefan!')},function(){return jshero.testutil.assert_functionReturns('hallo()','Hallo Welt!')}]})})(jshero.date);
jshero.koans.add({id:'utc',title:'Weltzeit',lesson:'Wenn man mit Datum und Uhrzeit arbeitet, muss man zwischen\n<a href="https://de.wikipedia.org/wiki/Koordinierte_Weltzeit">koordinierter Weltzeit</a> (UTC, engl. Coordinated Universal Time) und\n<a href="https://de.wikipedia.org/wiki/Zonenzeit">Zonenzeit</a> unterscheiden.\nDie koordinierte Weltzeit stellt weltweit eine einheitliche Zeitangabe her.\nDie Zonenzeit ist die in einer Zeitzone geltende Zeit.\nVon der koordinierten Weltzeit werden die verschiedenen Zonenzeiten abgeleitet.\nSo ergibt sich die <a href="https://de.wikipedia.org/wiki/Mitteleurop%C3%A4ische_Zeit">Mitteleurop\xE4ische Zeit (MEZ)</a>\naus der koordinierten Weltzeit durch Addition von einer Stunde (kurz UTC+1). Die Mitteleurop\xE4ische Sommerzeit (MESZ) entspricht\nUTC+2. UTC selbst ist die Zonenzeit der Westeurop\xE4ischen Zeit (WEZ).<br><br>\nWas wir bisher \xFCber das Date-Objekt gelernt haben, bezog sich im Wesentlichen auf die Zonenzeit. So liefert der Ausdruck\n<code>new Date(2018, 4, 5)</code> ein Date-Objekt, das dem Zeitpunkt 5.5.2018, 0:00 Uhr in lokaler Zeit entspricht.\nMacht man diesen Aufruf in Deutschland, erh\xE4lt man den Zeitpunkt 5.5.2018, 0:00 UTC+2 (Sommerzeit!). In Japan liefert derselbe Aufruf\nden Zeitpunkt 5.5.2018, 0:00 UTC+9. Zwischen beiden Zeitpunkten liegt eine Differenz von 7 Stunden.\nM\xF6chte man weltweit einen einheitlichen Zeitpunkt erzeugen, so muss man die Weltzeit verwenden:\n<pre><code>var millis = Date.UTC(2018, 4, 5);\nvar datum = new Date(millis);</code></pre>\nMit <code>Date.UTC</code> erh\xE4lt man zun\xE4chst die vergangenen Millisekunden seit dem 1.1.1970, 0:00 UTC.\nMit dieser Zahl und <code>new Date()</code> erzeugt man anschlie\xDFend das gew\xFCnschte Date-Objekt\n(siehe <a href="main.html?koan=date">Datum und Uhrzeit</a>). Die Variable <code>datum</code> repr\xE4sentiert den\n5.5.2018, 0:00 UTC.',task:'Schreibe eine Funktion <code>nikolausUTC</code>, die eine Jahreangabe als Zahl entgegennimmt und die ein Date-Objekt mit dem 6. Dezember\ndes \xFCbergebenen Jahres, 0:00 UTC, zur\xFCckgibt. <code>nikolaus(2017)</code> sollte ein Date-Objekt mit dem Zeitpunkt 6.12.2017, 0:00 UTC zur\xFCckgeben.',beforeTests:function(){if(typeof nikolausUTC!=='undefined'){nikolausUTC=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('nikolausUTC')},function(){return jshero.testutil.assert_functionHasNumOfParameter('nikolausUTC',1)},function(){return jshero.testutil.assert_functionReturnsType('nikolausUTC(2017)','Date')},function(){return jshero.testutil.assert_functionReturns('nikolausUTC(2017)',new Date(Date.UTC(2017,11,6)),{'utc':true})},function(){return jshero.testutil.assert_functionReturnsType('nikolausUTC(1960)','Date')},function(){return jshero.testutil.assert_functionReturns('nikolausUTC(1960)',new Date(Date.UTC(1960,11,6)),{'utc':true})}]});
(function(testutil){jshero.koans.add({id:"var",title:"Variablen",lesson:"<a href=\"https://de.wikipedia.org/wiki/JavaScript\">JavaScript</a>-Programme bestehen\naus einer Reihe von Anweisungen. Jede Anweisung f\xFChrt eine elementare Operation durch.\nDurch das Ausf\xFChren vieler Anweisungen kann man schlie\xDFlich komplexe Aufgaben l\xF6sen.\nJede Anweisung schreibt man in eine Zeile und schlie\xDFt sie mit einem Semikolon ab.<br><br>\nEine elementare Anweisung ist die Deklaration und Initialisierung einer Variablen.\nIn der Programmierung ist eine Variable ein Beh\xE4lter f\xFCr einen Wert.\nMit der Anweisung\n\n<pre><code>var stadt = \"Prag\";</code></pre>\n\ndeklariert man eine Variable mit dem Namen <code>stadt</code> und initialisiert sie mit dem Wert <code>\"Prag\"</code>.\nMit dem Schl\xFCsselwort <code>var</code> wird die Variable deklariert.\nMit dem Gleichheitszeichen, dem Zuweisungsoperator, weist man der Variablen einen Wert zu.<br><br>\nBeachte: JavaScript unterscheidet zwischen Gro\xDF- und Kleinschreibung. <code>stadt</code> und <code>Stadt</code> sind\nzwei verschiedene Variablen. Man sagt auch: JavaScript ist case sensitive.",task:"Deklariere eine Variable <code>vorname</code> und initialisiere sie mit dem Wert <code>\"Franz\"</code>.",hint:"<pre><code>var vorname = ...</code></pre>",solution:"<pre><code>var vorname = \"Franz\";</code></pre>",beforeTests:function(){if(typeof vorname!=="undefined"){vorname=undefined}},tests:[function(){return testutil.assert_variableDefined("vorname")},function(){return testutil.assert_variableHasValue("vorname","Franz")}]})})(jshero.testutil);
(function(testutil){jshero.koans.add({id:"var2",title:"Mehrere Variablen",lesson:"M\xF6chte man mehrere Variablen deklarieren und initialisieren, so kann man das in zwei Programmzeilen tun:\n\n<pre><code>var stadt = \"Prag\";\nvar land = \"Tschechien\";</code></pre>\n\nIn jeder Zeile steht eine Anweisung. Jede Anweisung sollte mit einem Semikolon abgeschlossen werden.",task:"Deklariere eine Variable <code>blume</code> und weise ihr den Wert <code>\"Rose\"</code> zu.\nDeklariere eine zweite Variable <code>tier</code> und weise ihr den Wert <code>\"K\xE4fer\"</code> zu.",beforeTests:function(){if(typeof blume!=="undefined"){blume=undefined}if(typeof tier!=="undefined"){tier=undefined}},tests:[function(){return testutil.assert_variableDefined("blume")},function(){return testutil.assert_variableHasValue("blume","Rose")},function(){return testutil.assert_variableDefined("tier")},function(){return testutil.assert_variableHasValue("tier","K\xE4fer")}]})})(jshero.testutil);
jshero.koans.add({id:'while',title:'while-Schleife',lesson:'Die <code>while</code>-Schleife besitzt nur eine Schleifen-Bedingung.\nDer Schleifen-Code wird ausgef\xFChrt, solange die Bedingung <code>true</code> ergibt.\nErgibt die Bedingung <code>false</code>, wird die Schleife beendet und die Codeausf\xFChrung\nwird nach der Schleife fortgesetzt.\n\n<pre><code>var dreiX = "";\nwhile (dreiX.length < 3) {\n  dreiX = dreiX + "x";\n}</code></pre>\n\nSolange <code>dreiX</code> weniger als 3 Zeichen besitzt, wird es um <code>"x"</code> erg\xE4nzt.\nHat <code>dreiX</code> die L\xE4nge 3, wird die Schleife beendet.\n<code>dreiX</code> hat dann den Wert <code>"xxx"</code>.',task:'Schreibe eine Funktion <code>abstand</code>, die eine nat\xFCrliche Zahl n als Parameter\nentgegennimmt und die einen String bestehend aus n Leerzeichen zur\xFCckgibt.\n<code>abstand(1)</code> sollte <code>" "</code> ergeben.',beforeTests:function(){if(typeof abstand!=='undefined'){abstand=undefined}},tests:[function(){return jshero.testutil.assert_isFunction('abstand')},function(){return jshero.testutil.assert_functionHasNumOfParameter('abstand',1)},function(){return jshero.testutil.assert_functionReturns('abstand(0)','')},function(){return jshero.testutil.assert_functionReturns('abstand(2)','  ')},function(){return jshero.testutil.assert_functionReturns('abstand(5)','     ')}]});
jshero.koans.add({id:"xor",title:"XOR",lesson:"Die logischen Operatoren kennen, \xE4hnlich der Punkt- vor Strich-Rechnung, eine Reihenfolge:\nNICHT zuerst, anschlie\xDFend UND, zuletzt ODER. M\xF6chte man diese Reihenfolge \xE4ndern, verwendet man Klammern:\n\n<pre><code>var x1 = true || false && false;\nvar x2 = (true || false) && false;\nvar x3 = !false && false;\nvar x4 = !(false && false);</code></pre>\n\nIn der ersten Zeile wird zuerst UND ausgewertet. <code>x1</code> wird <code>true</code>.\nIn der zweiten Zeile wird zuerst ODER ausgewertet. <code>x2</code> wird <code>false</code>.\nIn der dritten Zeile wird zuerst NICHT ausgewertet. <code>x3</code> wird <code>false</code>.\nUnd in der vierten Zeile wird zuerst UND ausgewertet. <code>x4</code> wird <code>true</code>.<br><br>\nIn der folgenden Aufgabe sollst du ein weiteres wichtiges Gatter, das XOR-Gatter (engl.: eXclusive OR - exklusives oder), programmieren.",task:"Schreibe eine Funktion <code>xor</code>, die zwei boolesche Werte als Parameter entgegennimmt.\nDie R\xFCckgabe der Funktion soll <code>true</code> sein, wenn beide Paramter verschieden sind.\nIn den anderen F\xE4llen soll die R\xFCckgabe <code>false</code> sein. <code>xor(true, false)</code> und\n<code>xor(false, true)</code> sollen <code>true</code> liefern, <code>xor(true, true)</code> und\n<code>xor(false, false)</code> sollen <code>false</code> zur\xFCckgeben.",beforeTests:function(){if(typeof xor!=="undefined"){xor=undefined}},tests:[function(){return jshero.testutil.assert_isFunction("xor")},function(){return jshero.testutil.assert_functionHasNumOfParameter("xor",2)},function(){return jshero.testutil.assert_functionReturns("xor(true, true)",false)},function(){return jshero.testutil.assert_functionReturns("xor(true, false)",true)},function(){return jshero.testutil.assert_functionReturns("xor(false, true)",true)},function(){return jshero.testutil.assert_functionReturns("xor(false, false)",false)}]});
jshero.koans.initReorder(['var','var2','function','function2','functioncall','parameter','parameter2a','string','log1','log2','log','stringlength','stringupper','stringcharat','trim','stringindexof','stringindexof2','stringsubstr','replace','number','fahrenheit','modulo','mean','math','minmax','pi','round','random','parseint','numbertostring','bool','nor','xor','equals','equals2','even','notequals','greaterthan','if','if2','else','elseif','array','array2','array3','arraylength','arraysort','arraypush','arrayindexof','concat','slice','join','comment','for1','for2','while','dowhile','ggt','break','bubblesort','arguments','undefined','nan','stringsplit','date','date2','date3','utc','gettime','subfunction','regex1','regex2','regex3','regex4','regex5','regex5a','regex6','regex7','regex8','further']);

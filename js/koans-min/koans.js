jshero.koans.add({id:'arguments',title:'Das arguments-Objekt',lesson:'Das <code>arguments</code>-Objekt ist eine in jeder Funktion verf\xFCgbare Variable. '+'Es ist ein Array \xE4hnliches Objekt, das die \xFCbergebenen Argumente einer Funktion der Reihe nach enth\xE4lt. '+'<pre><code>'+'var add = function() {<br>'+'  var arg0 = arguments[0];<br>'+'  var arg1 = arguments[1];<br>'+'  return arg0 + arg1;<br>'+'};<br><br>'+'var sum = add(1, 2);'+'</code></pre>'+'Hier wird <code>add</code> mit den Argumenten <code>1</code> und <code>2</code> aufgerufen. <code>arguments[0]</code> enth\xE4lt also den Wert <code>1</code>, '+'<code>arguments[1]</code> den Wert <code>2</code>. '+'Mit dem <code>arguments</code>-Objekt kann man ohne Parameter auf die \xFCbergebenen Argumente zugreifen. '+'Das ist z.B. dann praktisch, wenn man eine Funktion schreiben m\xF6chte, die eine beliebige Anzahl von Argumenten verarbeiten soll.'+'<pre><code>'+'var add = function() {<br>'+'  var sum = 0;<br>'+'  for (var i = 0; i < arguments.length; i++) {<br>'+'    sum = sum + arguments[i];<br>'+'  }<br>'+'  return sum;<br>'+'};<br><br>'+'var s1 = add(2, 4);<br>'+'var s2 = add(2, 3, 5, 7);<br>'+'</code></pre>'+'Hier iterieren wir \xFCber alle \xFCbergebenen Argumente und summieren sie auf. <code>arguments.length</code> liefert dabei die Anzahl der \xFCbergebenen Argumente. '+'Nun k\xF6nnen wir <code>add</code> mit einer beliebigen Anzahl von Argumenten aufrufen.',task:'Schreibe eine Funktion <code>maximum</code>, die beliebig viele Zahlen entgegennimmt und das Maximum dieser Zahlen liefert. '+'<code>maximum(12, 68, 3, 52)</code> sollte <code>68</code> ergeben.',beforeTests:function(){if(typeof maximum!=='undefined'){maximum=undefined}},tests:[function(){var ok=typeof maximum==='function';var msg;if(ok){msg='<code>maximum</code> ist eine Funktion.'}else{msg='<code>maximum</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=maximum(1);ok=result===1;if(ok){msg='<code>maximum(1)</code> gibt <code>1</code> zur\xFCck.'}else{msg='<code>maximum(1)</code> gibt nicht <code>1</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>maximum(1)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=maximum(1,7,3,9,2);ok=result===9;if(ok){msg='<code>maximum(1, 7, 3, 9, 2)</code> gibt <code>9</code> zur\xFCck.'}else{msg='<code>maximum(1, 7, 3, 9, 2)</code> gibt nicht <code>9</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>maximum(1, 7, 3, 9, 2)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'array',title:'Arrays anlegen',lesson:'Arrays sind Objekte zur Speicherung vieler, meist \xE4hnlicher Werte. Diese sogenannten Elemente werden '+'in einem Array der Reihe nach abgelegt. Arrays erzeugt man am besten mit eckigen Klammern.'+'<pre><code>var sprachen = ["C", "C++", "Java", "JavaScript"];<br>'+'var primzahlen = [2, 3, 5, 7, 11];<br>'+'var leeresArray = [];<br>'+'var a = "Douglas";<br>'+'var b = 12;<br>'+'var c = true;<br>'+'var allesMoegliche = [a, b, c];</code></pre>'+'Die Elemente eines Arrays k\xF6nnen, wie das letzte Beispiel zeigt, alle einen anderen Datentyp besitzen.',task:'Schreibe eine Funktion <code>toArray</code>, die 2 Paramter entgegennimmt und diese als Array zur\xFCckgibt. '+'<code>toArray(5, 9)</code> sollte das Array <code>[5, 9]</code> ergeben.',beforeTests:function(){if(typeof toArray!=='undefined'){toArray=undefined}},tests:[function(){var ok=typeof toArray==='function';var msg;if(ok){msg='<code>toArray</code> ist eine Funktion.'}else{msg='<code>toArray</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=toArray.length===2;var msg;if(ok){msg='<code>toArray</code> hat 2 Parameter.'}else{msg='<code>toArray</code> hat nicht 2, sondern '+toArray.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=toArray(1,2);ok=Array.isArray(result);if(ok){msg='<code>toArray(1, 2)</code> gibt ein Array zur\xFCck.'}else{msg='<code>toArray(1, 2)</code> gibt kein Array zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>toArray(1, 2)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=toArray(1,2);ok=result.length===2&&result[0]===1&&result[1]===2;if(ok){msg='<code>toArray(1, 2)</code> gibt <code>[1, 2]</code> zur\xFCck.'}else{msg='<code>toArray(1, 2)</code> gibt nicht <code>[1, 2]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>toArray(1, 2)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=toArray('H\xE4nsel','Gretel');ok=Array.isArray(result)&&result.length===2&&result[0]==='H\xE4nsel'&&result[1]==='Gretel';if(ok){msg='<code>toArray("H\xE4nsel", "Gretel")</code> gibt <code>["H\xE4nsel", "Gretel"]</code> zur\xFCck.'}else{msg='<code>toArray("H\xE4nsel", "Gretel")</code> gibt nicht <code>["H\xE4nsel", "Gretel"]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von toArray("H\xE4nsel", "Gretel")</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'array2',title:'Array-Elemente lesen',lesson:'Die Elemente eines Arrays werden mit einem Index beginnend mit 0 ausgelesen. '+'<pre><code>var sprachen = ["C", "C++", "Java", "JavaScript"];<br>'+'var c = sprachen[0];<br>'+'var cPlusPlus = sprachen[1];<br>'+'var java = sprachen[2];<br>'+'var javaScript = sprachen[3];',task:'Schreibe eine Funktion <code>getFirstElement</code>, die ein Array entgegennimmt und die das erste Element des Arrays zur\xFCckgibt. '+'<code>getFirstElement([1, 2])</code> sollte <code>1</code> zur\xFCckgeben.',beforeTests:function(){if(typeof getFirstElement!=='undefined'){getFirstElement=undefined}},tests:[function(){var ok=typeof getFirstElement==='function';var msg;if(ok){msg='<code>getFirstElement</code> ist eine Funktion.'}else{msg='<code>getFirstElement</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=getFirstElement.length===1;var msg;if(ok){msg='<code>getFirstElement</code> hat 1 Parameter.'}else{msg='<code>getFirstElement</code> hat nicht 1, sondern '+getFirstElement.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=getFirstElement([1,2]);ok=result===1;if(ok){msg='<code>getFirstElement([1, 2])</code> gibt <code>1</code> zur\xFCck.'}else{msg='<code>getFirstElement([1, 2])</code> gibt nicht <code>1</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>getFirstElement([1, 2])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=getFirstElement(['H\xE4nsel','Gretel']);ok=result==='H\xE4nsel';if(ok){msg='<code>getFirstElement(["H\xE4nsel", "Gretel"])</code> gibt <code>"H\xE4nsel"</code> zur\xFCck.'}else{msg='<code>getFirstElement(["H\xE4nsel", "Gretel"])</code> gibt nicht <code>"H\xE4nsel"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>getFirstElement(["H\xE4nsel", "Gretel"])</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'array3',title:'Array-Elemente schreiben',lesson:'Ebenso wie man Array-Elemente \xFCber einen Index auslesen kann, kann man sie \xFCber diesen Index setzen. '+'Dabei spielt es keine Rolle, ob das Array vorher gef\xFCllt oder leer war.'+'<pre><code>var sprachen = [];<br>'+'sprachen[0] = "C";<br>'+'sprachen[1] = "C++";<br>'+'sprachen[2] = "Java";<br>'+'sprachen[3] = "JavaScript";</code></pre>'+'Hier wird ein leeres Array nacheinander mit den aufgef\xFChrten Werten gef\xFCllt.',task:'Schreibe eine Funktion <code>setFirstElement</code>, die ein Array und eine beliebige Variable entgegennimmt. '+'Die Variable soll als erstes Element in das Array geschrieben werden. Das Array soll dann zur\xFCckgegeben werden. '+'<code>setFirstElement([1, 2], 3)</code> sollte <code>[3, 2]</code> zur\xFCckgeben.',beforeTests:function(){if(typeof setFirstElement!=='undefined'){setFirstElement=undefined}},tests:[function(){var ok=typeof setFirstElement==='function';var msg;if(ok){msg='<code>setFirstElement</code> ist eine Funktion.'}else{msg='<code>setFirstElement</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=setFirstElement.length===2;var msg;if(ok){msg='<code>setFirstElement</code> hat 2 Parameter.'}else{msg='<code>setFirstElement</code> hat nicht 2, sondern '+setFirstElement.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=setFirstElement([1,2],3);ok=Array.isArray(result)&&result.length===2&&result[0]===3&&result[1]===2;if(ok){msg='<code>setFirstElement([1, 2], 3)</code> gibt <code>[3, 2]</code> zur\xFCck.'}else{msg='<code>setFirstElement([1, 2], 3)</code> gibt nicht <code>[3, 2]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>setFirstElement([1, 2], 3)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=setFirstElement([],1);ok=Array.isArray(result)&&result.length===1&&result[0]===1;if(ok){msg='<code>setFirstElement([], 1)</code> gibt <code>[1]</code> zur\xFCck.'}else{msg='<code>setFirstElement([], 1)</code> gibt nicht <code>[1]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){e=exc;ok=false;msg='Fehler beim Aufruf von <code>setFirstElement([], 1)</code>.'}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'arraylength',title:'Array: length',lesson:'Die Eigenschaft <code>length</code> hatten wird schon bei Strings kennengelernt. Dort gab sie die Anzahl '+'der Zeichen eines Strings zur\xFCck. Bei Arrays gibt sie die Anzahl der Elemente zur\xFCck. '+'<pre><code>var sprachen = [];<br>'+'var l0 = sprachen.length;<br>'+'sprachen[0] = "C";<br>'+'var l1 = sprachen.length;<br>'+'sprachen[1] = "C++";<br>'+'var l2 = sprachen.length;</code></pre>'+'Das leere Array zu Anfang enth\xE4llt keine Elemente. <code>l0</code> ist also <code>0</code>. '+'Nun f\xFCllen wir das Array nach und nach. <code>l1</code> und <code>l2</code> haben dann die Werte <code>1</code> und <code>2</code>. '+'Beachte: Die L\xE4nge eines Arrays ist immer um 1 gr\xF6\xDFer als der h\xF6chste Index des Arrays.',task:'Schreibe eine Funktion <code>getLastElement</code>, die ein Array entgegennimmt und die das letzte Element des Arrays zur\xFCckgibt. '+'<code>getLastElement([1, 2])</code> sollte <code>2</code> zur\xFCckgeben.',beforeTests:function(){if(typeof setFirstElement!=='undefined'){setFirstElement=undefined}},tests:[function(){var ok=typeof getLastElement==='function';var msg;if(ok){msg='<code>getLastElement</code> ist eine Funktion.'}else{msg='<code>getLastElement</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=getLastElement.length===1;var msg;if(ok){msg='<code>getLastElement</code> hat 1 Parameter.'}else{msg='<code>getLastElement</code> hat nicht 1, sondern '+getLastElement.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=getLastElement([1,2]);ok=result===2;if(ok){msg='<code>getLastElement([1, 2])</code> gibt <code>2</code> zur\xFCck.'}else{msg='<code>getLastElement([1, 2])</code> gibt nicht <code>2</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>getLastElement([1, 2])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=getLastElement(['a','b','c']);ok=result==='c';if(ok){msg='<code>getLastElement(["a", "b", "c"])</code> gibt <code>"c"</code> zur\xFCck.'}else{msg='<code>getLastElement(["a", "b", "c"])</code> gibt nicht <code>"c"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>getLastElement(["a", "b", "c"])</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
(function(array){jshero.koans.add({id:'arraypush',title:'Array: shift() und push()',lesson:'Arrays besitzen eine Reihe von Methoden. Zwei dieser Methoden sind <code>shift</code> und <code>push</code>. '+'Zur Erinnerung: Methoden sind Funktionen, die auf einem Objekt, hier einem Array, ausgef\xFChrt werden. Methoden werden mit einem Punkt '+'an das Objekt angeh\xE4ngt. Wie bei Funktionen \xFCblich folgt dem Methodennamen die runden Klammern, ggf. gef\xFCllt mit Parametern. '+'<code>shift</code> hat keine Parameter und verschiebt die Elemente eines Arrays nach links. '+'Das 1te Element wird zum 0ten, das 2te zum 1ten, das 3te zum 2ten, usw. '+'Das 0te Element wird aus dem Array entfernt und zur\xFCckgegeben. Nach dem <code>shift</code> hat das Array ein Element weniger.'+'<pre><code>var sprachen = ["C", "Java", "JavaScript"];<br>'+'var naechsteSprache = sprachen.shift();</code></pre>'+'Das Array <code>sprachen</code> wird mit 3 Programmiersprachen angelegt. Nach dem <code>shift</code> enth\xE4lt <code>sprachen</code> '+'nur noch 2 Elemente, n\xE4mlich <code>["Java", "JavaScript"]</code>. Der Wert <code>"C"</code> ist in der Variablen '+'<code>naechsteSprache</code> gelandet.<br>'+'Mit der h\xE4ufig verwendeten Methode <code>push</code> f\xFCgt man dem Array ein neues Element hinzu. '+'Das neue Element wird als Parameter \xFCbergeben und an das Ende des Arrays geh\xE4ngt.'+'<pre><code>var sprachen = [];<br>'+'sprachen.push("C");<br>'+'sprachen.push("Java");<br>'+'sprachen.push("JavaScript");</code></pre>'+'Hier wird ein leeres Array nacheinander mit den aufgef\xFChrten Werten gef\xFCllt. Am Ende erhalten wir das Array '+'<code>["C", "Java", "JavaScript"]</code>. Wir hatten gesehen, dass man ein Array auch per Index f\xFCllen kann. '+'<code>sprachen[sprachen.length] = "PHP"</code> ist dasselbe wie <code>sprachen.push("PHP")</code>. Doch schon '+'an der L\xE4nge des Codes sieht man, dass die Variante mit <code>push</code> eleganter ist.',task:'Schreibe eine Funktion <code>rotiere</code>, die die Elemente eines Arrays rotiert. Alle Elemente des Arrays sollen um eine '+'Position nach links verschoben werden. Das 0te Element soll ans Ende des Arrays gestellt werden. Das rotierte Array soll zur\xFCckgegeben werden. '+'<code>rotiere(["a", "b", "c"])</code> sollte <code>["b", "c", "a"]</code> ergeben.',beforeTests:function(){if(typeof rotiere!=='undefined'){rotiere=undefined}},tests:[function(){var ok=typeof rotiere==='function';var msg;if(ok){msg='<code>rotiere</code> ist eine Funktion.'}else{msg='<code>rotiere</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=rotiere.length===1;var msg;if(ok){msg='<code>rotiere</code> hat 1 Parameter.'}else{msg='<code>rotiere</code> hat nicht 1, sondern '+rotiere.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=rotiere([1,2]);ok=array.isEqual(result,[2,1]);if(ok){msg='<code>rotiere([1, 2])</code> gibt <code>[2, 1]</code> zur\xFCck.'}else{msg='<code>rotiere([1, 2])</code> gibt nicht <code>[2, 1]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>rotiere([1, 2])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=rotiere(['a','b','c']);ok=array.isEqual(result,['b','c','a']);if(ok){msg='<code>rotiere(["a", "b", "c"])</code> gibt <code>["b", "c", "a"]</code> zur\xFCck.'}else{msg='<code>rotiere(["a", "b", "c"])</code> gibt nicht <code>["b", "c", "a"]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>rotiere(["a", "b", "c"])</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]})})(jshero.array);
jshero.koans.add({id:'arraysort',title:'Arrays sortieren',lesson:'Wir k\xF6nnen jetzt Arrays mit vorgegebener L\xE4nge sortieren.',task:'Schreibe eine Funktion <code>sortiere</code>, die ein mit 3 Zahlen gef\xFClltes Array entgegennimmt und die diese 3 Zahlen aufsteigend sortiert als Array  zur\xFCckgibt. '+'<code>sortiere([2,&nbsp;3,&nbsp;1])</code> sollte <code>[1,&nbsp;2,&nbsp;3]</code> ergeben.',beforeTests:function(){if(typeof sortiere!=='undefined'){sortiere=undefined}},tests:[function(){var ok=typeof sortiere==='function';var msg;if(ok){msg='<code>sortiere</code> ist eine Funktion.'}else{msg='<code>sortiere</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=sortiere.length===1;var msg;if(ok){msg='<code>sortiere</code> hat 1 Parameter.'}else{msg='<code>sortiere</code> hat nicht 1, sondern '+sortiere.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=sortiere([3,2,1]);ok=Array.isArray(result)&&result.length===3&&result[0]===1&&result[1]===2&&result[2]===3;if(ok){msg='<code>sortiere([3, 2, 1])</code> gibt <code>[1, 2, 3]</code> zur\xFCck.'}else{msg='<code>sortiere([3, 2, 1])</code> gibt nicht <code>[1, 2, 3]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>sortiere([3, 2, 1])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=sortiere([2,3,1]);ok=Array.isArray(result)&&result.length===3&&result[0]===1&&result[1]===2&&result[2]===3;if(ok){msg='<code>sortiere([2, 3, 1])</code> gibt <code>[1, 2, 3]</code> zur\xFCck.'}else{msg='<code>sortiere([2, 3, 1])</code> gibt nicht <code>[1, 2, 3]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>sortiere([2, 3, 1])</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"bool",title:"Wahrheitswerte",lesson:"Der dritte wichtige Datentyp neben Strings und Zahlen sind Wahrheitswerte. Sie werden auch boolesche Werte genannt. Boolesche Werte kennen nur zwei Zust\xE4nde: "+"<code>true</code> und <code>false</code>. Mit booleschen Werten kann man \xE4hnlich \"rechnen\" wie mit Zahlen. JavaScript kennt drei boolesche Operatoren: "+"<code>&&</code> (und), <code>||</code> (oder) und <code>!</code> (nicht). Das Ergebnis dieser Operationen ist wieder ein boolescher Wert. "+"<code>&&</code> verkn\xFCpft zwei boolesche Werte. Sind beide Werte <code>true</code>, ist das Ergebnis auch <code>true</code>. In allen anderen F\xE4llen "+"ist es <code>false</code>. Bei <code>||</code> ist das Ergebnis <code>false</code>, wenn beide Eingangswerte auch <code>false</code> sind. In  allen "+"anderen F\xE4llen ist das Ergebnis <code>true</code>. <code>!</code> wird nur auf einen booleschen Wert angewendet und invertiert diesen Wert: aus "+"<code>true</code> wird <code>false</code> und aus <code>false</code> wird <code>true</code>."+"<pre><code>var x1 = true && false;<br>var x2 = !x1;<br>var x3 = x1 || x2;</code></pre>"+"<code>x1</code> ist <code>false</code>,  <code>x2</code> ist <code>true</code> und <code>x3</code> ist ebenfalls <code>true</code>.",task:"Schreibe eine Funktion <code>nand</code>, die zwei boolesche Werte als Parameter entgegennimmt. Die R\xFCckgabe der Funktion soll <code>false</code> sein, "+"wenn beide Paramter <code>true</code> sind. In den anderen F\xE4llen soll die R\xFCckgabe <code>true</code> sein. <code>nand(true, true)</code> "+"soll <code>false</code> liefern, <code>nand(true, false)</code>, <code>nand(false, true)</code> und <code>nand(false, false)</code> sollen <code>true</code> zur\xFCckgeben.",beforeTests:function(){if(typeof nand!=="undefined"){nand=undefined}},tests:[function(){var ok=typeof nand==="function";var msg;if(ok){msg="<code>nand</code> ist eine Funktion."}else{msg="<code>nand</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok=nand.length===2;var msg;if(ok){msg="<code>nand</code> hat zwei Parameter."}else{msg="<code>nand</code> hat nicht 2, sondern "+nand.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=nand(true,true);ok=result===false;if(ok){msg="<code>nand(true, true)</code> ergibt <code>false</code>."}else{msg="<code>nand(true, true)</code> ergibt nicht <code>false</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>nand(true, true)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=nand(true,false);ok=result===true;if(ok){msg="<code>nand(true, false)</code> ergibt <code>true</code>."}else{msg="<code>nand(true, false)</code> ergibt nicht <code>true</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>nand(true, false)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=nand(false,true);ok=result===true;if(ok){msg="<code>nand(false, true)</code> ergibt <code>true</code>."}else{msg="<code>nand(false, true)</code> ergibt nicht <code>true</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>nand(false, true)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=nand(false,false);ok=result===true;if(ok){msg="<code>nand(false, false)</code> ergibt <code>true</code>."}else{msg="<code>nand(false, false)</code> ergibt nicht <code>true</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>nand(false, false)</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'break',title:'break und continue',lesson:'Mit <code>break</code> wird eine Schleife beendet. Das Programm wird nach der Schleife fortgesetzt. '+'<pre><code>var satz = "So ist das.";<br>'+'var i;<br>'+'for (i = 0; i < satz.length; i++) {<br>'+'  if (satz.charAt(i) === " ") {<br>'+'    break;<br>'+'  }<br>'+'}<br>'+'var laengeErstesWort = i;</code></pre>'+'Ist das Zeichen mit dem Index <code>i</code> in <code>satz</code> das Leerzeichen, ist die <code>if</code>-Bedingung erf\xFCllt '+'und der <code>break</code>-Befehl wird ausgef\xFChrt. Die Schleife wird beendet und die Codeausf\xFChrung wird '+'nach der Schleife fortgesetzt. In unserem Beispiel ist das Zeichen mit dem Index <code>2</code> das Leerzeichen. Sobald die Schleifenvariable <code>i</code> '+'den Wert <code>2</code> erreicht hat, wird die Schleife beendet. <code>laengeErstesWort</code> bekommt dann den Wert <code>2</code> zugewiesen.<br><br>'+'Mit <code>continue</code> wird der aktuelle Schleifendurchlauf beendet. Die Programmausf\xFChrung springt zum Schleifenkopf.'+'<pre><code>var summe = 0;<br>'+'for (var i = 0; i < 10; i++) {<br>'+'  if (i % 2 === 0) {<br>'+'    continue;<br>'+'  }<br>'+'  summe = summe + i;<br>'+'}<br></code></pre>'+'Ist <code>i</code> eine ungerade Zahl, so gilt: i modulo 2 = 1. Die <code>if</code> - Bedingung ist nicht erf\xFCllt. '+'Die Codeausf\xFChrung wird nach dem <code>if</code> fortgesetzt und <code>i</code> wird zu <code>summe</code> hinzugez\xE4hlt. '+'Ist <code>i</code> eine gerade Zahl, so gilt: i modulo 2 = 0. Die <code>if</code> - Bedingung ist erf\xFCllt und <code>continue</code> wird ausgef\xFChrt. '+'Die Code-Ausf\xFChrung springt direkt zum Schleifenkopf. <code>i</code> wird nicht zu <code>summe</code> hinzugez\xE4hlt. '+'So werden alle ungeraden Zahlen kleiner 10 aufaddiert.<br>'+'<code>break</code> und <code>continue</code> kann man in allen Schleifen (for, while, do...while) verwenden.',task:'Schreibe eine Funktion <code>isPrime</code>. Sie soll pr\xFCfen, ob eine \xFCbergebene Zahl eine Primzahl ist oder nicht. Ist die '+'Zahl prim, so soll <code>true</code> zur\xFCckgegeben werden, im anderen Fall <code>false</code>. '+'Der Aufruf <code>isPrime(2)</code> soll <code>true</code> zur\xFCckgeben, <code>isPrime(4)</code> soll <code>false</code> ergeben. '+'Eine Primzahl ist eine nat\xFCrliche Zahl, die gr\xF6\xDFer als 1 und nur durch sich selbst und durch 1 teilbar ist.',beforeTests:function(){if(typeof isPrime!=='undefined'){isPrime=undefined}},tests:[function(){var ok=typeof isPrime==='function';var msg;if(ok){msg='<code>isPrime</code> ist eine Funktion.'}else{msg='<code>isPrime</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=isPrime.length===1;var msg;if(ok){msg='<code>isPrime</code> hat 1 Parameter.'}else{msg='<code>isPrime</code> hat nicht 1, sondern '+isPrime.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=isPrime(1);ok=result===false;if(ok){msg='<code>isPrime(1)</code> gibt <code>false</code> zur\xFCck.'}else{msg='<code>isPrime(1)</code> gibt nicht <code>false</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>isPrime(1)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=isPrime(2);ok=result===true;if(ok){msg='<code>isPrime(2)</code> gibt <code>true</code> zur\xFCck.'}else{msg='<code>isPrime(2)</code> gibt nicht <code>true</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>isPrime(2)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=isPrime(3);ok=result===true;if(ok){msg='<code>isPrime(3)</code> gibt <code>true</code> zur\xFCck.'}else{msg='<code>isPrime(3)</code> gibt nicht <code>true</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>isPrime(3)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=isPrime(4);ok=result===false;if(ok){msg='<code>isPrime(4)</code> gibt <code>false</code> zur\xFCck.'}else{msg='<code>isPrime(4)</code> gibt nicht <code>false</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>isPrime(4)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=isPrime(11);ok=result===true;if(ok){msg='<code>isPrime(11)</code> gibt <code>true</code> zur\xFCck.'}else{msg='<code>isPrime(11)</code> gibt nicht <code>true</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>isPrime(11)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
(function(ArrayUtil){jshero.koans.add({id:'bubblesort',title:'Bubblesort',lesson:'H\xE4ufig m\xF6chte man Daten der Gr\xF6\xDFe nach sortieren. Hierf\xFCr gibt es verschiedene Sortierverfahren. Ein bekanntes, '+'einfaches, aber auch langsames Verfahren ist <a href="https://de.wikipedia.org/wiki/Bubblesort" target="_blank">Bubblesort</a>. Liegen die zu sortierenden Daten in einem Array der L\xE4nge n vor '+'und sollen die Daten aufsteigend sortiert werden, so wird in einer sogenannten Bubble-Phase das Array vom 1 &apos;ten bis zum n-1 &apos;ten Element durchlaufen. '+'Dabei wird in jedem Schritt das aktuelle Element an der Stelle i mit dem nachfolgenden Element an der Stelle i+1 verglichen. Ist das Element an der Stelle i gr\xF6\xDFer als das '+'Element an der Stelle i+1, so vertauscht man beide Elemente. Hat man so eine Bubble-Phase durchlaufen, ist das gr\xF6\xDFte Element am Ende des Arrays angekommen. '+'Wiederholt man nun eine Bubble-Phase, so steht auch das zweitgr\xF6\xDFte Element an der richtigen Stelle. Hat man n-1 Bubble-Phasen durchlaufen, ist das komplette Array sortiert. '+'Um ein Array mit 4 Zahlen zu sortieren, ben\xF6tigt man also drei Bubble-Phasen:'+'<pre><code>'+'Erste Bubble-Phase:<br>'+'[4, 2, 3, 1] -> [2, 4, 3, 1] Das erste Element wird mit dem zweiten verglichen. Sie werden vertauscht, da 4>2 ist.<br>'+'[2, 4, 3, 1] -> [2, 3, 4, 1] Das zweite Element wird mit dem dritten verglichen. Sie werden vertauscht, da 4>3 ist.<br>'+'[2, 3, 4, 1] -> [2, 3, 1, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden vertauscht, da 4>1 ist.<br>'+'Das gr\xF6\xDFte Element ist an die richtige Stelle geblubbert.<br><br>'+'Zweite Bubble-Phase:<br>'+'[2, 3, 1, 4] -> [2, 3, 1, 4] Das erste Element wird mit dem zweiten verglichen. Sie werden nicht vertauscht, da 2<3 ist.<br>'+'[2, 3, 1, 4] -> [2, 1, 3, 4] Das zweite Element wird mit dem dritten verglichen. Sie werden vertauscht, da 3>1 ist.<br>'+'[2, 1, 3, 4] -> [2, 1, 3, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden nicht vertauscht, da 3<4 ist.<br>'+'Das zweitgr\xF6\xDFte Element ist an die richtige Stelle geblubbert.<br><br>'+'Dritte Bubble-Phase:<br>'+'[2, 1, 3, 4] -> [1, 2, 3, 4] Das erste Element wird mit dem zweiten verglichen. Sie werden vertauscht, da 2>1 ist.<br>'+'[1, 2, 3, 4] -> [1, 2, 3, 4] Das zweite Element wird mit dem dritten verglichen. Sie werden nicht vertauscht, da 2<3 ist.<br>'+'[1, 2, 3, 4] -> [1, 2, 3, 4] Das dritte Element wird mit dem vierten verglichen. Sie werden vertauscht, da 3<4 ist.<br>'+'Das drittgr\xF6\xDFte Element ist an die richtige Stelle geblubbert.<br>'+'Damit ist automatisch auch das kleinste Element an der richtigen Stelle.<br>'+'Das Array ist aufsteigend sortiert.'+'</code></pre>',task:'Schreibe eine Funktion <code>sort</code>, die ein mit Zahlen gef\xFClltes Array entgegennimmt und die diese Zahlen aufsteigend sortiert als Array zur\xFCckgibt. '+'Wird ein leeres Array \xFCbergeben, so soll auch ein leeres Array zur\xFCckgegeben werden. <code>sort([4,&nbsp;2,&nbsp;3,&nbsp;1])</code> sollte <code>[1,&nbsp;2,&nbsp;3,&nbsp;4]</code> ergeben.',beforeTests:function(){if(typeof sort!=='undefined'){sort=undefined}},tests:[function(){var ok=typeof sort==='function';var msg;if(ok){msg='<code>sort</code> ist eine Funktion.'}else{msg='<code>sort</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=sort.length===1;var msg;if(ok){msg='<code>sort</code> hat 1 Parameter.'}else{msg='<code>sort</code> hat nicht 1, sondern '+sort.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=sort([]);ok=ArrayUtil.isEqual(result,[]);if(ok){msg='<code>sort([])</code> gibt <code>[]</code> zur\xFCck.'}else{msg='<code>sort([])</code> gibt nicht <code>[]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>sort([])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=sort([1]);ok=ArrayUtil.isEqual(result,[1]);if(ok){msg='<code>sort([1])</code> gibt <code>[1]</code> zur\xFCck.'}else{msg='<code>sort([1])</code> gibt nicht <code>[1]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>sort([1])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=sort([2,1]);ok=ArrayUtil.isEqual(result,[1,2]);if(ok){msg='<code>sort([2, 1])</code> gibt <code>[1, 2]</code> zur\xFCck.'}else{msg='<code>sort([2, 1])</code> gibt nicht <code>[1, 2]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>sort([2, 1])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=sort([2,3,1]);ok=ArrayUtil.isEqual(result,[1,2,3]);if(ok){msg='<code>sort([2, 3, 1])</code> gibt <code>[1, 2, 3]</code> zur\xFCck.'}else{msg='<code>sort([2, 3, 1])</code> gibt nicht <code>[1, 2, 3]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>sort([2, 3, 1])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=sort([5,4,3,2,1]);ok=ArrayUtil.isEqual(result,[1,2,3,4,5]);if(ok){msg='<code>sort([5, 4, 3, 2, 1])</code> gibt <code>[1, 2, 3, 4, 5]</code> zur\xFCck.'}else{msg='<code>sort([5, 4, 3, 2, 1])</code> gibt nicht <code>[1, 2, 3, 4, 5]</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>sort([5, 4, 3, 2, 1])</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]})})(jshero.array);
jshero.koans.add({id:'comment',title:'Kommentare',lesson:'Neben dem eigentlichen Code kann man Kommentare schreiben. Kommentare dienen dazu, Programme zu erkl\xE4ren. Sie helfen uns Menschen, Programme zu verstehen und zu verwenden. '+'Computer, die Programme ausf\xFChren, ignorieren Kommentare. In JavaScript gibt zwei M\xF6glichkeiten, Kommentare zu schreiben: '+'Zeilen-Kommentare werden mit <code>//</code> eingeleitet und gelten immer bis zum Ende der Zeile. Block-Kommentare werden mit <code>/*</code> eingeleitet und mit <code>*/</code> beendet. '+'Alles dazwischen ist Kommentar. Hier ein paar Beispiele:'+'<pre><code>'+'// Das ist ein Zeilenkommentar.<br><br>'+'// Dieser Zeilenkommentar geht<br>'+'// \xFCber 2 Zeilen.<br><br>'+'/* Das ist ein Blockkommentar. */<br><br>'+'/* Dieser Blockkommentar geht<br>'+'\xFCber mehrere Zeilen. */<br><br>'+'/**<br>'+' * Auch dies ist ein Blockkommentar.<br>'+' * Die zus\xE4tzlichen Sterne zwischen<br>'+' * dem Beginn und dem Ende des<br>'+' * Blockkommentars dienen nur zur<br>'+' * Verzierung. So sieht ein l\xE4ngerer <br>'+' * Blockkommentar \xFCbersichtlicher aus.<br>'+' */</code></pre>'+'Block-Kommentare schreibt man gerne \xFCber Funktionen, Zeilen-Kommentare in den Code-Fluss.'+'<pre><code>'+'/**<br>'+' * Pr\xFCft, ob eine String kein Zeichen<br>'+' * au\xDFer Leerzeichen enth\xE4lt.<br>'+' */<br>'+'var isEmpty = function(string) {<br>'+'  // Die Methode trim() entfernt Leerzeichen<br>'+'  // am Anfang und am Ende einer Zeichenfolge.<br>'+'  var trimmedString = string.trim();<br>'+'  return trimmedString.length === 0;<br>'+'};</code></pre>'+'Da Kommentare mit den hier verwendeten Tests nicht \xFCberpr\xFCfen werden k\xF6nnen, eine Aufgabe, bei der man vieles von dem bisher Gelernten anwenden muss.',task:'Schreibe eine Funktion <code>median</code>, die ein Array von aufsteigend sortierten Zahlen entgegennimmt und die den Median dieser Zahlen zur\xFCckgibt. '+'<code>median([1, 2, 10])</code> sollte <code>2</code> ergeben; <code>median([1, 2, 10, 100])</code> sollte <code>6</code> ergeben. '+'Der Median einer sortierten Zahlenreihe ist der Wert, der an der mittleren Stelle steht. Ist die Anzahl der Werte gerade, so ist der Median der Mittelwert '+'der beiden mittleren Zahlen.',beforeTests:function(){if(typeof median!=='undefined'){median=undefined}},tests:[function(){var ok=typeof median==='function';var msg;if(ok){msg='<code>median</code> ist eine Funktion.'}else{msg='<code>median</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=median.length===1;var msg;if(ok){msg='<code>median</code> hat 1 Parameter.'}else{msg='<code>median</code> hat nicht 1, sondern '+median.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=median([1]);ok=result===1;if(ok){msg='<code>median([1])</code> gibt <code>1</code> zur\xFCck.'}else{msg='<code>median([1])</code> gibt nicht <code>1</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>median([1])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=median([1,2]);ok=result===1.5;if(ok){msg='<code>median([1, 2])</code> gibt <code>1.5</code> zur\xFCck.'}else{msg='<code>median([1, 2])</code> gibt nicht <code>1.5</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>median([1, 2])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=median([1,2,10]);ok=result===2;if(ok){msg='<code>median([1, 2, 10])</code> gibt <code>2</code> zur\xFCck.'}else{msg='<code>median([1, 2, 10])</code> gibt nicht <code>2</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>median([1, 2, 10])</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
(function(dateUtil){jshero.koans.add({id:'date',title:'Datum und Uhrzeit',lesson:'Um mit Datum und Uhrzeit zu arbeiten, verwendet man <code>Date</code>-Objekte. Ein <code>Date</code>-Objekt repr\xE4sentiert '+'einen Zeitpunkt, also ein Datum zusammen mit einer Uhrzeit. Die Uhrzeit wird dabei auf die Millisekunde genau festgelegt. '+'Ein Date-Objekt erzeugt man mit <code>new Date()</code>. Es gibt 4 m\xF6gliche Aufrufe: '+'<pre><code>// aktueller Zeitpunkt<br>var d1 = new Date();</code></pre>'+'Ohne Parameter erzeugt <code>new Date()</code> ein Date-Objekt, das dem Zeitpunkt seines Aufrufs entspricht. Wird obiges Beispiel '+'am 1. Mai 2017 um 8:15 Uhr aufgerufen, so enth\xE4lt <code>d1</code> eben diesen Zeitpunkt.<br>'+'<pre><code>// Aufruf mit Jahr, Monat, Tag, Stunde,<br>// Stunde, Minute, Sekunde, Millisekunde<br>var d2 = new Date(2017, 2, 8, 16, 31, 10, 117);</code></pre>'+'M\xF6chte man ein Date-Objekt zu einem bestimmten Zeitpunkt erstellen, verwendet man am besten die zweite M\xF6glichkeit. '+'Hier \xFCbergibt man als Parameter das Jahr, den Monat, den Tag, die Stunde, die Minute, die Sekunde und die Millisekunde. '+'Das Jahr muss in voller L\xE4nge \xFCbergeben werden. <code>17</code> ergibt das Jahr 17 n. Chr. und <code>2017</code> das Jahr 2017 n. Chr. '+'Bei dem Monat muss man aufpassen. JavaScript nummeriert die Monate von 0 (Januar) bis 11 (Dezember). Alle weiteren Zahlen entsprechen der \xFCblichen '+'Bedeutung. <code>d2</code> repr\xE4sentiert also den Zeitpunkt 8.3.2017, 16:31:10 Uhr und 117 Millisekunden.<br>'+'Die Parameter Millisekunde, Sekunde, Minute, Stunde und Tag sind - in dieser Reihenfolge - optional. Man kann sie weglassen. '+'Gibt man sie nicht an, werden die Zeitangaben automatisch auf 0 gesetzt. Der Tag wird auf den Monatsersten gesetzt. '+'Das ist besonders praktisch, wenn man nur mit einem Datum arbeiten m\xF6chte. '+'Dann l\xE4\xDFt man einfach alle Zeitangaben weg. <code>new&nbsp;Date(2017, 5, 2)</code> ist der 2.6.2017, 0:00 Uhr.<br>'+'<pre><code>// Millisekunden seit dem 1.1.1970<br>var d3 = new Date(86400000);</code></pre>'+'Bei der dritten Variante \xFCbergibt man die vergangenen Millisekunden seit dem 1.1.1970, 0:00 Uhr. Der Bezugspunkt 1.1.1970 f\xFCr Datumsangaben ist seit den '+'Tagen von Unix und der Programmiersprache C in der IT \xFCblich geworden. Ein Tag hat 24 * 60 * 60 * 1000 = 86400000 Millisekunden. <code>d3</code> ist '+'also der 2.1.1970, 0:00 Uhr.<br>'+'<pre><code>// \xDCbergabe eines Datumsstrings<br>var d4 = new Date("2017-3-8T16:31:10.117");</code></pre>'+'Bei der vierten Variante wird ein Datumsstring in einem bestimmten Format, d.h. in einer bestimmten Schreibweise, \xFCbergeben. '+'<code>d4</code> entspricht ebenfalls dem Zeitpunkt 8.3.2017, 16:31:10 Uhr und 117 Millisekunden. Diese Varainte ist jedoch nicht zu empfehlen, '+'da verschiedene Browser leichte Unterschiede bei der Bestimmung des Datums aufweisen.',task:'Schreibe eine Funktion <code>nikolaus</code>, die eine Jahreangabe als Zahl entgegennimmt und  die ein Date-Objekt mit dem 6. Dezember '+'des \xFCbergebenen Jahres, 0:00 Uhr, zur\xFCckgibt. <code>nikolaus(2017)</code> sollte ein Date-Objekt mit dem Zeitpunkt 6.12.2017, 0:00 Uhr zur\xFCckgeben.',beforeTests:function(){if(typeof nikolaus!=='undefined'){nikolaus=undefined}},tests:[function(){var ok=typeof nikolaus==='function';var msg;if(ok){msg='<code>nikolaus</code> ist eine Funktion.'}else{msg='<code>nikolaus</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=nikolaus.length===1;var msg;if(ok){msg='<code>nikolaus</code> hat 1 Parameter.'}else{msg='<code>nikolaus</code> hat nicht 1, sondern '+nikolaus.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=nikolaus(2017);ok=dateUtil.isDate(result);if(ok){msg='<code>nikolaus(2017)</code> gibt ein Date-Objekt zur\xFCck.'}else{msg='<code>nikolaus(2017)</code> gibt kein Date-Objekt zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>nikolaus(2017)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=nikolaus(2017);ok=result.getTime()===new Date(2017,11,6).getTime();if(ok){msg='<code>nikolaus(2017)</code> gibt den 6.12.2017 zur\xFCck.'}else{msg='<code>nikolaus(2017)</code> gibt nicht den 6.12.2017 zur\xFCck, sondern den '+result.toLocaleString()+' zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>nikolaus(2017)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=nikolaus(1960);ok=dateUtil.isDate(result);if(ok){msg='<code>nikolaus(1960)</code> gibt ein Date-Objekt zur\xFCck.'}else{msg='<code>nikolaus(1960)</code> gibt kein Date-Objekt zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>nikolaus(1960)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=nikolaus(1960);ok=result.getTime()===new Date(1960,11,6).getTime();if(ok){msg='<code>nikolaus(1960)</code> gibt den 6.12.1960 zur\xFCck.'}else{msg='<code>nikolaus(1960)</code> gibt nicht den 6.12.1960 zur\xFCck, sondern den '+result.toLocaleString()+' zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>nikolaus(1960)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]})})(jshero.date);
jshero.koans.add({id:'date2',title:'Datum und Uhrzeit ausgeben',lesson:'Zur Ausgabe der Daten eines Date-Objekts gibt es sieben sogenannte Getter-Methoden:'+'<pre><code>'+'var startFastnacht = new Date(2017, 10, 11, 11, 11);<br>'+'var jahr = startFastnacht.getFullYear();<br>'+'var monat = startFastnacht.getMonth();<br>'+'var tag = startFastnacht.getDate();<br>'+'var stunde = startFastnacht.getHours();<br>'+'var minute = startFastnacht.getMinutes();<br>'+'var sekunde = startFastnacht.getSeconds();<br>'+'var millisekunde = startFastnacht.getMilliseconds();<br>'+'</code></pre>'+'Man erh\xE4lt die erwarteten Werte: <code>2017</code> f\xFCr das Jahr, <code>10</code> f\xFCr den Monat, <code>11</code> f\xFCr den Tag, die Stunde und die Minute, '+'sowie <code>0</code> f\xFCr die Sekunde und die Millisekunde. '+'Die Monatsz\xE4hlung beginnt wie beim Erzeugen eines Date-Objektes mit <code>0</code>. <code>10</code> steht f\xFCr den November.',task:'Schreibe eine Funktion <code>toGerman</code>, die ein Date-Objekt entgegennimmt und dessen Datum im Format "d.M.YYYY" zur\xFCckgibt. '+'Mit <code>date = new Date(2017, 2, 8)</code> sollte <code>toGerman(date)</code> den String <code>"8.3.2017"</code> zur\xFCckgeben.',beforeTests:function(){if(typeof toGerman!=='undefined'){toGerman=undefined}},tests:[function(){var ok=typeof toGerman==='function';var msg;if(ok){msg='<code>toGerman</code> ist eine Funktion.'}else{msg='<code>toGerman</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=toGerman.length===1;var msg;if(ok){msg='<code>toGerman</code> hat 1 Parameter.'}else{msg='<code>toGerman</code> hat nicht 1, sondern '+toGerman.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=toGerman(new Date(2017,2,8));ok=result==='8.3.2017';if(ok){msg='<code>toGerman(new Date(2017, 2, 8))</code> gibt <code>"8.3.2017"</code> zur\xFCck.'}else{msg='<code>toGerman(new Date(2017, 2, 8))</code> gibt nicht <code>"8.3.2017"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>toGerman(new Date(2017, 2, 8))</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=toGerman(new Date(1724,3,22));ok=result==='22.4.1724';if(ok){msg='<code>toGerman(new Date(1724, 3, 22))</code> gibt <code>"22.4.1724"</code> zur\xFCck.'}else{msg='<code>toGerman(new Date(1724, 3, 22))</code> gibt nicht <code>"22.4.1724"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>toGerman(new Date(1724, 3, 22))</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
(function(dateUtil){jshero.koans.add({id:'date3',title:'Datum und Uhrzeit \xE4ndern',lesson:'Passend zu den sieben Getter-Methoden besitzt das Date-Objekt sieben Setter-Methoden: '+'<code>setFullYear</code>, <code>setMounth</code>, <code>setDate</code>, <code>setHours</code>, <code>setMinutes</code>, <code>setSeconds</code> und <code>setMilliseconds</code>. '+'Mit diesen 7 Methoden kann man den entsprechenden Date-Eintrag setzen:'+'<pre><code>'+'var today = new Date();<br>'+'today.setHours(0);<br>'+'today.setMinutes(0);<br>'+'today.setSeconds(0);<br>'+'today.setMilliseconds(0);<br>'+'</code></pre>'+'<code>today</code> enth\xE4lt zun\xE4chst den Zeitpunkt seiner Erstellung. Anschlie\xDFend wird mit den vier Setter-Aufrufen die Zeit auf 0:00:00.000 Uhr gesetzt. '+'So enth\xE4lt <code>today</code> das aktuelle Tagesdatum mit zur\xFCckgesetzter Uhrzeit.<br><br>'+'\xDCberschreitet oder unterschreitet man bei einer dieser Methoden den zul\xE4ssigen Wertebereich, dann rechnen diese Methoden den \xDCber- oder Untertrag automatisch um:<br>'+'<pre><code>'+'var someDay = new Date(2020, 3, 1);<br>'+'someDay.setDate(32);<br>'+'someDay.setDate(0);<br>'+'</code></pre>'+'Zun\xE4chst repr\xE4sentiert <code>someDay</code> den 1.4.2020. Nun wird der Tag auf den 32. gesetzt. Da der April 30 Tage hat, entspricht das dem 2.5.2020. Wird nun der Tag '+'auf 0 gesetzt, erh\xE4lt man den 30.4.2020.',task:'Schreibe eine Funktion <code>yesterday</code>, die ein Date-Objekt entgegennimmt, dessen Datum um einen Tag zur\xFCcksetzt und dann dieses Date-Objekt zur\xFCckgibt. '+'Die Uhrzeit soll dabei nicht ver\xE4ndert werden. Mit <code>date = new Date(1965, 8, 14)</code> sollte <code>yesterday(date)</code> ein Date-Objekt zur\xFCckgeben, das den 13.9.1965 repr\xE4sentiert.',beforeTests:function(){if(typeof yesterday!=='undefined'){yesterday=undefined}},tests:[function(){var ok=typeof yesterday==='function';var msg;if(ok){msg='<code>yesterday</code> ist eine Funktion.'}else{msg='<code>yesterday</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=yesterday.length===1;var msg;if(ok){msg='<code>yesterday</code> hat 1 Parameter.'}else{msg='<code>yesterday</code> hat nicht 1, sondern '+yesterday.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=yesterday(new Date(1965,8,14));ok=dateUtil.isDate(result);if(ok){msg='<code>yesterday(new Date(1965, 8, 14))</code> gibt eine Date-Objekt zur\xFCck.'}else{msg='<code>yesterday(new Date(1965, 8, 14))</code> gibt kein Date-Objekt zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>yesterday(new Date(1965, 8, 14))</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=yesterday(new Date(1965,8,14));ok=dateUtil.isEqual(result,new Date(1965,8,13));if(ok){msg='<code>yesterday(new Date(1965, 8, 14))</code> gibt eine Date-Objekt zur\xFCck, das den 13.9.1965 repr\xE4sentiert. '}else{msg='<code>yesterday(new Date(1965, 8, 14))</code> gibt eine Date-Objekt zur\xFCck, das nicht den 13.9.1965 repr\xE4sentiert, sondern den '+result.toLocaleString()+'.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>yesterday(new Date(1965, 8, 14))</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=yesterday(new Date(2000,0,1,12));ok=dateUtil.isDate(result);if(ok){msg='<code>yesterday(new Date(2000, 0, 1, 12))</code> gibt eine Date-Objekt zur\xFCck.'}else{msg='<code>yesterday(new Date(2000, 0, 1, 12))</code> gibt kein Date-Objekt zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>yesterday(new Date(2000, 0, 1, 12))</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=yesterday(new Date(2000,0,1,12));ok=dateUtil.isEqual(result,new Date(1999,11,31,12));if(ok){msg='<code>yesterday(new Date(2000, 0, 1, 12))</code> gibt eine Date-Objekt zur\xFCck, das den 31.12.1999, 12 Uhr repr\xE4sentiert. '}else{msg='<code>yesterday(new Date(2000, 0, 1, 12))</code> gibt eine Date-Objekt zur\xFCck, das nicht den 31.12.1999, 12 Uhr repr\xE4sentiert, sondern den '+result.toLocaleString()+'.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>yesterday(new Date(2000, 0, 1, 12))</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]})})(jshero.date);
(function(){jshero.koans.add({id:'dowhile',title:'do...while-Schleife',lesson:'Die <code>do...while</code>-Schleife funktioniert \xE4hnlich wie die <code>while</code>-Schleife. '+'Der Schleifen-Code wird ausgef\xFChrt, solange die Schleifenbedingung <code>true</code> ergibt. '+'Einziger Unterschied ist, dass die Schleifenbedingung nach dem Schleifen-Code \xFCberpr\xFCft wird. '+'Dadurch ist sichergestellt, dass der Schleifen-Code mindestens einmal durchlaufen wird.'+'<pre><code>var restDurch6;<br>'+'var restDurch8;<br>'+'var kgV = 0;<br>'+'do {<br>'+'  kgV++;<br>'+'  restDurch6 = kgV % 6;<br>'+'  restDurch8 = kgV % 8;<br>'+'} while (restDurch6 !== 0 || restDurch8 !== 0)</code></pre>'+'Dieser Codeabschnitt berechnet das kleinste gemeinsame Vielfache (kgV) von 6 und 8. '+'Das kgV ist die kleinste Zahl, die sowohl ein Vielfaches von 6 als auch ein Vielfaches von 8 ist. '+'Die Vielfachen von 6 sind 6, 12, 18, 24, 30, ... und die Vielfachen von 8 sind 8, 16, 24, 32, ... . '+'Damit ist das kgV von 6 und 8 die Zahl 24.<br>'+'Unser Codebeispiel pr\xFCft beginnend mit <code>1</code>, ob <code>kgV</code> sowohl durch <code>6</code> als auch durch <code>8</code> teilbar ist. '+'Die Teilbarkeit wird mithilfe des Modulo-Operators \xFCberpr\xFCft. Eine Zahl ist durch 6 bzw. 8 teilbar, '+'wenn sie Modulo 6 bzw. Modulo 8 den Wert 0 liefert. Die Modulo-Berechnung findet im Schleifen-Code statt. '+'In der Schleifenbedingung wird dann \xFCberpr\xFCft, ob beide Modulo-Berechnungen <code>0</code> ergeben. Ist eine von beiden '+'Modulo-Berechnungen nicht <code>0</code>, ist die Schleifenbedingung <code>true</code> und der Schleifen-Code wird mit einem um 1 erh\xF6hten <code>kgV</code> '+'erneut durchlaufen. Ergeben beide Modulo-Berechnungen <code>0</code>, ist die Schleifenbedingung <code>false</code> und die Schleife wird beendet. '+'<code>kgV</code> hat dann den gew\xFCnschten Wert (n\xE4mlich 24), da es die erste Zahl ist, die sowohl durch 6 als auch durch 8 teilbar ist.',task:'Schreibe eine Funktion <code>kgV</code>, die zwei nat\xFCrliche Zahlen als Parameter entgegennimmt und deren kgV berechnet. '+'<code>kgV(6, 8)</code> sollte <code>24</code> zur\xFCckgeben.',beforeTests:function(){if(typeof kgV!=='undefined'){kgV=undefined}},tests:[function(){var ok=typeof kgV==='function';var msg;if(ok){msg='<code>kgV</code> ist eine Funktion.'}else{msg='<code>kgV</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=kgV.length===2;var msg;if(ok){msg='<code>kgV</code> hat 2 Parameter.'}else{msg='<code>kgV</code> hat nicht 2, sondern '+kgV.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=kgV(6,8);ok=result===24;if(ok){msg='<code>kgV(6, 8)</code> gibt <code>24</code> zur\xFCck.'}else{msg='<code>kgV(6, 8)</code> gibt nicht <code>24</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>kgV(6, 8)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=kgV(5,7);ok=result===35;if(ok){msg='<code>kgV(5, 7)</code> gibt <code>35</code> zur\xFCck.'}else{msg='<code>kgV(5, 7)</code> gibt nicht <code>35</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>kgV(5, 7)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]})})();
jshero.koans.add({id:'else',title:'if ... else',lesson:'M\xF6chte man, dass ein Codeblock nur dann ausgef\xFChrt wird, wenn eine <code>if</code>-Bedingung nicht erf\xFCllt ist, verwendet man '+'zus\xE4tzlich zum <code>if</code> ein <code>else</code> (engl.: sonst).'+'<pre><code>var mitteilung;<br>if (betrag > 1000) {<br>  mitteilung = "Keine Auszahlung m\xF6glich!";<br>} else {<br>'+'  mitteilung = "Der Betrag wird ausgezahlt!";<br>}</code></pre>'+'Je nachdem, ob <code>betrag</code> gr\xF6\xDFer oder kleiner <code>1000</code> ist, wird entweder der <code>if</code>-Zweig oder '+'der <code>else</code>-Zweig ausgef\xFChrt.',task:'Schreibe eine Funktion <code>addiereMitZuschlag</code>, die zwei Betr\xE4ge mit Zuschlag addiert. F\xFCr jeden Betrag, der kleiner gleich <code>10</code> '+'ist, betr\xE4gt der Zuschlag <code>1</code>. F\xFCr jeden Betrag, der gr\xF6\xDFer <code>10</code> ist, betr\xE4gt der Zuschlag <code>2</code>. '+'<code>addiereMitZuschlag(10, 20)</code> sollte <code>33</code> ergeben.',beforeTests:function(){if(typeof addiereMitZuschlag!=='undefined'){addiereMitZuschlag=undefined}},tests:[function(){var ok=typeof addiereMitZuschlag==='function';var msg;if(ok){msg='<code>addiereMitZuschlag</code> ist eine Funktion.'}else{msg='<code>addiereMitZuschlag</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=addiereMitZuschlag.length===2;var msg;if(ok){msg='<code>addiereMitZuschlag</code> hat 2 Parameter.'}else{msg='<code>addiereMitZuschlag</code> hat nicht 2, sondern '+addiereMitZuschlag.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=addiereMitZuschlag(10,10);ok=result===22;if(ok){msg='<code>addiereMitZuschlag(10, 10)</code> ergibt <code>22</code>.'}else{msg='<code>addiereMitZuschlag(10, 10)</code> ergibt nicht <code>22</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>addiereMitZuschlag(10, 10)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=addiereMitZuschlag(10,11);ok=result===24;if(ok){msg='<code>addiereMitZuschlag(10, 11)</code> ergibt <code>24</code>.'}else{msg='<code>addiereMitZuschlag(10, 11)</code> ergibt nicht <code>24</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>addiereMitZuschlag(10, 11)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=addiereMitZuschlag(11,10);ok=result===24;if(ok){msg='<code>addiereMitZuschlag(11, 10)</code> ergibt <code>24</code>.'}else{msg='<code>addiereMitZuschlag(11, 10)</code> ergibt nicht <code>24</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>addiereMitZuschlag(11, 10)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=addiereMitZuschlag(11,11);ok=result===26;if(ok){msg='<code>addiereMitZuschlag(11, 11)</code> ergibt <code>26</code>.'}else{msg='<code>addiereMitZuschlag(11, 11)</code> ergibt nicht <code>26</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>addiereMitZuschlag(11, 11)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'elseif',title:'else if',lesson:'M\xF6chte man mehrere F\xE4lle unterscheiden, kann man ein <code>if</code> mit beliebig vielen <code>else if</code> '+'erg\xE4nzen. Zum Schluss kann bei Bedarf noch ein einzelnes <code>else</code> stehen.'+'<pre><code>var mitteilung;<br>if (betrag > 1000) {<br>  mitteilung = "Zu gro\xDF. Keine Auszahlung m\xF6glich!";<br>'+'} else if (betrag < 10) {<br>  mitteilung = "Zu klein. Keine Auszahlung m\xF6glich!";<br>} else {<br>'+'  mitteilung = "Der Betrag wird ausgezahlt!";<br>}</code></pre>'+'Zuerst wird gepr\xFCft, ob <code>betrag</code> gr\xF6\xDFer <code>1000</code> ist. Ist das der Fall, wird die "Zu gro\xDF..."-Mitteilung '+'gesetzt und der Code am Ende des gesamten Blocks fortgesetzt. Ist das nicht der Fall, wird die <code>else if</code>-Bedingung '+'gepr\xFCft. Ist diese erf\xFCllt, wird die "Zu klein..."-Mitteilung gesetzt und der Code am Ende des gesamten Blocks fortgesetzt. '+'Erst wenn keine Bedingung erf\xFCllt ist, wird der abschlie\xDFenden <code>else</code>-Block ausgef\xFChrt.',task:'Schreibe eine Funktion <code>addiereMitZuschlag</code>, die zwei Betr\xE4ge mit Zuschlag addiert. F\xFCr jeden Betrag, der kleiner gleich <code>10</code> '+'ist, betr\xE4gt der Zuschlag <code>1</code>. F\xFCr jeden Betrag, der gr\xF6\xDFer <code>10</code> und kleiner gleich <code>20</code> ist, betr\xE4gt der Zuschlag <code>2</code>. '+'F\xFCr jeden Betrag, der gr\xF6\xDFer <code>20</code> ist, betr\xE4gt der Zuschlag 3. <code>addiereMitZuschlag(10, 30)</code> sollte <code>44</code> ergeben.',beforeTests:function(){if(typeof gleich!=='undefined'){gleich=undefined}},tests:[function(){var ok=typeof addiereMitZuschlag==='function';var msg;if(ok){msg='<code>addiereMitZuschlag</code> ist eine Funktion.'}else{msg='<code>addiereMitZuschlag</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=addiereMitZuschlag.length===2;var msg;if(ok){msg='<code>addiereMitZuschlag</code> hat 2 Parameter.'}else{msg='<code>addiereMitZuschlag</code> hat nicht 2, sondern '+addiereMitZuschlag.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=addiereMitZuschlag(10,10);ok=result===22;if(ok){msg='<code>addiereMitZuschlag(10, 10)</code> ergibt <code>22</code>.'}else{msg='<code>addiereMitZuschlag(10, 10)</code> ergibt nicht <code>22</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>addiereMitZuschlag(10, 10)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=addiereMitZuschlag(10,11);ok=result===24;if(ok){msg='<code>addiereMitZuschlag(10, 11)</code> ergibt <code>24</code>.'}else{msg='<code>addiereMitZuschlag(10, 11)</code> ergibt nicht <code>24</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>addiereMitZuschlag(10, 11)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=addiereMitZuschlag(11,10);ok=result===24;if(ok){msg='<code>addiereMitZuschlag(11, 10)</code> ergibt <code>24</code>.'}else{msg='<code>addiereMitZuschlag(11, 10)</code> ergibt nicht <code>24</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>addiereMitZuschlag(11, 10)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=addiereMitZuschlag(11,11);ok=result===26;if(ok){msg='<code>addiereMitZuschlag(11, 11)</code> ergibt <code>26</code>.'}else{msg='<code>addiereMitZuschlag(11, 11)</code> ergibt nicht <code>26</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>addiereMitZuschlag(11, 11)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=addiereMitZuschlag(10,21);ok=result===35;if(ok){msg='<code>addiereMitZuschlag(10, 21)</code> ergibt <code>35</code>.'}else{msg='<code>addiereMitZuschlag(10, 21)</code> ergibt nicht <code>35</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>addiereMitZuschlag(10, 21)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=addiereMitZuschlag(21,10);ok=result===35;if(ok){msg='<code>addiereMitZuschlag(21, 10)</code> ergibt <code>35</code>.'}else{msg='<code>addiereMitZuschlag(21, 10)</code> ergibt nicht <code>35</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>addiereMitZuschlag(21, 10)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'equals',title:'Strikte Gleichheit',lesson:'Zwei Werte kann man auf strikte Gleichheit \xFCberpr\xFCfen. Das Ergebnis eines solchen Vergleichs ist entweder <code>true</code>, '+'die beiden Werte sind gleich, oder <code>false</code>, die beiden Werte sind ungleich. Der Operator f\xFCr strikte Gleichheit ist '+'<code>===</code>.'+'<pre><code>var sprache = "JavaScript";<br>var x = 10;<br>var v1 = sprache === "Java";<br>var v2 = x === 10;<br>'+'var v3 = x === "10";</code></pre><code>v1</code> bekommt das Ergebnis des Vergleichs der Variablen <code>sprache</code> '+'mit dem Wert <code>"Java"</code> zugewiesen. Da <code>sprache</code> zuvor den Wert <code>JavaScript</code> erhalten hat und '+'diese beiden Werte verschieden sind, hat <code>v1</code> den Wert <code>false</code>. <code>v2</code> ist <code>true</code>, '+'da der Wert von <code>x</code> gleich <code>10</code> ist. Bei der strikten Gleichheit kommt es auch darauf an, dass die '+'Datentypen der beiden verglichenen Werte gleich sind. <code>v3</code> ist <code>false</code>, da hier unterschiedliche Typen '+'verglichen werden. Auf der linken Seite des Vergleichs steht eine Zahl, auf der rechten Seite ein String.',task:'Schreibe eine Funktion <code>gleich</code>, die zwei Werte auf strikte Gleichheit \xFCberpr\xFCft. <code>gleich(1, 1)</code> soll '+'<code>true</code> zur\xFCckgeben, <code>gleich(1, 2)</code> soll <code>false</code> ergeben.',beforeTests:function(){if(typeof gleich!=='undefined'){gleich=undefined}},tests:[function(){var ok=typeof gleich==='function';var msg;if(ok){msg='<code>gleich</code> ist eine Funktion.'}else{msg='<code>gleich</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=gleich.length===2;var msg;if(ok){msg='<code>gleich</code> hat zwei Parameter.'}else{msg='<code>gleich</code> hat nicht 2, sondern '+gleich.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=gleich(1,1);ok=result===true;if(ok){msg='<code>gleich(1, 1)</code> ergibt <code>true</code>.'}else{msg='<code>gleich(1, 1)</code> ergibt nicht <code>true</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>gleich(1, 1)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=gleich(1,'1');ok=result===false;if(ok){msg='<code>gleich(1, "1")</code> ergibt <code>false</code>.'}else{msg='<code>gleich(1, "1")</code> ergibt nicht <code>false</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>gleich(1, "1")</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'equals2',title:'Drei gleiche Werte',lesson:'Die folgende Aufgabe soll das Zusammenspiel von strikter Gleichheit und booleschen Operatoren vertiefen.',task:'Schreibe eine Funktion <code>gleich</code>, die 3 Werte auf strikte Gleichheit \xFCberpr\xFCft. Die Funktion soll nur '+'dann <code>true</code> ergeben, wenn alle 3 Werte gleich sind. <code>gleich(1, 1, 1)</code> soll '+'<code>true</code> zur\xFCckgeben, <code>gleich(1, 1, 2)</code> soll <code>false</code> ergeben.',beforeTests:function(){if(typeof gleich!=='undefined'){gleich=undefined}},tests:[function(){var ok=typeof gleich==='function';var msg;if(ok){msg='<code>gleich</code> ist eine Funktion.'}else{msg='<code>gleich</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=gleich.length===3;var msg;if(ok){msg='<code>gleich</code> hat 3 Parameter.'}else{msg='<code>gleich</code> hat nicht 3, sondern '+gleich.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=gleich(1,1,1);ok=result===true;if(ok){msg='<code>gleich(1, 1, 1)</code> ergibt <code>true</code>.'}else{msg='<code>gleich(1, 1, 1)</code> ergibt nicht <code>true</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>gleich(1, 1, 1)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=gleich(1,1,'1');ok=result===false;if(ok){msg='<code>gleich(1, 1, "1")</code> ergibt <code>false</code>.'}else{msg='<code>gleich(1, 1, "1")</code> ergibt nicht <code>false</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>gleich(1, 1, "1")</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=gleich(1,'1',1);ok=result===false;if(ok){msg='<code>gleich(1, "1", 1)</code> ergibt <code>false</code>.'}else{msg='<code>gleich(1, "1", 1)</code> ergibt nicht <code>false</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>gleich(1, "1", 1)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=gleich('1',1,1);ok=result===false;if(ok){msg='<code>gleich("1", 1, 1)</code> ergibt <code>false</code>.'}else{msg='<code>gleich("1", 1, 1)</code> ergibt nicht <code>false</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>gleich("1", 1, 1)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'even',title:'Gerade Zahlen',lesson:'Diese Aufgabe soll das Zusammenspiel von strikter Gleichheit und dem Modulo-Operator vertiefen.',task:'Schreibe eine Funktion <code>istGerade</code>, die angibt, ob eine \xFCbergebene Zahl gerade oder ungerade ist. '+'Ist die \xFCbergebene Zahl gerade, so soll die Funktion <code>true</code> zur\xFCckgeben, andernfalls <code>false</code>. '+'<code>istGerade(6)</code> soll <code>true</code> ergeben und <code>istGerade(7)</code> soll <code>false</code> zur\xFCckgeben. ',beforeTests:function(){if(typeof istGerade!=='undefined'){gleich=undefined}},tests:[function(){var ok=typeof istGerade==='function';var msg;if(ok){msg='<code>istGerade</code> ist eine Funktion.'}else{msg='<code>istGerade</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=istGerade.length===1;var msg;if(ok){msg='<code>istGerade</code> hat 1 Parameter.'}else{msg='<code>istGerade</code> hat nicht 1, sondern '+istGerade.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=istGerade(10);ok=result===true;if(ok){msg='<code>istGerade(10)</code> ergibt <code>true</code>.'}else{msg='<code>istGerade(10)</code> ergibt nicht <code>true</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>istGerade(10)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=istGerade(15);ok=result===false;if(ok){msg='<code>istGerade(15)</code> ergibt <code>false</code>.'}else{msg='<code>istGerade(15)</code> ergibt nicht <code>false</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>istGerade(15)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
(function(){jshero.koans.add({id:'for',title:'for-Schleife',lesson:'Mit Schleifen k\xF6nnen Code-Abschnitte mehrmals durchlaufen werden. JavaScript kennt mehrere Schleifenarten. Die einfachste ist die <code>for</code>-Schleife.'+'<pre><code>var summe = 0;<br>'+'for (var i = 1; i < 3; i++) {<br>'+'  summe = summe + i;<br>'+'}</code></pre>'+'Die <code>for</code>-Schleife besteht aus drei Steuer-Anweisungen und dem Schleifen-Code. Die drei Anweisungen folgen dem <code>for</code> in runden Klammern. '+'Sie werden durch Semikolons voneinander getrennt. Die erste Anweisung ist die Start-Anweisung. Sie wird einmal zu Beginn der Schleife ausgef\xFChrt. '+'Hier wird normalerweise eine Variable, die sogenannte Schleifenvariable, initialisiert. Die zweite Anweisung ist die Schleifen-Bedingung. '+'Sie wird vor jedem Schleifendurchlauf zu <code>true</code> oder <code>false</code> ausgewertet. Ist der Ausdruck <code>true</code>, wird der Schleifen-Code ausgef\xFChrt. '+'Ist er <code>false</code>, wird die Schleife beendet und die Programmausf\xFChrung wird nach der Schleife fortgesetzt. '+'Nach jedem Schleifen-Durchlauf wird die dritte Anweisung, die sogenannten End-Anweisung, ausgef\xFChrt. Hier wird normalerweise die Schleifenvariable erh\xF6ht. '+'Anschlie\xDFend beginnt ein neuer Schleifendurchlauf mit erneuter Auswertung der Schleifen-Bedingung. '+'Der Schleifen-Code folgt in Mengenklammern den drei Steueranweisungen.<br>'+'In unserem Beispiel hat <code>summe</code> zun\xE4chst den Wert <code>0</code>. In der Start-Anweisung wird <code>i</code> mit <code>1</code> initialisiert. '+'Die Schleifenbedingung <code>1 < 3</code> ist erf\xFCllt, also wird der Schleifen-Code ausgef\xFChrt. <code>summe</code> erh\xE4lt den Wert <code>0 + 1</code>, also <code>1</code>. '+'Nun wird in der End-Anweisung <code>i</code> um <code>1</code> erh\xF6ht (<code>i++</code> ist identisch mit <code>i = i + 1</code>). '+'Es erh\xE4llt also den Wert <code>2</code>. Der zweite Schleifendurchlauf startet mit Auswertung der Schleifenbedingung. Diese Bedingung (<code>2 < 3</code>) ist immer noch erf\xFCllt. '+'Der Schleifen-Code wird erneut ausgef\xFChrt und <code>summe</code> erh\xE4lt jetzt den Wert <code>1 + 2</code>, also <code>3</code>. '+'<code>i</code> wird abermals erh\xF6ht und hat nun den Wert <code>3</code>. '+'Die Schleifenbedingung <code>3 < 3</code> ist jetzt nicht mehr erf\xFCllt. Die Schleife wird beendet und die Programmausf\xFChrung wird nach der Schleife fortgesetzt. '+'Unser Codebespiel hat also alle nat\xFCrlichen Zahlen echt kleiner 3 addiert.',task:'Schreibe eine Funktion <code>addiereBis</code>, die eine Zahl als Parameter entgegennimmt und die '+'alle nat\xFCrlichen Zahlen echt kleiner dem Paramter aufaddiert. Das Ergebnis der Addition soll zur\xFCckgegeben werden. '+'<code>addiereBis(4)</code> sollte <code>6</code> ergeben.',beforeTests:function(){if(typeof addiereBis!=='undefined'){rotiere=undefined}},tests:[function(){var ok=typeof addiereBis==='function';var msg;if(ok){msg='<code>addiereBis</code> ist eine Funktion.'}else{msg='<code>addiereBis</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=addiereBis.length===1;var msg;if(ok){msg='<code>addiereBis</code> hat 1 Parameter.'}else{msg='<code>addiereBis</code> hat nicht 1, sondern '+addiereBis.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=addiereBis(2);ok=result===1;if(ok){msg='<code>addiereBis(2)</code> gibt <code>1</code> zur\xFCck.'}else{msg='<code>addiereBis(2)</code> gibt nicht <code>1</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>addiereBis(2)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=addiereBis(4);ok=result===6;if(ok){msg='<code>addiereBis(4)</code> gibt <code>6</code> zur\xFCck.'}else{msg='<code>addiereBis(4)</code> gibt nicht <code>6</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>addiereBis(4)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]})})();
(function(){jshero.koans.add({id:'for2',title:'Schleifen und Arrays',lesson:'<code>for</code>-Schleifen eignen sich besonders gut zum Durchlaufen von Arrays. Die folgende Funktion filtert aus einem Array diejenigen Elemente heraus, die gr\xF6\xDFer gleich 10 sind. '+'Die gefilterten Werte werden als Array zur\xFCckgegeben:'+'<pre><code>var filter = function(in) {<br>'+'  var out = [];<br>'+'  for (var i = 1; i < in.length; i++) {<br>'+'    if (in[i] >= 10) {<br>'+'      out.push(in[i]);<br>'+'    }<br>'+'  }<br>'+'  return out;<br>'+'};</code></pre>',task:'Schreibe eine Funktion <code>mean</code>, die ein Array gef\xFCllt mit Zahlen entgegennimmt und den Mittelwert dieser Zahlen zur\xFCckgibt. '+'Tipp: Um den Mittelwert von n Zahlen zu berechnen, mu\xDFt du die Zahlen aufaddieren und die erhaltene Summe durch n teilen. '+'<code>mean([1, 4])</code> sollte <code>(1 + 4)/2 = 2.5</code> ergeben.',beforeTests:function(){if(typeof mean!=='undefined'){mean=undefined}},tests:[function(){var ok=typeof mean==='function';var msg;if(ok){msg='<code>mean</code> ist eine Funktion.'}else{msg='<code>mean</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=mean.length===1;var msg;if(ok){msg='<code>mean</code> hat 1 Parameter.'}else{msg='<code>mean</code> hat nicht 1, sondern '+mean.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=mean([0]);ok=result===0;if(ok){msg='<code>mean([0])</code> gibt <code>0</code> zur\xFCck.'}else{msg='<code>mean([0])</code> gibt nicht <code>0</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>mean([0])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=mean([1,2]);ok=result===1.5;if(ok){msg='<code>mean([1, 2])</code> gibt <code>1.5</code> zur\xFCck.'}else{msg='<code>mean([1, 2])</code> gibt nicht <code>1.5</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>mean([1, 2])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=mean([1,4,10,85]);ok=result===25;if(ok){msg='<code>mean([1, 4, 10, 85])</code> gibt <code>25</code> zur\xFCck.'}else{msg='<code>mean([1, 4, 10, 85])</code> gibt nicht <code>25</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>mean([1, 4, 10, 85])</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]})})();
jshero.koans.add({id:"function",title:"Funktionen",lesson:"Eine Funktion ist ein Block von Anweisungen, der beliebig oft ausgef\xFChrt werden kann. "+"Eine Funktion kann Parameter entgegennehmen und eine Funktion kann einen Wert zur\xFCckgeben. "+"Funktionen werden mit dem Schl\xFCsselwort <code>function</code> definiert. Darauf folgen in runden Klammern eingeschlossen die Parameter und "+"anschlie\xDFend, eingeschlossen in geschweiften Klammern, die Anweisungen. Mit dem Schl\xFCsselwort <code>return</code> "+"kann ein Wert zur\xFCckgegeben werden. Gleichzeitig beendet <code>return</code> die Funktion. Anweisungen nach einem <code>return</code> "+"werden nicht mehr ausgef\xFChrt. Funktionen kann man Variablen zuordnen. Mit "+"<pre><code>var farbe = function() {<br>  return \"gr\xFCn\";<br>};</code></pre> definieren wir eine Funktion, "+"die <code>\"gr\xFCn\"</code> zur\xFCckgibt. Die Funktion nimmt keine Paramter entgegen (die runde Klammer ist leer) und sie enth\xE4lt genau "+"eine Anweisung, die R\xFCckgabe. Die Funktion wird der Variablen <code>farbe</code> zugeordnet. \xDCber diese Variable wird die Funktion aufgerufen: <pre><code>var ergebnis = farbe();</code></pre>"+"Jetzt wird die Funktion ausgef\xFChrt. Ihre R\xFCckgabe wird der Variablen <code>ergebnis</code> zugewiesen. <code>ergebnis</code> hat "+"dann den Wert <code>\"gr\xFCn\"</code>.",task:"Deklariere eine Variable <code>hallo</code> und weise ihr eine Funktion zu, die <code>\"Hallo Welt!\"</code> zur\xFCckgibt.",beforeTests:function(){if(typeof hallo!=="undefined"){hallo=undefined}},tests:[function(){var ok=typeof hallo==="function";var msg;if(ok){msg="<code>hallo</code> ist eine Funktion."}else{msg="<code>hallo</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=hallo();ok=result==="Hallo Welt!";if(ok){msg="<code>hallo()</code> gibt <code>\"Hallo Welt!\"</code> zur\xFCck."}else{msg="<code>hallo()</code> gibt nicht <code>\"Hallo Welt!\"</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>hallo()</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"function2",title:"Mehrere Funktionen",lesson:"Wir definieren nun mehr als eine Funktion.\n\n  Wiederholung: So wird eine Funktion mit Namen <code>farbe</code> definiert, die den Wert <code>\"rot\"</code>\n  zur\xFCckgibt:\n\n<pre><code>var farbe = function() {\n  return \"rot\";\n};</code></pre>\n\n  ",task:"Definiere zwei Funktionen. Die erste Funktion <code>a</code> soll <code>\"Hallo a!\"</code>\n  zur\xFCckgeben. Die zweite Funktion <code>b</code> soll <code>\"Hallo b!\"</code> zur\xFCckgeben.\n  ",beforeTests:function(){a=undefined;b=undefined},tests:[function(){return jshero.testutil.assert_de_isFunction("a")},function(){return jshero.testutil.assert_de_isFunction("b")},function(){return jshero.testutil.assert_de_functionReturns("a()","Hallo a!")},function(){return jshero.testutil.assert_de_functionReturns("b()","Hallo b!")}]});
jshero.koans.add({id:"functioncall",title:"Funktionsaufrufe",lesson:"Wichtig ist der Unterschied zwischen der Definition und dem Aufruf einer Funktion.\n    Mit der Definition\n\n<pre><code>var f = function() {\n  return \"hallo\";\n};</code></pre>\n\n    wird festgelegt, was die Funktion machen soll. Sie wird dabei nicht ausgef\xFChrt. Sie wird lediglich zur Ausf\xFChrung bereitgestellt.\n    Erst mit ihrem Aufruf\n\n<pre><code>var x = f();</code></pre>\n\n    wird die Funktion ausgef\xFChrt. Dann werden die Anweisung im Funktionsblock der Reihe nach abgearbeitet.\n    Die R\xFCckgabe der Funktion wird in diesem Beispiel der Variablen <code>x</code> zugewiesen.\n    Definiert werden Funktionen mit dem Schl\xFCsselwort <code>function</code>.\n    Ist die Funktion einer Variablen zugewiesen, geschieht der Aufruf der Funktion \xFCber diese Variable.\n    Funktionen werden einmal definiert, um sie dann an verschiedenen Programmstellen durch ihren Aufruf mehrfach zu benutzen.",task:"1. Definiere eine Funktion <code>begruesse</code>, die den Wet <code>\"Moin!\"</code> zur\xFCckgibt.\n  <br/>\n    2. Deklariere eine Variable <code>begruessung</code>. Rufe die Funktion <code>begruesse</code> auf und weise der Variablen\n    <code>begruessung</code> die R\xFCckgabe dieses Aufrufs zu.",beforeTests:function(){begruesse=undefined;begruessung=undefined},tests:[function(){return jshero.testutil.assert_de_isFunction("begruesse")},function(){return jshero.testutil.assert_de_functionReturns("begruesse()","Moin!")},function(){return jshero.testutil.assert_de_variableDefined(begruessung,"begruessung")},function(){return jshero.testutil.assert_de_variableHasValue(begruessung,"begruessung","Moin!")}]});
jshero.koans.add({id:"further",title:"Fortsetzung folgt ...",lesson:"JS Hero wird fortgesetzt. Weitere \xDCbungen folgen. Zum Abschluss noch eine Aufgabe aus dem Gebiet der Mathematik.",task:"Schreibe eine Funktion <code>quersumme</code>, die die Quersumme einer nat\xFCrlichen Zahl berechnet. "+"Die Quersumme einer Zahl ist dabei die Summe ihrer Ziffern. <code>quersumme(198)</code> sollte <code>18</code> ergeben.",beforeTests:function(){if(typeof quersumme!=="undefined"){quersumme=undefined}},tests:[function(){var ok=typeof quersumme==="function";var msg;if(ok){msg="<code>quersumme</code> ist eine Funktion."}else{msg="<code>quersumme</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok=quersumme.length===1;var msg;if(ok){msg="<code>quersumme</code> hat 1 Parameter."}else{msg="<code>quersumme</code> hat nicht 1, sondern "+quersumme.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=quersumme(1);ok=result===1;if(ok){msg="<code>quersumme(1)</code> gibt <code>1</code> zur\xFCck."}else{msg="<code>quersumme(1)</code> gibt nicht <code>1</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>quersumme(1)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=quersumme(198);ok=result===18;if(ok){msg="<code>quersumme(198)</code> gibt <code>18</code> zur\xFCck."}else{msg="<code>quersumme(198)</code> gibt nicht <code>18</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>quersumme(198)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=quersumme(123456789);ok=result===45;if(ok){msg="<code>quersumme(123456789)</code> gibt <code>45</code> zur\xFCck."}else{msg="<code>quersumme(123456789)</code> gibt nicht <code>45</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>quersumme(123456789)</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
(function(){jshero.koans.add({id:'ggt',title:'ggT',lesson:'Das Gegenst\xFCck zum kleinsten gemeinsamen Vielfachen ist der gr\xF6\xDFte gemeinsamer Teiler (ggT). '+'Der gr\xF6\xDFte gemeinsame Teiler zweier Zahlen a und b ist die gr\xF6\xDFte Zahl, durch die sich sowohl a als auch b teilen l\xE4\xDFt.',task:'Schreibe eine Funktion <code>ggT</code>, die zwei nat\xFCrliche Zahlen als Parameter entgegennimmt und deren ggT berechnet. '+'<code>ggT(6, 15)</code> sollte <code>3</code> zur\xFCckgeben.',beforeTests:function(){if(typeof ggT!=='undefined'){ggT=undefined}},tests:[function(){var ok=typeof ggT==='function';var msg;if(ok){msg='<code>ggT</code> ist eine Funktion.'}else{msg='<code>ggT</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=ggT.length===2;var msg;if(ok){msg='<code>ggT</code> hat 2 Parameter.'}else{msg='<code>ggT</code> hat nicht 2, sondern '+ggT.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=ggT(6,15);ok=result===3;if(ok){msg='<code>ggT(6, 15)</code> gibt <code>3</code> zur\xFCck.'}else{msg='<code>ggT(6, 15)</code> gibt nicht <code>3</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>ggT(6, 15)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=ggT(5,7);ok=result===1;if(ok){msg='<code>ggT(5, 7)</code> gibt <code>1</code> zur\xFCck.'}else{msg='<code>ggT(5, 7)</code> gibt nicht <code>1</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>ggT(5, 7)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=ggT(7,5);ok=result===1;if(ok){msg='<code>ggT(7, 5)</code> gibt <code>1</code> zur\xFCck.'}else{msg='<code>ggT(7, 5)</code> gibt nicht <code>1</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>ggT(7, 5)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=ggT(2,4);ok=result===2;if(ok){msg='<code>ggT(2, 4)</code> gibt <code>2</code> zur\xFCck.'}else{msg='<code>ggT(2, 4)</code> gibt nicht <code>2</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>ggT(2, 4)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=ggT(4,2);ok=result===2;if(ok){msg='<code>ggT(4, 2)</code> gibt <code>2</code> zur\xFCck.'}else{msg='<code>ggT(4, 2)</code> gibt nicht <code>2</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>ggT(4, 2)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]})})();
jshero.koans.add({id:'greaterthan',title:'Zahlen vergleichen',lesson:'Zahlen kann man mit den aus der Mathematik bekannten Zeichen <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code> und <code>&gt;=</code> '+'auf gr\xF6\xDFer, gr\xF6\xDFer gleich, kleiner und kleiner gleich vergleichen. Im folgenden Beispiel liefern alle Ausdr\xFCcke den Wert <code>true</code>:'+'<pre><code>var v1 = 5 > 4;<br>var v2 = 5 >= 5;<br>var v3 = 5 < 6;<br>var v4 = 5 <= 5;</code></pre>',task:'Schreibe eine Funktion <code>istDreistellig</code>, die pr\xFCft, ob eine Zahl gr\xF6\xDFer gleich 100 und kleiner 1000 ist. '+'<code>istDreistellig(500)</code> sollte <code>true</code> zur\xFCckgeben, <code>istDreistellig(50)</code> sollte <code>false</code> ergeben.',beforeTests:function(){if(typeof istDreistellig!=='undefined'){istDreistellig=undefined}},tests:[function(){var ok=typeof istDreistellig==='function';var msg;if(ok){msg='<code>istDreistellig</code> ist eine Funktion.'}else{msg='<code>istDreistellig</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=istDreistellig.length===1;var msg;if(ok){msg='<code>istDreistellig</code> hat einen Parameter.'}else{msg='<code>istDreistellig</code> hat nicht 1, sondern '+istDreistellig.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=istDreistellig(100);ok=result===true;if(ok){msg='<code>istDreistellig(100)</code> ergibt <code>true</code>.'}else{msg='<code>istDreistellig(100)</code> ergibt nicht <code>true</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>istDreistellig(100)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=istDreistellig(999);ok=result===true;if(ok){msg='<code>istDreistellig(999)</code> ergibt <code>true</code>.'}else{msg='<code>istDreistellig(999)</code> ergibt nicht <code>true</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>istDreistellig(999)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=istDreistellig(99);ok=result===false;if(ok){msg='<code>istDreistellig(99)</code> ergibt <code>false</code>.'}else{msg='<code>istDreistellig(99)</code> ergibt nicht <code>false</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>istDreistellig(99)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=istDreistellig(1000);ok=result===false;if(ok){msg='<code>istDreistellig(1000)</code> ergibt <code>false</code>.'}else{msg='<code>istDreistellig(1000)</code> ergibt nicht <code>false</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>istDreistellig(1000)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'if',title:'if',lesson:'H\xE4ufig soll Code nur dann ausgef\xFChrt werden, wenn eine bestimmte Bedingung erf\xFCllt ist. '+'Dazu verwendet man die <code>if</code>-Anweisung.'+'<pre><code>var gewinn = 0;<br>if (wuerfelzahl === 6) {<br>  gewinn = 100;<br>}</code></pre>'+'Diese Anweisung besteht aus dem Schl\xFCsselwort <code>if</code> (engl: wenn) gefolgt von runden Klammern. In den runden Klammern steht ein '+'Ausdruck - die Bedingung -, der zu <code>true</code> oder <code>false</code> ausgewertet wird. Ergibt die Bedingung <code>true</code>, '+'werden alle Anweisungen in dem durch die geschweiften Klammern begrenzten Block ausgef\xFChrt. Ergibt die Bedingung <code>false</code>, '+'wird der durch die geschweiften Klammern begrenzte Block \xFCbersprungen. '+'Hat in unserem Beispiel die Variable <code>wuerfelzahl</code> den Wert <code>6</code>, so wird <code>gewinn</code> auf '+'<code>100</code> gesetzt. Hat <code>wuerfelzahl</code> nicht den Wert <code>6</code>, bleibt <code>gewinn</code> bei <code>0</code>.',task:'Schreibe eine Funktion <code>gleich</code>, die 2 Werte auf strikte Gleichheit \xFCberpr\xFCft. Sind die beiden Werte gleich, so soll '+'der String <code>"GLEICH"</code> zur\xFCckgegeben werden. Sind sie ungleich, so soll man <code>"UNGLEICH"</code> erhalten.',beforeTests:function(){if(typeof gleich!=='undefined'){gleich=undefined}},tests:[function(){var ok=typeof gleich==='function';var msg;if(ok){msg='<code>gleich</code> ist eine Funktion.'}else{msg='<code>gleich</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=gleich.length===2;var msg;if(ok){msg='<code>gleich</code> hat 2 Parameter.'}else{msg='<code>gleich</code> hat nicht 2, sondern '+gleich.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=gleich(1,1);ok=result==='GLEICH';if(ok){msg='<code>gleich(1, 1)</code> ergibt <code>"GLEICH"</code>.'}else{msg='<code>gleich(1, 1)</code> ergibt nicht <code>"GLEICH"</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>gleich(1, 1)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=gleich(1,'1');ok=result==='UNGLEICH';if(ok){msg='<code>gleich(1, "1")</code> ergibt <code>"UNGLEICH"</code>.'}else{msg='<code>gleich(1, "1")</code> ergibt nicht <code>"UNGLEICH"</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>gleich(1, "1")</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"log",title:"Loggen",lesson:"Wenn man Programme schreibt, laufen die Dinge manchmal nicht so wie man will. Es kommt einfach nicht das "+"gew\xFCnschte Ergebnis heraus und man wei\xDF nicht warum. Eine M\xF6glichkeit hier weiter "+"zu kommen ist das Loggen. Man l\xE4\xDFt sich den Wert von Variablen w\xE4hrend der Programmausf\xFChrung ausgeben. In JavaScript macht man "+"das mit der Funktion <code>console.log</code>."+"<pre><code>"+"var mitteilung = \"Hallo\";<br>"+"console.log(mitteilung);<br>"+"mitteilung = mitteilung + \" Franz!\";<br>"+"console.log(mitteilung);<br>"+"</code></pre>"+"Wir geben den Wert von <code>mitteilung</code> zweimal mit <code>console.log</code> aus. Beim ersten Log wird der initiale Werte von "+"<code>mitteilung</code> ausgegeben. Beim zweiten Log sehen wir, welchen Wert <code>mitteilung</code> nach der \xC4nderung hat. "+"So k\xF6nnen wir feststellen, welchen Wert Variablen an bestimmen Stellen des Programmsablaufs besitzen und wie sich dieser Wert im Ablauf \xE4ndert. "+"In unserem Beispiel erhalten wir nacheinander die Ausgaben <code>\"Hallo\"</code> und <code>\"Hallo Franz!\"</code>.<br><br>"+"Wo man das Log zu sehen bekommt, h\xE4ngt von der JavaScript-Umgebung ab. Node.js wird in einer klassischen Konsole gestartet. Dort wird auch das Log ausgegeben. "+"In Browsern sieht man die Log-Ausgabe im normalen Betrieb nicht. Doch jeder Browser besitzt sogenannte Entwickler-Werkzeuge. Das sind m\xE4chtige Tools zur Unterst\xFCtzung "+"von Webentwicklern. Eines dieser Tools ist die Konsole. Dort wird das Log ausgegeben. Wie man die Entwickler-Werkzeuge \xF6ffnet h\xE4ngt vom jeweiligen Browser ab. "+"Bei vielen Desktop-Browsern (z.B. Firefox) wird sie mit der Taste F12 ge\xF6ffnet. Die Konsole kannst du dann als Reiter ausw\xE4hlen. "+"Benutzt du JavaScript Hero im Browser auf einem PC oder Laptop, dann kannst du das sofort ausprobieren. \xD6ffne die Entwickler-Konsole (im Firefox mit F12), schreibe unten in das L\xF6sungsfeld "+"<code>console.log(\"Hallo Konsole!\")</code> und f\xFChre die Tests aus. In der Entwickler-Konsole erscheint \"Hallo Konsole!\".<br><br>"+"Da es sinnvoll ist, das Log direkt in der Testausgabe zu sehen, besitzt JavaScript Hero eine eigene Log-Funktion: <code>jshero.log</code>. "+"Diese Funktion loggt so wie oben <code>console.log</code>. Die Ausgabe wird allerdings nicht in die Entwickler-Konsole, sondern in die Testausgabe geschrieben. "+"So sieht man genau, was bei welchem Testaufruf geloggt wird. <code>jshero.log</code> kannst du in jeder Lektion verwenden! Der Vollst\xE4ndigkeit halber seien zwei Unterschiede zwischen dem "+"Loggen mit <code>console.log</code> und <code>jshero.log</code> genannt: (i)&nbsp;<code>console.log</code> kann mehrere Paramter gleichzeitig loggen "+"und es loggt Objekte (diese werden wir sp\xE4ter kennen lernen) in ihrer Objekt-Notation. (ii)&nbsp;<code>jshero.log</code> loggt nicht beim Einlesen deines L\xF6sungs-Codes. "+"Es ist nur beim Aufruf deiner L\xF6sungsfunktion aktiv. Dadurch werden Log-Aufrufe au\xDFerhalb deiner L\xF6sungsfunktion mit <code>jshero.log</code> nicht geloggt, w\xE4hrend sie "+"mit <code>console.log</code> geloggt werden.",task:"Schreibe eine Funktion <code>rufe</code>, die einen String als Parameter entgegennimmt und diesen String verdoppelt zur\xFCckgibt. "+"Gleichzeitig soll der Eingangsparameter und die R\xFCckgabe mit <code>jshero.log</code> geloggt werden. Der Aufruf <code>rufe(\"Werder\")</code> "+"sollte <code>\"WerderWerder\"</code> zur\xFCckgeben und es sollte nacheinander <code>\"Werder\"</code> und <code>\"WerderWerder\"</code> geloggt werden.",beforeTests:function(){if(typeof rufe!=="undefined"){rufe=undefined}},tests:[function(){var ok=typeof rufe==="function";var msg;if(ok){msg="<code>rufe</code> ist eine Funktion."}else{msg="<code>rufe</code> ist keine Funktion."}return{msg:msg,ok:ok}},function(){var ok=rufe.length===1;var msg;if(ok){msg="<code>rufe</code> hat 1 Parameter."}else{msg="<code>rufe</code> hat nicht 1, sondern "+rufe.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=rufe("Werder");if(result==="WerderWerder"){ok=true;msg="<code>rufe(\"Werder\")</code> gibt <code>\"WerderWerder\"</code> zur\xFCck."}else{ok=false;msg="<code>rufe(\"Werder\")</code> gibt nicht <code>\"WerderWerder\"</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>rufe(\"Werder\")</code>.";e=exc}return{msg:msg,ok:ok,e:e}},function(){var ok,msg,e;try{rufe("Werder");var result=jshero.getLogs().length;if(result===2){ok=true;msg="<code>rufe(\"Werder\")</code> loggt mit <code>jshero.log</code> genau 2 mal."}else{ok=false;msg="<code>rufe(\"Werder\")</code> loggt mit <code>jshero.log</code> nicht 2 mal, sondern "+result+" mal."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>rufe(\"Werder\")</code>.";e=exc}return{msg:msg,ok:ok,e:e}},function(){var ok,msg,e;try{rufe("Werder");var result=jshero.getLogs()[0];if(result==="Werder"){ok=true;msg="<code>rufe(\"Werder\")</code> loggt als erstes die \xDCbergabe <code>\"Werder\"</code>."}else{ok=false;msg="<code>rufe(\"Werder\")</code> loggt als erstes nicht die \xDCbergabe <code>\"Werder\"</code>, sondern es wird <code>"+JSON.stringify(result)+"</code> geloggt."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>rufe(\"Werder\")</code>.";e=exc}return{msg:msg,ok:ok,e:e}},function(){var ok,msg,e;try{rufe("Werder");var result=jshero.getLogs()[1];if(result==="WerderWerder"){ok=true;msg="<code>rufe(\"Werder\")</code> loggt als zweites die R\xFCckgabe <code>\"WerderWerder\"</code>."}else{ok=false;msg="<code>rufe(\"Werder\")</code> loggt als zweites nicht die R\xFCckgabe <code>\"WerderWerder\"</code>, sondern es wird <code>"+JSON.stringify(result)+"</code> geloggt."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>rufe(\"Werder\")</code>.";e=exc}return{msg:msg,ok:ok,e:e}},function(){var ok,msg,e;try{var result=rufe("Kickers");if(result==="KickersKickers"){ok=true;msg="<code>rufe(\"Kickers\")</code> gibt <code>\"KickersKickers\"</code> zur\xFCck."}else{ok=false;msg="<code>rufe(\"Kickers\")</code> gibt nicht <code>\"KickersKickers\"</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>rufe(\"Kickers\")</code>.";e=exc}return{msg:msg,ok:ok,e:e}},function(){var ok,msg,e;try{rufe("Kickers");var result=jshero.getLogs()[0];if(result==="Kickers"){ok=true;msg="<code>rufe(\"Kickers\")</code> loggt als erstes die \xDCbergabe <code>\"Kickers\"</code>."}else{ok=false;msg="<code>rufe(\"Kickers\")</code> loggt als erstes nicht die \xDCbergabe <code>\"Kickers\"</code>, sondern es wird <code>"+JSON.stringify(result)+"</code> geloggt."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>rufe(\"Kickers\")</code>.";e=exc}return{msg:msg,ok:ok,e:e}},function(){var ok,msg,e;try{rufe("Kickers");var result=jshero.getLogs()[1];if(result==="KickersKickers"){ok=true;msg="<code>rufe(\"Kickers\")</code> loggt als zweites die R\xFCckgabe <code>\"KickersKickers\"</code>."}else{ok=false;msg="<code>rufe(\"Kickers\")</code> loggt als zweites nicht die R\xFCckgabe <code>\"KickersKickers\"</code>, sondern es wird <code>"+JSON.stringify(result)+"</code> geloggt."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>rufe(\"Werder\")</code>.";e=exc}return{msg:msg,ok:ok,e:e}}]});
jshero.koans.add({id:"math",title:"Math",lesson:"Viele mathematische Funktionen sind in dem Objekt <code>Math</code> zusammengefasst. "+"So gibt <code>Math.sqrt(x)</code> die Quadratwurzel (engl.: square root) zur\xFCck "+"und mit <code>Math.pow(x, y)</code> berechnet man die Potenz (engl.: power) x hoch y."+"<pre><code>var y1 = Math.sqrt(9);<br>var y2 = Math.pow(10, 3);</code></pre>"+"<code>y1</code> hat den Wert <code>3</code> und <code>y2</code> den Wert <code>1000</code> (10&sup3; = 10 * 10 * 10 = 1000). ",task:"Schreibe eine Funktion <code>hypotenuse</code>, die die L\xE4nge der Hypotenuse eines rechtwinkligen Dreiecks berechnet. "+"\xDCbergeben wird der Funktion als Parameter die L\xE4ngen der beiden Katheten. Tipp: In einem rechtwinkligen Dreieck gilt der Satz "+"des Pythagoras. Sind a, b die L\xE4ngen der beiden Katheten und c die L\xE4nge der Hypotenuse, so gilt: a&sup2; + b&sup2; = c&sup2;. "+"Da 3&sup2; + 4&sup2; = 5&sup2; gilt, sollte <code>hypotenuse(3, 4)</code> den Wert <code>5</code> liefern.",beforeTests:function(){if(typeof hypotenuse!=="undefined"){hypotenuse=undefined}},tests:[function(){var ok=typeof hypotenuse==="function";var msg;if(ok){msg="<code>hypotenuse</code> ist eine Funktion."}else{msg="<code>hypotenuse</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok=hypotenuse.length===2;var msg;if(ok){msg="<code>hypotenuse</code> hat zwei Parameter."}else{msg="<code>hypotenuse</code> hat nicht 2, sondern "+hypotenuse.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=hypotenuse(3,4);ok=result===5;if(ok){msg="<code>hypotenuse(3, 4)</code> ergibt <code>5</code>."}else{msg="<code>hypotenuse(3, 4)</code> ergibt nicht <code>5</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>hypotenuse(3, 4)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=hypotenuse(5,12);ok=result===13;if(ok){msg="<code>hypotenuse(5, 12)</code> ergibt <code>13</code>."}else{msg="<code>hypotenuse(5, 12)</code> ergibt nicht <code>13</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>hypotenuse(5, 12)</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"mean",title:"Klammern",lesson:"Ebenso wie in der Mathematik gilt in JavaScript die Punkt-vor-Strichrechnung. Multiplikation und Division werden vor Addition und Subtraktion "+"ausgef\xFChrt. M\xF6chte man zuerst die Strichrechnung ausf\xFChren, verwendet man genauso wie in der Mathematik Klammern."+"<pre><code>var x1 = 3 + 4 * 2;<br>var x2 = (3 + 4) * 2;</code></pre>"+"<code>x1</code> hat den Wert <code>11</code>, der Wert von <code>x2</code> ist <code>14</code>.",task:"Schreibe eine Funktion <code>mittelwert</code>, die zwei Zahlen als Parameter entgegennimmt und deren Mittelwert zur\xFCckgibt. "+"<code>mittelwert(1, 2)</code> sollte <code>1.5</code> ergeben.",beforeTests:function(){if(typeof mittelwert!=="undefined"){mittelwert=undefined}},tests:[function(){var ok=typeof mittelwert==="function";var msg;if(ok){msg="<code>mittelwert</code> ist eine Funktion."}else{msg="<code>mittelwert</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok=mittelwert.length===2;var msg;if(ok){msg="<code>mittelwert</code> hat zwei Parameter."}else{msg="<code>mittelwert</code> hat nicht 2, sondern "+mittelwert.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=mittelwert(1,2);ok=result===1.5;if(ok){msg="<code>mittelwert(1, 2)</code> ergibt <code>1.5</code>."}else{msg="<code>mittelwert(1, 2)</code> ergibt nicht <code>1.5</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>mittelwert(1, 2)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=mittelwert(0,0);ok=result===0;if(ok){msg="<code>mittelwert(0, 0)</code> ergibt <code>0</code>."}else{msg="<code>mittelwert(0, 0)</code> ergibt nicht <code>0</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>mittelwert(0, 0)</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"modulo",title:"Modulo",lesson:"Ein weiterer arithmetischer Operator ist Modulo. Er berechnet den Rest einer Division und wird mit dem Prozentzeichen <code>%</code> notiert."+"<pre><code>var x = 7 % 2;<br>"+"var y = 20 % 3;</code></pre>"+"7 geteilt durch 2 ergibt 3 Rest 1. <code>x</code> ist also <code>1</code>.<br>"+"20 geteilt durch 3 ergibt 6 Rest 2. <code>y</code> ist also <code>2</code>.",task:"Schreibe eine Funktion <code>einer</code>, die eine nat\xFCrliche Zahl entgegenimmt und die Ziffer der Einer-Stelle zur\xFCckgibt. "+"<code>einer(2674)</code> sollte <code>4</code> zur\xFCckgeben.",beforeTests:function(){if(typeof einer!=="undefined"){einer=undefined}},tests:[function(){var ok=typeof einer==="function";var msg;if(ok){msg="<code>einer</code> ist eine Funktion."}else{msg="<code>einer</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok=einer.length===1;var msg;if(ok){msg="<code>einer</code> hat 1 Parameter."}else{msg="<code>einer</code> hat nicht 1, sondern "+einer.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=einer(0);ok=result===0;if(ok){msg="<code>einer(0)</code> gibt <code>0</code> zur\xFCck."}else{msg="<code>einer(0)</code> gibt nicht <code>0</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>einer(0)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=einer(17);ok=result===7;if(ok){msg="<code>einer(17)</code> gibt <code>7</code> zur\xFCck."}else{msg="<code>einer(17)</code> gibt nicht <code>7</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>einer(17)</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"nan",title:"NaN",lesson:"<code>NaN</code> repr\xE4sentiert den Wert Not-A-Number (engl.: Keine-Zahl). Numerische Operationen oder Funktionen geben <code>NaN</code> zur\xFCck, "+"wenn sie keinen Wert berechnen k\xF6nnen. Wir hatten dies bei <code><a href=\"main.html?koan=parseint\">parseInt</a></code> kennengelernt. "+"<code>parseInt</code> gibt <code>NaN</code> zur\xFCck, wenn es keine Zahl parsen kann. Ein weiteres Beispiel ist die Berechnung der Wurzel aus einer negativen Zahl. "+"<pre><code>"+"var age = parseInt(\"Babylon\");<br>"+"var length = Math.sqrt(-1);"+"</code></pre>"+"Sowohl <code>age</code> als auch <code>length</code> haben den Wert <code>NaN</code>. "+"M\xF6chte man testen, ob <code>NaN</code> vorliegt, kann man leider nicht <code>===</code> verwenden. <code>age === NaN</code> ergibt auch dann <code>false</code>, "+"wenn <code>age</code> den Wert <code>NaN</code> besitzt. <code>NaN</code> ist der einzige Wert in JavaScript, der nicht mit sich selbst "+"gleich ist. Stattdessen verwendet man die Funktion <code>isNaN</code>."+"<pre><code>"+"var message;<br>"+"var age = parseInt(\"Babylon\");<br>"+"if ( isNaN(alter) ) {<br>"+"  message = \"Du hast keine Zahl eingegeben.\";<br>"+"}"+"</code></pre>",task:"Schreibe eine Funktion <code>parseFirstInt</code>, die einen String entgegennimmt und die die erste in dem String vorkommende ganze Zahl zur\xFCckgibt. "+"<code>parseFirstInt(\"Sonnebornstr. 27\")</code> sollte <code>27</code> zur\xFCckgeben. <code>parseFirstInt(\"Babylon\")</code> sollte <code>NaN</code> ergeben.",beforeTests:function(){if(typeof parseFirstInt!=="undefined"){parseFirstInt=undefined}},tests:[function(){var ok=typeof parseFirstInt==="function";var msg;if(ok){msg="<code>parseFirstInt</code> ist eine Funktion."}else{msg="<code>parseFirstInt</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok=parseFirstInt.length===1;var msg;if(ok){msg="<code>parseFirstInt</code> hat 1 Parameter."}else{msg="<code>parseFirstInt</code> hat nicht 1, sondern "+parseFirstInt.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=parseFirstInt("Sonnebornstr. 27");ok=result===27;if(ok){msg="<code>parseFirstInt(\"Sonnebornstr. 27\")</code> ergibt <code>27</code>."}else{msg="<code>parseFirstInt(\"Sonnebornstr. 27\")</code> ergibt nicht <code>27</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>parseFirstInt(\"Sonnebornstr. 27\")</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=parseFirstInt("28 Jahre");ok=result===28;if(ok){msg="<code>parseFirstInt(\"28 Jahre\")</code> ergibt <code>28</code>."}else{msg="<code>parseFirstInt(\"28 Jahre\")</code> ergibt nicht <code>28</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>parseFirstInt(\"28 Jahre\")</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=parseFirstInt("Ohnezahl");ok=Number.isNaN(result);if(ok){msg="<code>parseFirstInt(\"Ohnezahl\")</code> ergibt <code>NaN</code>."}else{msg="<code>parseFirstInt(\"Ohnezahl\")</code> ergibt nicht <code>NaN</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>parseFirstInt(\"Ohnezahl\")</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'notequals',title:'Strikte Ungleichtheit',lesson:'Mit <code>!==</code> vergleicht man zwei Werte auf strikte Ungleichheit.'+'<pre><code>var v1 = "lauf" !== "Lauf";<br>var v2 = 10 !== "10";</code></pre>'+'Beide Vergleiche ergeben <code>true</code>. Der erste, weil sich die beiden Strings in der Gro\xDF- und Kleinschreibung unterscheiden. '+'Der zweite, weil sich die beiden Werte von Typ her unterscheiden.',task:'Schreibe eine Funktion <code>ungleich</code>, die 3 Werte auf strikte Ungleichheit \xFCberpr\xFCft. Die Funktion soll nur dann '+'<code>true</code> ergeben, wenn alle drei Parameter unterschiedlich sind. <code>ungleich(1, 2, 3)</code> soll '+'<code>true</code> liefern, <code>ungleich(1, 1, 2)</code> soll <code>false</code> ergeben.',beforeTests:function(){if(typeof ungleich!=='undefined'){ungleich=undefined}},tests:[function(){var ok=typeof ungleich==='function';var msg;if(ok){msg='<code>ungleich</code> ist eine Funktion.'}else{msg='<code>ungleich</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=ungleich.length===3;var msg;if(ok){msg='<code>ungleich</code> hat 3 Parameter.'}else{msg='<code>ungleich</code> hat nicht 3, sondern '+ungleich.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=ungleich(1,2,3);ok=result===true;if(ok){msg='<code>ungleich(1, 2, 3)</code> ergibt <code>true</code>.'}else{msg='<code>ungleich(1, 2, 3)</code> ergibt nicht <code>true</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>ungleich(1, 2, 3)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=ungleich(1,1,2);ok=result===false;if(ok){msg='<code>ungleich(1, 1, 2)</code> ergibt <code>false</code>.'}else{msg='<code>ungleich(1, 1, 2)</code> ergibt nicht <code>false</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>ungleich(1, 1, 2)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=ungleich(1,2,1);ok=result===false;if(ok){msg='<code>ungleich(1, 2, 1)</code> ergibt <code>false</code>.'}else{msg='<code>ungleich(1, 2, 1)</code> ergibt nicht <code>false</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>ungleich(1, 2, 1)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=ungleich(2,1,1);ok=result===false;if(ok){msg='<code>ungleich(2, 1, 1)</code> ergibt <code>false</code>.'}else{msg='<code>ungleich(2, 1, 1)</code> ergibt nicht <code>false</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>ungleich(2, 1, 1)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=ungleich('1',1,true);ok=result===true;if(ok){msg='<code>ungleich("1", 1, true)</code> ergibt <code>true</code>.'}else{msg='<code>ungleich("1", 1, true)</code> ergibt nicht <code>true</code>, sondern <code>'+JSON.stringify(result)+'</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>ungleich("1", 1, true)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"number",title:"Zahlen",lesson:"Zahlen werden in JavaScript durch einfache Ziffern dargestellt. Sie k\xF6nnen einen Dezimalpunkt und ein Minuszeichen besitzen."+"<pre><code>var x1 = 1;<br>var x2 = 1.0;<br>var x3 = 3.14;<br>var x4 = -1;</code></pre>"+"<code>1</code> und <code>1.0</code> sind dieselbe Zahl. "+"Mit Zahlen kann man rechnen. Die vier Grundrechenarten Addieren, Subtrahieren, Multiplizieren und Dividieren werden durch "+"<code>+ - *</code> und <code>/</code> dargestellt."+"<pre><code>var x1 = 6;<br>var x2 = 2;<br>var x3 = x1 + x2;<br>var x4 = x1 - x2;<br>var x5 = x1 * x2;<br>var x6 = x1 / x2;</code></pre>"+"Die Variablen <code>x3</code> bis <code>x6</code> haben so die Werte <code>8</code>, <code>4</code>, <code>12</code> und <code>3</code>.",task:"Schreibe eine Funktion <code>add</code>, die zwei Zahlen als Parameter entgegennimmt und deren Summe zur\xFCckgibt. "+"<code>add(1, 2)</code> sollte <code>3</code> ergeben.",beforeTests:function(){if(typeof add!=="undefined"){add=undefined}},tests:[function(){var ok=typeof add==="function";var msg;if(ok){msg="<code>add</code> ist eine Funktion."}else{msg="<code>add</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok=add.length===2;var msg;if(ok){msg="<code>add</code> hat zwei Parameter."}else{msg="<code>add</code> hat nicht 2, sondern "+add.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=add(0,0);ok=result===0;if(ok){msg="<code>add(0, 0)</code> ergibt <code>0</code>."}else{msg="<code>add(0, 0)</code> ergibt nicht <code>0</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>add(0, 0)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=add(2,3);ok=result===5;if(ok){msg="<code>add(2, 3)</code> ergibt <code>5</code>."}else{msg="<code>add(2, 3)</code> ergibt nicht <code>5</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>add(2, 3)</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"numbertostring",title:"Number: toString()",lesson:"Die Number-Methode <code>toString</code> wandelt eine Zahl in den entsprechenden String um. Der Dezimalpunkt wird dabei als Punkt dargestellt. "+"Das kann man z.B. dazu verwenden, eine Zahl im deutschen Format, also mit Komma als Dezimalpunkt, auszugeben:"+"<code><pre>"+"var number = 7.25;<br>"+"var numberInEnglish = number.toString();<br>"+"var numberInGerman = numberInEnglish.replace(\".\", \",\");"+"</code></pre>"+"<code>numberInEnglish</code> enth\xE4lt den String <code>\"7.25\"</code>. Da wir jetzt unsere Zahl als String vorliegen haben, k\xF6nnen wir auf ihr die String-Methode "+"<code>replace</code> anwenden. <code>numberInGerman</code> enth\xE4lt so den String <code>\"7,25\"</code>.",task:"Schreibe eine Funktion <code>digitLength</code>, die eine nat\xFCrliche Zahl entgegennimmt und die Anzahl der Ziffern zur\xFCckgibt. "+"<code>digitLength(709)</code> sollte 3 zur\xFCckgeben.",beforeTests:function(){if(typeof digitLength!=="undefined"){digitLength=undefined}},tests:[function(){var ok=typeof digitLength==="function";var msg;if(ok){msg="<code>digitLength</code> ist eine Funktion."}else{msg="<code>digitLength</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok=digitLength.length===1;var msg;if(ok){msg="<code>digitLength</code> hat einen Parameter."}else{msg="<code>digitLength</code> hat nicht 1, sondern "+digitLength.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=digitLength(1);ok=result===1;if(ok){msg="<code>digitLength(1)</code> gibt <code>1</code> zur\xFCck."}else{msg="<code>digitLength(1)</code> gibt nicht <code>1</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>digitLength(1)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=digitLength(709);ok=result===3;if(ok){msg="<code>digitLength(709)</code> gibt <code>3</code> zur\xFCck."}else{msg="<code>digitLength(709)</code> gibt nicht <code>3</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>digitLength(709)</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"parameter",title:"Parameter",lesson:"Jetzt lernen wir Funktionen mit Parametern kennen. Mit <pre><code>var gebe = function(eingabe) {<br>  return eingabe;<br>};</code></pre>"+"definieren wir eine Funktion, die den \xFCbergebenen Parameter <code>eingabe</code> einfach wieder zur\xFCckgibt. "+"Parameter sind Variablen. Sie stehen in der runden Klammer und ben\xF6tigen nicht das Schl\xFCsselwort <code>var</code> zu ihrer Deklaration. "+"Mit <pre><code>var ergebnis = gebe(\"Apfel\");</code></pre>"+"wird die Funktion mit dem Argument <code>\"Apfel\"</code> aufgerufen. Jetzt wird unsere zuvor definierte Funktion "+"ausgef\xFChrt. Dabei wird zun\xE4chst das Argument <code>\"Apfel\"</code> dem Parameter <code>eingabe</code> zugewiesen. <code>eingabe</code> hat jetzt den "+"Wert <code>\"Apfel\"</code>. In der einzigen Codezeile der Funktion wird nun die Variable <code>eingabe</code> mit der "+"<code>return</code>-Anweisung zur\xFCckgegeben. Diese R\xFCckgabe wird der Variablen <code>ergebnis</code> zugewiesen. <code>ergebnis</code> hat "+"dann auch den Wert <code>\"Apfel\"</code>.",task:"Schreibe eine Funktion <code>echo</code>, die ebenfalls den \xFCbergebenen Parameter wieder zur\xFCckgibt.",beforeTests:function(){if(typeof echo!=="undefined"){echo=undefined}},tests:[function(){var ok=typeof echo==="function";var msg;if(ok){msg="<code>echo</code> ist eine Funktion."}else{msg="<code>echo</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var result=echo.length;var ok=result===1;var msg;if(ok){msg="<code>echo</code> hat genau 1 Parameter."}else{msg="<code>echo</code> hat nicht 1, sondern "+result+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=echo("Hallo Welt!");ok=result==="Hallo Welt!";if(ok){msg="<code>echo(\"Hallo Welt!\")</code> gibt <code>\"Hallo Welt!\"</code> zur\xFCck."}else{msg="<code>echo(\"Hallo Welt!\")</code> gibt nicht <code>\"Hallo Welt!\"</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>echo(\"Hallo Welt!\")</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=echo("Franz");ok=result==="Franz";if(ok){msg="<code>echo(\"Franz\")</code> gibt <code>\"Franz\"</code> zur\xFCck."}else{msg="<code>echo(\"Franz\")</code> gibt nicht <code>\"Franz\"</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>echo(\"Franz\")</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"parameter2",title:"Parameternamen",lesson:"Bitte achte darauf, dass du eventuelle Parameter deiner Funktion anders nennst als die Funktion selbst.\n  Die Funktion <code>f1</code> zum Beispiel\n\n<pre><code>var f1 = function(f1) {\n  return f1;\n};</code></pre>\n\n  macht das gleiche wie diese Funktion:\n\n<pre><code>var f2 = function(eingabe) {\n  return eingabe;\n};</code></pre>\n\n  Die zweite Funktionsdefinition ist aber besser, weil der Parameter <code>eingabe</code> hei\xDFt\n  und damit anders als die Funktion selbst.\n  ",task:"Schreibe eine Funktion <code>echo</code>, die einen Parameter hat und dessen Wert einfach zur\xFCckgibt.\n  Achte darauf, dass der Parameter anders hei\xDFt, als die Funktion selbst.\n  ",beforeTests:function(){echo=undefined},tests:[function(){return jshero.testutil.assert_de_isFunction("echo")},function(){var result=echo.length;var ok=result===1;var msg;if(ok){msg="<code>echo</code> hat genau 1 Parameter."}else{msg="<code>echo</code> hat nicht 1, sondern "+result+" Parameter."}return{ok:ok,msg:msg}},function(){return jshero.testutil.assert_de_functionReturns("echo(\"Test\")","Test")},function(){return jshero.testutil.assert_de_functionReturns("echo(\"Hallo Welt!\")","Hallo Welt!")}]});
jshero.koans.add({id:"parseint",title:"parseInt",lesson:"H\xE4ufig m\xF6chte man eine Zahl, die als String vorliegt, in eine Zahl vom Typ Number umwandeln. "+"F\xFCr das Umwandeln von ganzen Zahlen (..., -2, -1, 0, 1, 2, ..) gibt es in JavaScript die Funktion <code>parseInt</code>. "+"Folgende Beispiele geben <code>19</code> oder <code>-19</code> zur\xFCck: "+"<pre><code>"+"var n1 = parseInt(\"19\", 10);<br>"+"var n2 = parseInt(\"+19\", 10);<br>"+"var n3 = parseInt(\"-19\", 10);<br>"+"var n4 = parseInt(\"19 Grad\", 10);<br>"+"var n5 = parseInt(\"19.1\", 10);<br>"+"var n6 = parseInt(\"019\", 10);<br>"+"var n7 = parseInt(\" 19\", 10);<br>"+"</code></pre>"+"Neben dem direkten Einlesen von ganzen Zahlen mit oder ohne Vorzeichen (n1, n2, n3) beherrscht <code>parseInt</code> auch einige komplexe F\xE4lle. Nicht-numerische Zeichen nach "+"der ganzen Zahl (n4, n5) sowie Nullen (n6) und Leerzeichen (n7) vor der Zahl werden ignoriert.<br><br>"+"In allen Beispielen ist der zweite an <code>parseInt</code> \xFCbergebene Parameter <code>10</code>. Dieser Paramter gibt an, zu welcher Basis die Zahl "+"interpretiert werden soll. <code>10</code> steht f\xFCr das \xFCbliche Dezimalsystem. L\xE4\xDFt man den zweiten Paramter weg, wird normalerweise das Dezimalsystem als Default verwendet. "+"Da es aber von dieser Regel Ausnahmen gibt und diese Ausnahmen in verschiedenen Browsern auch noch unterschiedlich gehandhabt werden, sollte man immer die Basis mit angeben!<br><br>"+"Kann <code>parseInt</code> keine Zahl einlesen, gibt sie den Wert <code>NaN</code> (engl.: Not a Number) zur\xFCck:"+"<pre><code>"+"var n1 = parseInt(\"Nur Text\", 10);<br>"+"var n2 = parseInt(\"Nr. 8\", 10);<br>"+"</code></pre>"+"Im ersten Fall ist \xFCberhaupt keine Zahl vorhanden. Im zweiten Fall gibt es nicht-numerische Zeichen vor der eigentlichen Zahl. Auch das ist nicht zul\xE4ssig und f\xFChrt zur R\xFCckgabe "+"<code>NaN</code>.",task:"Schreibe eine Funktion <code>add</code>, die einen String mit einer Additionsaufgabe entgegennimmt und die das Ergebnis der Addition als Zahl zur\xFCckgibt. "+"Es sollen zwei nat\xFCrliche Zahlen addiert werden. Die Additionsaufgabe ist ein String der Form \"zahl1+zahl2\". So soll <code>add(\"100+19\")</code> die Zahl <code>119</code> zur\xFCckgeben.",beforeTests:function(){if(typeof add!=="undefined"){add=undefined}},tests:[function(){var ok=typeof add==="function";var msg;if(ok){msg="<code>add</code> ist eine Funktion."}else{msg="<code>add</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok=add.length===1;var msg;if(ok){msg="<code>add</code> hat 1 Parameter."}else{msg="<code>add</code> hat nicht 1, sondern "+add.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=add("1+2");ok=result===3;if(ok){msg="<code>add(\"1+2\")</code> ergibt <code>3</code>."}else{msg="<code>add(\"1+2\")</code> ergibt nicht <code>3</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>add(\"1+2\")</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=add("100123+456");ok=result===100579;if(ok){msg="<code>add(\"100123+456\")</code> ergibt <code>100579</code>."}else{msg="<code>add(\"100123+456\")</code> ergibt nicht <code>100579</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>add(\"100123+456\")</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"pi",title:"Math.PI",lesson:"Neben Funktionen bietet <code>Math</code> auch einige mathematische Konstanten an. "+"<code>Math.PI</code> liefert die Kreiszahl &pi; (gerundet 3.14) und <code>Math.E</code> die Eulersche Zahl e (gerundet 2.71). "+"Beachte: Die Konstanten werden im Gegensatz zu Funktionen ohne anschlie\xDFende Klammern aufgerufen.",task:"Schreibe eine Funktion <code>flaeche</code>, die die Fl\xE4che eines Kreises berechnet. "+"\xDCbergeben wird der Funktion als Parameter der Radius des Kreises. Tipp: Die Fl\xE4che eines Kreises ist &pi; * r&sup2;. "+"Dabei ist r der Radius des Kreises.",beforeTests:function(){if(typeof flaeche!=="undefined"){flaeche=undefined}},tests:[function(){var ok=typeof flaeche==="function";var msg;if(ok){msg="<code>flaeche</code> ist eine Funktion."}else{msg="<code>flaeche</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok=flaeche.length===1;var msg;if(ok){msg="<code>flaeche</code> hat einen Parameter."}else{msg="<code>flaeche</code> hat nicht 1, sondern "+flaeche.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=flaeche(1);ok=result===Math.PI;if(ok){msg="<code>flaeche(1)</code> ergibt <code>"+Math.PI+"</code>."}else{msg="<code>flaeche(1)</code> ergibt nicht <code>"+Math.PI+"</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>flaeche(1)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=flaeche(2);ok=result===Math.PI*4;if(ok){msg="<code>flaeche(2)</code> ergibt <code>"+Math.PI*4+"</code>."}else{msg="<code>flaeche(2)</code> ergibt nicht <code>"+Math.PI*4+"</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>flaeche(2)</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
(function(){var isOneToSix=function(x){return x===1||x===2||x===3||x===4||x===5||x===6};jshero.koans.add({id:'random',title:'Zufallszahlen',lesson:'Mit <code>Math.random()</code> erzeugt man eine Pseudozufallszahl zwischen 0 (inklusive) und 1 (exklusive).'+'<pre><code>'+'var x = Math.random();'+'</code></pre>'+'<code>x</code> k\xF6nnte z.B. den Wert <code>0.6206372241429993</code> erhalten. Jeder Aufruf von <code>Math.random()</code> generiert eine neue Pseudozufallszahl. '+'Die Zahlen sind zwischen 0 und 1 gleichverteilt. Sie hei\xDFen Pseudozufallszahlen, weil sie zuf\xE4llig aussehen, aber dennoch berechnet werden. '+'M\xF6chte man Zufallszahlen in einem anderen Wertebereich oder mit einer anderen Verteilung erhalten, muss man die von <code>Math.random()</code> generierten Zahlen '+'geeignet umrechnen. Das soll jetzt gleich probiert werden.',task:'Schreibe eine Funktion <code>dice</code>, die wie ein W\xFCrfel eine Zufallszahl zwischen 1 und 6 zur\xFCckgibt.',beforeTests:function(){if(typeof dice!=='undefined'){dice=undefined}},tests:[function(){var ok=typeof dice==='function';var msg;if(ok){msg='<code>dice</code> ist eine Funktion.'}else{msg='<code>dice</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=dice.length===0;var msg;if(ok){msg='<code>dice</code> hat keinen Parameter.'}else{msg='<code>dice</code> hat nicht 0, sondern '+dice.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{ok=true;var result;for(var i=0;i<1000;i++){result=dice();if(!isOneToSix(result)){ok=false;break}}if(ok){msg='<code>dice()</code> gab bei 1000 Aufrufen nur nat\xFCrliche Zahlen zwischen <code>1</code> und <code>6</code> zur\xFCck.'}else{msg='<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>'+JSON.stringify(result)+'</code> zur\xFCck. Dies ist keine nat\xFCrliche Zahl zwischen <code>1</code> und <code>6</code>.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>dice()</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{ok=false;var result;for(var i=0;i<1000;i++){result=dice();if(result===1){ok=true;break}}if(ok){msg='<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>1</code> zur\xFCck.'}else{msg='<code>dice()</code> gab bei 1000 Aufrufen keine <code>1</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>dice()</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{ok=false;var result;for(var i=0;i<1000;i++){result=dice();if(result===2){ok=true;break}}if(ok){msg='<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>2</code> zur\xFCck.'}else{msg='<code>dice()</code> gab bei 1000 Aufrufen keine <code>2</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>dice()</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{ok=false;var result;for(var i=0;i<1000;i++){result=dice();if(result===3){ok=true;break}}if(ok){msg='<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>3</code> zur\xFCck.'}else{msg='<code>dice()</code> gab bei 1000 Aufrufen keine <code>3</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>dice()</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{ok=false;var result;for(var i=0;i<1000;i++){result=dice();if(result===4){ok=true;break}}if(ok){msg='<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>4</code> zur\xFCck.'}else{msg='<code>dice()</code> gab bei 1000 Aufrufen keine <code>4</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>dice()</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{ok=false;var result;for(var i=0;i<1000;i++){result=dice();if(result===5){ok=true;break}}if(ok){msg='<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>5</code> zur\xFCck.'}else{msg='<code>dice()</code> gab bei 1000 Aufrufen keine <code>5</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>dice()</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{ok=false;var result;for(var i=0;i<1000;i++){result=dice();if(result===6){ok=true;break}}if(ok){msg='<code>dice()</code> gab bei 1000 Aufrufen mindestens einmal <code>6</code> zur\xFCck.'}else{msg='<code>dice()</code> gab bei 1000 Aufrufen keine <code>6</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>dice()</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]})})();
jshero.koans.add({id:'replace',title:'String: replace()',lesson:'Die Methode <code>replace</code> ersetzt einen Teilstring durch einen anderen:'+'<pre><code>'+'var str = "Hallo Marcel!";<br>'+'var newstr = str.replace("Marcel", "Robert");'+'</code></pre>'+'"Marcel" wird durch "Robert" ersetzt. <code>newstr</code> hat also den Wert <code>"Hallo Robert!"</code>. '+'Der urspr\xFCngliche String bleibt unver\xE4ndert. Nur das erste Vorkommen wird ersetzt:'+'<pre><code>'+'var newname = "Peter".replace("e", "a");'+'</code></pre>'+'<code>newname</code> enth\xE4lt den Wert <code>"Pater"</code> und nicht <code>"Patar"</code>. Ein Spezialfall ergibt sich, wenn der ersetzende String '+'der Leerstring ist:'+'<pre><code>'+'var nurso = "sowie so".replace("wie", "");'+'</code></pre>'+'Der zu ersetzende String wird entfernt. <code>nurso</code> enth\xE4lt den Wert <code>"so so"</code>. Kommt der zu ersetzende String nicht vor, so wird der '+'urspr\xFCngliche String zur\xFCckgegeben.',task:'Schreibe eine Funktion <code>convert</code>, die einen Datumsstring in englischer Schreibweise (20-05-2017 oder 20/05/2017) in '+'deutsche Schreibweise (20.05.2017) umwandet. Sowohl <code>convert("20-05-2017")</code> als auch <code>convert("20/05/2017")</code> sollten <code>"20.05.2017"</code> ergeben.',beforeTests:function(){if(typeof convert!=='undefined'){convert=undefined}},tests:[function(){var ok=typeof convert==='function';var msg;if(ok){msg='<code>convert</code> ist eine Funktion.'}else{msg='<code>convert</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=convert.length===1;var msg;if(ok){msg='<code>convert</code> hat 1 Parameter.'}else{msg='<code>convert</code> hat nicht 1, sondern '+convert.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=convert('10-07-1871');ok=result==='10.07.1871';if(ok){msg='<code>convert("10-07-1871")</code> gibt <code>"10.07.1871"</code> zur\xFCck.'}else{msg='<code>convert("10-07-1871")</code> gibt nicht <code>"10.07.1871"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>convert("10-07-1871")</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=convert('18/11/1922');ok=result==='18.11.1922';if(ok){msg='<code>convert("18/11/1922")</code> gibt <code>"18.11.1922"</code> zur\xFCck.'}else{msg='<code>convert("18/11/1922")</code> gibt nicht <code>"18.11.1922"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>convert("18/11/1922")</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"round",title:"Runden",lesson:"M\xF6chte man eine Dezimalzahl auf- oder abrunden, stehen einem die Funktionen <code>Math.round()</code>, "+"<code>Math.floor()</code> (engl.: Boden) und <code>Math.ceil()</code> (engl: Decke) zur Verf\xFCgung."+"<pre><code>"+"var a = Math.round(5.49);<br>"+"var b = Math.round(4.5);<br>"+"var c = Math.floor(5.99);<br>"+"var d = Math.ceil(4.01);"+"</code></pre>"+"<code>Math.round()</code> rundet kaufm\xE4nnisch. Zahlen mit der ersten Dezimalstelle kleiner gleich 4 werden abgerundet, alle anderen aufgerundet. "+"<code>Math.floor()</code> rundet immer ab und <code>Math.ceil()</code> rundet immer auf. Die Variablen <code>a</code> bis <code>d</code> "+"werden also alle auf <code>5</code> gerundet.",task:"Schreibe eine Funktion <code>round100</code>, die eine Dezimalzahl kaufm\xE4nnisch auf die Hunderterstelle rundet. "+"<code>round100(1749)</code> sollte <code>1700</code> und <code>round100(856.123)</code> sollte <code>900</code> ergeben.<br>"+"Tipp: Verwende neben <code>Math.round()</code> noch Multiplikation und Division.",beforeTests:function(){if(typeof round100!=="undefined"){round100=undefined}},tests:[function(){var ok=typeof round100==="function";var msg;if(ok){msg="<code>round100</code> ist eine Funktion."}else{msg="<code>round100</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok=round100.length===1;var msg;if(ok){msg="<code>round100</code> hat einen Parameter."}else{msg="<code>round100</code> hat nicht 1, sondern "+round100.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=round100(49.999);ok=result===0;if(ok){msg="<code>round100(49.999)</code> ergibt <code>0</code>."}else{msg="<code>round100(49.999)</code> ergibt nicht <code>0</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>round100(49.999)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=round100(4650);ok=result===4700;if(ok){msg="<code>round100(4650)</code> ergibt <code>4700</code>."}else{msg="<code>round100(4650)</code> ergibt nicht <code>4700</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>round100(4650)</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"string",title:"Strings",lesson:"Wir haben gesehen, dass eine Variable ein Beh\xE4lter f\xFCr einen Wert ist. Werte besitzen dabei einen Typ. So kann ein Wert eine Zahl\n    wie <code>7.12</code> sein. Der Typ von <code>7.12</code> ist Zahl. Oder ein Wert kann ein Text wie <code>\"Hallo Welt!\"</code> sein.\n    Der Typ von <code>\"Hallo Welt!\"</code> ist Text. Diesen Typ\n    bezeichnet man auch als Zeichenkette oder String. Strings schreibt man immer in einfachen oder doppelten Anf\xFChrungszeichen. So ist \"Hallo Welt!\" derselbe String\n    wie 'Hallo Welt!'.<br>Mit Strings kann man arbeiten. Man kann sie zum Beispiel verketten. Dies macht man mit dem <code>+</code> Zeichen.\n    So liefert <code>\"Blau\" + \"meier\"</code> den String <code>\"Blaumeier\"</code>.<br>Die folgende Funktion h\xE4ngt an dem \xFCbergebenen Parameter einen Text an und\n    gibt den zusammengesetzten Text zur\xFCck: <pre><code>var lobe = function(name) {<br>  return name + \" ist toll!\";<br>};</code></pre>\n    So liefert <code>lobe(\"JavaScript\")</code> den Wert <code>\"JavaScript ist toll!\"</code>.",task:"Schreibe eine Funktion <code>begruesse</code>, die einen Parameter entgegennimmt und die <code>\"Hallo &lt;Parameter&gt;!\"</code> zur\xFCckgibt.\n    \xDCbergibt man der Funktion <code>\"Maria\"</code>, so sollte die Funktion <code>\"Hallo Maria!\"</code> zur\xFCckgeben. \xDCbergibt man der Funktion <code>\"Franz\"</code>,\n    so sollte die R\xFCckgabe <code>\"Hallo Franz!\"</code> sein.",beforeTests:function(){begruesse=undefined},tests:[function(){return jshero.testutil.assert_de_isFunction("begruesse")},function(){var ok=begruesse.length===1;var msg;if(ok){msg="<code>begruesse</code> hat 1 Parameter."}else{msg="<code>begruesse</code> hat nicht 1, sondern "+begruesse.length+" Parameter."}return{ok:ok,msg:msg}},function(){return jshero.testutil.assert_de_functionReturns("begruesse(\"Maria\")","Hallo Maria!")},function(){return jshero.testutil.assert_de_functionReturns("begruesse(\"Franz\")","Hallo Franz!")}]});
jshero.koans.add({id:'stringcharat',title:'String: charAt()',lesson:'Um aus einem String das Zeichen an einer bestimmten Stelle zu erhalten, verwendet man die Methode '+'<code>charAt(index)</code>. Der Paramter <code>index</code> gibt die Stelle des Zeichens innerhalb der Zeichenkette an. '+'Dabei hat das erste Zeichen einer Zeichenkette den Index 0:'+'<pre><code>var n1 = "Maria".charAt(0);<br>var n2 = "Maria".charAt(1);<br>var n3 = "Maria".charAt(5);<br>var n4 = "Maria".charAt();</code></pre>'+'<code>n1</code> hat den Wert <code>"M"</code> und <code>n2</code> hat den Wert <code>"a"</code>. Ist der Index gr\xF6\xDFer als der Index des letzten Zeichens, '+'wird der leere String zur\xFCckgegeben. <code>n3</code> hat also den Wert <code>""</code>. '+'Wird kein Parameter \xFCbergeben, so wird das Zeichen mit dem Index <code>0</code> zur\xFCckgegeben. Man sagt: der Default-Wert f\xFCr <code>index</code> '+'ist <code>0</code>. Der Wert von <code>n4</code> ist also auch <code>"M"</code>.',task:'Schreibe eine Funktion <code>abkuerzung</code>, die zwei Strings als Parameter entgegennimmt und als R\xFCckgabe die Anfangsbuchstaben '+'dieser Strings zur\xFCckgibt. <code>abkuerzung("Hansestadt", "Bremen")</code> sollte <code>"HB"</code> zur\xFCckliefern.',beforeTests:function(){if(typeof abkuerzung!=='undefined'){abkuerzung=undefined}},tests:[function(){var ok=typeof abkuerzung==='function';var msg;if(ok){msg='<code>abkuerzung</code> ist eine Funktion.'}else{msg='<code>abkuerzung</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=abkuerzung.length===2;var msg;if(ok){msg='<code>abkuerzung</code> hat zwei Parameter.'}else{msg='<code>abkuerzung</code> hat nicht 2, sondern '+abkuerzung.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=abkuerzung('Hansestadt','Bremen');ok=result==='HB';if(ok){msg='<code>abkuerzung("Hansestadt", "Bremen")</code> gibt <code>"HB"</code> zur\xFCck.'}else{msg='<code>abkuerzung("Hansestadt", "Bremen")</code> gibt nicht <code>"HB"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){e=exc;ok=false;msg='Fehler beim Aufruf von <code>abkuerzung("Hansestadt", "Bremen")</code>.'}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=abkuerzung('Java','Script');ok=result==='JS';if(ok){msg='<code>abkuerzung("Java", "Script")</code> gibt <code>"JS"</code> zur\xFCck.'}else{msg='<code>abkuerzung("Java", "Script")</code> gibt nicht <code>"JS"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>abkuerzung("Java", "Script")</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'stringindexof',title:'String: indexOf()',lesson:'Um die Position eines Strings innerhalb eines anderen Strings zu bestimmen, verwendet man die Methode <code>indexOf</code>:'+'<pre><code>'+'var n1 = "Fred Feuerstein".indexOf("Feuer");<br>'+'var n2 = "Fred Feuerstein".indexOf("Rauch");<br>'+'var n3 = "Fred Feuerstein".indexOf("FEUER");<br>'+'</code></pre>'+'<code>n1</code> ist <code>5</code>, da <code>"Feuer"</code> in <code>"Fred Feuerstein"</code> an der 5. Stelle beginnt. Wie \xFCblich werden Strings von 0 an durchnummeriert. '+'Kommt das Suchwort im aufrufenden String nicht vor, wird <code>-1</code> zur\xFCckgegeben. <code>n2</code> ist also <code>-1</code>. '+'Die Methode <code>indexOf()</code> unterscheidet zwischen Gro\xDF- und Kleinschreibung. <code>n3</code> ist also auch <code>-1</code>.',task:'Schreibe eine Funktion <code>indexOfIgnoreCase</code>, die 2 Strings entgegennimmt und wie die Methode <code>indexOf</code> die Position des '+'zweiten Strings im ersten String bestimmt. Im Unterschied zur Methode <code>indexOf</code> soll die Gro\xDF- oder Kleinschreibung keine Rolle spielen. '+'Sowohl <code>indexOfIgnoreCase("So", "so")</code> als auch <code>indexOfIgnoreCase("so", "So")</code> sollen <code>0</code> ergeben.',beforeTests:function(){if(typeof indexOfIgnoreCase!=='undefined'){indexOfIgnoreCase=undefined}},tests:[function(){var ok=typeof indexOfIgnoreCase==='function';var msg;if(ok){msg='<code>indexOfIgnoreCase</code> ist eine Funktion.'}else{msg='<code>indexOfIgnoreCase</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=indexOfIgnoreCase.length===2;var msg;if(ok){msg='<code>indexOfIgnoreCase</code> hat 2 Parameter.'}else{msg='<code>indexOfIgnoreCase</code> hat nicht 2, sondern '+indexOfIgnoreCase.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=indexOfIgnoreCase('Fred Feuerstein','FEUER');ok=result===5;if(ok){msg='<code>indexOfIgnoreCase("Fred Feuerstein", "FEUER")</code> gibt <code>5</code> zur\xFCck.'}else{msg='<code>indexOfIgnoreCase("Fred Feuerstein", "FEUER")</code> gibt nicht <code>5</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>indexOfIgnoreCase("Fred Feuerstein", "FEUER")</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=indexOfIgnoreCase('WILMA FEUERSTEIN','feuer');ok=result===6;if(ok){msg='<code>indexOfIgnoreCase("WILMA FEUERSTEIN", "feuer")</code> gibt <code>6</code> zur\xFCck.'}else{msg='<code>indexOfIgnoreCase("WILMA FEUERSTEIN", "feuer")</code> gibt nicht <code>6</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>indexOfIgnoreCase("WILMA FEUERSTEIN", "feuer")</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'stringindexof2',title:'String: indexOf(), 2. Parameter',lesson:'Der Methode <code>indexOf</code> kann man als zweiten Parameter noch die Stelle mitgeben, ab der der Suchstring im aufrufenden String gesucht werden soll.\n    <pre><code>var n1 = "Fred Feuerstein".indexOf("e", 2);\nvar n2 = "Fred Feuerstein".indexOf("e", 3);\nvar n3 = "Fred Feuerstein".indexOf("e", 7);</code></pre>\n    Das erste <code>"e"</code> befindet sich in <code>"Fred Feuerstein"</code> an 2. Stelle. Es wird bei einer Suche ab der 2. Stelle gefunden. <code>n1</code>\n    ist also 2. Das zweite <code>"e"</code> in <code>"Fred Feuerstein"</code> befindet sich an der 6. Stelle. Es wird bei der Suche ab der 3. Stelle gefunden.\n    <code>n2</code> ist <code>6</code>. Mit der dritten Codezeile wird das dritte <code>"e"</code> in <code>"Fred Feuerstein"</code> gefunden.\n    <code>n3</code> ist <code>8</code>.',task:'Schreibe eine Funktion <code>secondIndexOf</code>, die 2 Strings entgegennimmt und die zweite Position des\n    zweiten Strings im ersten String bestimmt. Kommt der Suchstring nicht zweimal vor, so soll <code>-1</code> zur\xFCckgegeben werden.\n    <code>secondIndexOf("Maria Maria", "Maria")</code> soll <code>6</code> zur\xFCckgeben.\n    <br/>Tipp: Falls Du nicht weiterkommst, lese dir auch die Beschreibung in\n    <a href="https://wiki.selfhtml.org/wiki/JavaScript/Objekte/String/indexOf">SELFHTML</a> durch.',beforeTests:function(){if(typeof secondIndexOf!=='undefined'){secondIndexOf=undefined}},tests:[function(){var ok=typeof secondIndexOf==='function';var msg;if(ok){msg='<code>secondIndexOf</code> ist eine Funktion.'}else{msg='<code>secondIndexOf</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=secondIndexOf.length===2;var msg;if(ok){msg='<code>secondIndexOf</code> hat 2 Parameter.'}else{msg='<code>secondIndexOf</code> hat nicht 2, sondern '+secondIndexOf.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=secondIndexOf('Maria Maria','Maria');ok=result===6;if(ok){msg='<code>secondIndexOf("Maria Maria", "Maria")</code> gibt <code>6</code> zur\xFCck.'}else{msg='<code>secondIndexOf("Maria Maria", "Maria")</code> gibt nicht <code>6</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>secondIndexOf("Maria Maria", "Maria")</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=secondIndexOf('xxXX','X');ok=result===3;if(ok){msg='<code>secondIndexOf("xxXX", "X")</code> gibt <code>3</code> zur\xFCck.'}else{msg='<code>secondIndexOf("xxXX", "X")</code> gibt nicht <code>3</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>secondIndexOf("xxXX", "X")</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=secondIndexOf('O ja!','ja');ok=result===-1;if(ok){msg='<code>secondIndexOf("O ja!", "ja")</code> gibt <code>-1</code> zur\xFCck.'}else{msg='<code>secondIndexOf("O ja!", "ja")</code> gibt nicht <code>-1</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>secondIndexOf("O ja!", "ja")</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:"stringlength",title:"String: length",lesson:"Strings besitzen die Eigenschaft <code>length</code>. Diese Eigenschaft liefert die Anzahl der Zeichen eines Strings. "+"Dazu muss man dem String  oder der Variablen, die den String enth\xE4lt, <code>.length</code> anh\xE4ngen:"+"<pre><code>var anzahl = \"Franz\".length;</code/></pre>"+"<code>\"Franz\"</code> hat 5 Zeichen. Also hat <code>anzahl</code> jetzt den Wert <code>5</code>."+"<pre><code>var stadt = \"Prag\";<br>anzahl = stadt.length;</code/></pre>"+"<code>\"Prag\"</code> hat 4 Zeichen. <code>anzahl</code> hat jetzt den Wert <code>4</code>."+"<pre><code>anzahl = \"\".length;</code/></pre>"+"Der Leerstring besitzt keine Zeichen. Der Wert von <code>anzahl</code> ist jetzt <code>0</code>.",task:"Schreibe eine Funktion <code>laenge</code>, die bei \xDCbergabe eines Strings die Anzahl der Zeichen dieses Strings zur\xFCckgibt. "+"<code>laenge(\"Franz\")</code> sollte <code>5</code> zur\xFCckgeben.",beforeTests:function(){if(typeof laenge!=="undefined"){laenge=undefined}},tests:[function(){var ok=typeof laenge==="function";var msg;if(ok){msg="<code>laenge</code> ist eine Funktion."}else{msg="<code>laenge</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var result=laenge.length;var ok=result===1;var msg;if(ok){msg="<code>laenge</code> hat genau 1 Parameter."}else{msg="<code>laenge</code> hat nicht 1, sondern "+result+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=laenge("Hallo Welt!");ok=result===11;if(ok){msg="<code>laenge(\"Hallo Welt!\")</code> gibt <code>11</code> zur\xFCck."}else{msg="<code>laenge(\"Hallo Welt!\")</code> gibt nicht <code>11</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>laenge(\"Hallo Welt!\")</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=laenge("");ok=result===0;if(ok){msg="<code>laenge(\"\")</code> gibt <code>0</code> zur\xFCck."}else{msg="<code>laenge(\"\")</code> gibt nicht <code>0</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>laenge(\"\")</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'stringsplit',title:'String: split()',lesson:'Die Methode <code>split</code> zerlegt einen String anhand eines Trennstrings in Teilstrings. Die Teilstrings werden als Array zur\xFCckgegeben. '+'Der urspr\xFCngliche String wird nicht ver\xE4ndert.'+'<pre><code>'+'var date = "31-10-2017";<br>'+'var parts = date.split("-");<br>'+'var day = parts[0]; // "31"<br>'+'var month = parts[1]; // "10"<br>'+'var year = parts[2]; // "2017"<br>'+'</code></pre>'+'Der Trennstring ist hier der Bindestrich. Er zerlegt den Datumsstring in drei Teile. Diese drei Teile werden als Array der Variablen <code>parts</code> zugewiesen. '+'Anschlie\xDFend werden die einzelnen Teile aus dem Array ausgelesen und gesonderten Variablen zugewiesen. Die Variable <code>date</code> hat weiterhin den Wert <code>"31-10-2017"</code>.',task:'Schreibe eine Funktion <code>add</code>, die einen String mit einer Additionsaufgabe entgegennimmt und die das Ergebnis der Addition als Zahl zur\xFCckgibt. '+'Es sollen endlich viele nat\xFCrliche Zahlen addiert werden. Die Additionsaufgabe ist ein String der Form "1+19+...+281". '+'So soll <code>add("7+12+100")</code> die Zahl <code>119</code> zur\xFCckgeben.',beforeTests:function(){if(typeof hallo!=='undefined'){hallo=undefined}},tests:[function(){var ok=typeof add==='function';var msg;if(ok){msg='<code>add</code> ist eine Funktion.'}else{msg='<code>add</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=add.length===1;var msg;if(ok){msg='<code>add</code> hat 1 Parameter.'}else{msg='<code>add</code> hat nicht 1, sondern '+add.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=add('1+2');ok=result===3;if(ok){msg='<code>add("1+2")</code> gibt <code>3</code> zur\xFCck.'}else{msg='<code>add("1+2")</code> gibt nicht <code>3</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>add("1+2")</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=add('50000+4000+300+20+1');ok=result===54321;if(ok){msg='<code>add("50000+4000+300+20+1")</code> gibt <code>54321</code> zur\xFCck.'}else{msg='<code>add("50000+4000+300+20+1")</code> gibt nicht <code>54321</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>add("50000+4000+300+20+1")</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'stringsubstr',title:'String: substr()',lesson:'Die Methode <code>substr</code> extrahiert aus einen String einen Teilstring:'+'<pre><code>'+'var see = "see and stop".substr(0, 3);<br>'+'var and = "see and stop".substr(4, 3);<br>'+'var stop = "see and stop".substr(8);<br>'+'</code></pre>'+'Der erste Parameter gibt an, von welcher Stelle an der Substring extrahiert werden soll. Der zweite Parameter gibt an, wieviel Zeichen ab der festgelegten Stelle extrahiert werden sollen. '+'Ist der zweite Paramter nicht angegeben, so wird immer bis zum Ende des urspr\xFCglichen Strings extrahiert.',task:'Schreibe eine Funktion <code>firstWord</code>, die einen String entgegennimmt und das erste Wort in diesem String zur\xFCckgibt. Das erste Wort sind dabei alle Zeichen bis zum '+'ersten Leerzeichen. <code>firstWord("Wo ist hier")</code> sollte <code>"Wo"</code> zur\xFCckgeben.',beforeTests:function(){if(typeof firstWord!=='undefined'){firstWord=undefined}},tests:[function(){var ok=typeof firstWord==='function';var msg;if(ok){msg='<code>firstWord</code> ist eine Funktion.'}else{msg='<code>firstWord</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=firstWord.length===1;var msg;if(ok){msg='<code>firstWord</code> hat 1 Parameter.'}else{msg='<code>firstWord</code> hat nicht 1, sondern '+firstWord.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=firstWord('Wo ist hier');ok=result==='Wo';if(ok){msg='<code>firstWord("Wo ist hier")</code> gibt <code>"Wo"</code> zur\xFCck.'}else{msg='<code>firstWord("Wo ist hier")</code> gibt nicht <code>"Wo"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>firstWord("Wo ist hier")</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=firstWord('Irres Licht');ok=result==='Irres';if(ok){msg='<code>firstWord("Irres Licht")</code> gibt <code>"Irres"</code> zur\xFCck.'}else{msg='<code>firstWord("Irres Licht")</code> gibt nicht <code>"Irres"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>firstWord("Irres Licht")</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'stringupper',title:'String: toUpperCase()',lesson:'Neben der Eigenschaft <code>length</code> besitzen Strings noch eine Reihe von Methoden. Das sind Funktionen, die direkt auf dem String angewendet werden. '+'Wie die Eigenschaft <code>length</code> werden diese Methoden mit einem Punkt direkt dem String oder einer Variablen, die einen String enth\xE4lt, angeh\xE4ngt. '+'Da Methoden Funktionen sind, folgen in runden Klammern eingeschlossen die Argumente. '+'Zwei dieser String-Methoden sind die parameterlosen Methoden <code>toUpperCase</code> und <code>toLowerCase</code>. '+'Sie geben den String, auf dem sie angewendet werden, in Gro\xDF- bzw. Kleinbuchstaben zur\xFCck. Wichtig ist, dass der eigentliche String unver\xE4ndert bleibt. '+'Die R\xFCckgabe dieser Methoden ist der in Gro\xDF- bzw. Kleinbuchstaben umgewandelte String.'+'<pre><code>var stadt = "Prag";<br>var ausgabe = stadt.toUpperCase();</code/></pre>'+'<code>ausgabe</code> erh\xE4lt den Wert <code>"PRAG"</code>. <code>stadt</code> hat weiterhin den Wert <code>"Prag"</code>.'+'<pre><code>ausgabe = stadt.toLowerCase();</code/></pre>'+'Jetzt hat <code>ausgabe</code> den Wert <code>"prag"</code>.'+'<pre><code>ausgabe = "Flug 714".toUpperCase();</code/></pre>'+'Hier wird <code>toUpperCase()</code> direkt auf einen String angewendet. Der Wert von <code>ausgabe</code> ist <code>"FLUG 714"</code>. '+'Zahlen und auch Sonderzeichen werden nicht ver\xE4ndert.',task:'Schreibe eine Funktion <code>toCase</code>, die bei \xDCbergabe eines Strings diesen aneinandergeh\xE4ngt in Klein- und in Gro\xDFschreibung zur\xFCckgibt. '+'Das Trennzeichen zwischen der Klein- und Gro\xDFschreibung soll <code>-</code> sein. '+'<code>toCase("Code")</code> sollte <code>"code-CODE"</code> zur\xFCckgeben.',beforeTests:function(){if(typeof toCase!=='undefined'){toCase=undefined}},tests:[function(){var ok=typeof toCase==='function';var msg;if(ok){msg='<code>toCase</code> ist eine Funktion.'}else{msg='<code>toCase</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var result=toCase.length;var ok=result===1;var msg;if(ok){msg='<code>toCase</code> hat genau 1 Parameter.'}else{msg='<code>toCase</code> hat nicht 1, sondern '+result+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=toCase('Code');ok=result==='code-CODE';if(ok){msg='<code>toCase("Code")</code> gibt <code>"code-CODE"</code> zur\xFCck.'}else{msg='<code>toCase("Code")</code> gibt nicht <code>"code-CODE"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>toCase("Code")</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=toCase('Maria');ok=result==='maria-MARIA';if(ok){msg='<code>toCase("Maria")</code> gibt <code>"maria-MARIA"</code> zur\xFCck.'}else{msg='<code>toCase("Maria")</code> gibt nicht <code>"maria-MARIA"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>toCase("Maria")</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]});
jshero.koans.add({id:'subfunction',title:'Funktionen benutzen Funktionen',lesson:'Funktionen k\xF6nnen weitere Funktionen aufrufen:'+'<pre><code>'+'var brutto = function(netto) {<br>'+'  var steuersatz = 19;<br>'+'  var steuer = netto * steuersatz / 100;<br>'+'  return netto + steuer;<br>'+'};<br><br>'+'var addiereMitMehrwertsteuer = function(nettoX, nettoY) {<br>'+'  var bruttoX = brutto(nettoX);<br>'+'  var bruttoY = brutto(nettoY);<br>'+'  return bruttoX + bruttoY;<br>'+'};</code></pre>'+'<code>addiereMitMehrwertsteuer</code> nimmt 2 Nettobetr\xE4ge entgegen und gibt die Summe der Bruttobetr\xE4ge zur\xFCck. <code>brutto</code> '+'berechnet aus einem Nettobetrag den Bruttobetrag. Dabei wird eine Mehrwertsteuer von 19% zugrunde gelegt. '+'Anstatt den Bruttobetrag selbst zu berechnen, ruft <code>addiereMitMehrwertsteuer</code> die Funktion '+'<code>brutto</code> auf. Das hat zwei Vorteile: Der Code ist besser lesbar und die Bruttoberechnung wird zentral an einer Stelle durchgef\xFChrt.',task:'Schreibe eine Funktion <code>sum</code>, die ein Array gef\xFCllt mit Zahlen entgegennimmt und die Summe dieser Zahlen zur\xFCckgibt. '+'Schreibe eine Funktion <code>mean</code>, die ein Array gef\xFCllt mit Zahlen entgegennimmt und den Mittelwert dieser Zahlen zur\xFCckgibt. '+'Die Funktion <code>mean</code> soll dabei die Funktion <code>sum</code> benutzen.',beforeTests:function(){if(typeof sum!=='undefined'){mean=undefined}if(typeof mean!=='undefined'){mean=undefined}},tests:[// sum
function(){var ok=typeof sum==='function';var msg;if(ok){msg='<code>sum</code> ist eine Funktion.'}else{msg='<code>sum</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=sum.length===1;var msg;if(ok){msg='<code>sum</code> hat 1 Parameter.'}else{msg='<code>sum</code> hat nicht 1, sondern '+sum.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=sum([0]);ok=result===0;if(ok){msg='<code>sum([0])</code> gibt <code>0</code> zur\xFCck.'}else{msg='<code>sum([0])</code> gibt nicht <code>0</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>sum([0])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=sum([1,2,3]);ok=result===6;if(ok){msg='<code>sum([1, 2, 3])</code> gibt <code>6</code> zur\xFCck.'}else{msg='<code>sum([1, 2, 3])</code> gibt nicht <code>6</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>sum([1, 2, 3])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},// mean
function(){var ok=typeof mean==='function';var msg;if(ok){msg='<code>mean</code> ist eine Funktion.'}else{msg='<code>mean</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=mean.length===1;var msg;if(ok){msg='<code>mean</code> hat 1 Parameter.'}else{msg='<code>mean</code> hat nicht 1, sondern '+mean.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=mean([0]);ok=result===0;if(ok){msg='<code>mean([0])</code> gibt <code>0</code> zur\xFCck.'}else{msg='<code>mean([0])</code> gibt nicht <code>0</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>mean([0])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=mean([1,2,9]);ok=result===4;if(ok){msg='<code>mean([1, 2, 9])</code> gibt <code>4</code> zur\xFCck.'}else{msg='<code>mean([1, 2, 9])</code> gibt nicht <code>4</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>mean([1, 2, 9])</code>.';e=exc}return{ok:ok,msg:msg,e:e}},// mean calls sum
function(){var msg,e;var sumIsCalled=false;var oldSum=sum;sum=function(x){sumIsCalled=true;return oldSum(x)};mean([1,2,9]);try{if(sumIsCalled){msg='<code>mean</code> ruft <code>sum</code> auf.'}else{msg='<code>mean</code> ruft nicht <code>sum</code> auf.'}}catch(exc){sumIsCalled=false;msg='Fehler beim Aufruf von <code>mean([1, 2, 9])</code>.';e=exc}return{ok:sumIsCalled,msg:msg,e:e}}]});
jshero.koans.add({id:"trim",title:"String: trim()",lesson:"Die Methode <code>trim</code> entfernt Leerzeichen an beiden Enden eines Strings. Der an den Enden um Leerzeichen bereinigte String wird zur\xFCckgegeben. "+"Der urspr\xFCgliche String bleibt unver\xE4ndert."+"<pre><code>"+"var eingabe = \" Rosa Parks \";<br>"+"var name = eingabe.trim();"+"</code></pre>"+"<code>name</code> enth\xE4lt den String <code>\"Rosa Parks\"</code>. Wie angedeutet werden h\xE4ufig Benutzereingaben vor der Verarbeitung getrimmt.",task:"Schreibe eine Funktion <code>firstChar</code>, die bei \xDCbergabe eines Strings das erste Zeichen, das kein Leerzeichen ist, zur\xFCckgibt. "+"<code>firstChar(\" Rosa\")</code> sollte <code>\"R\"</code> zur\xFCckgeben.",beforeTests:function(){if(typeof firstChar!=="undefined"){firstChar=undefined}},tests:[function(){var ok=typeof firstChar==="function";var msg;if(ok){msg="<code>firstChar</code> ist eine Funktion."}else{msg="<code>firstChar</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var result=firstChar.length;var ok=result===1;var msg;if(ok){msg="<code>firstChar</code> hat genau 1 Parameter."}else{msg="<code>firstChar</code> hat nicht 1, sondern "+result+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=firstChar(" Rosa");ok=result==="R";if(ok){msg="<code>firstChar(\" Rosa\")</code> gibt <code>\"R\"</code> zur\xFCck."}else{msg="<code>firstChar(\" Rosa\")</code> gibt nicht <code>\"R\"</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>firstChar(\" Rosa\")</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=firstChar("Parks");ok=result==="P";if(ok){msg="<code>firstChar(\"Parks\")</code> gibt <code>\"P\"</code> zur\xFCck."}else{msg="<code>firstChar(\"Parks\")</code> gibt nicht <code>\"P\"</code>, sondern <code>"+JSON.stringify(result)+"</code> zur\xFCck."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>firstChar(\"Parks\")</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
(function(dateUtil){jshero.koans.add({id:'undefined',title:'undefined',lesson:'Bisher hatten wir Variablen bei der Deklaration immer auch initialisiert.'+'<pre><code>'+'// Deklaration und Initialisierung<br>'+'var x = 1;'+'</code></pre>'+'Man kann eine Varialbe aber auch deklarieren und ihr sp\xE4ter einen Wert zuweisen.'+'<pre><code>'+'var x; // Deklaration<br>'+'x = 1; // Initialisierung'+'</code></pre>'+'Variablen, die nicht initialisiert wurden, haben den Wert <code>undefined</code> (engl.: nicht definiert). '+'In der Praxis kommt das bei Funktionsaufrufen am h\xE4ufigsten vor. Ruft man eine Funktion, die einen Parameter erwartet, ohne Argument auf, '+'dann erh\xE4lt der Funktionsparameter den Wert <code>undefined</code>.'+'<pre><code>'+'var echo = function(x) {<br>'+'  return x;<br>'+'};<br>'+'// Aufruf ohne Argument<br>'+'var y = echo();'+'</code></pre>'+'<code>echo</code> wird ohne Argument aufgerufen. Dem Parameter <code>x</code> wird so kein Wert zugewiesen, er erh\xE4lt den Wert <code>undefined</code>. '+'Da <code>echo</code> den Parameter <code>x</code> einfach nur zur\xFCckgibt, erh\xE4lt auch <code>y</code> den Wert <code>undefined</code>. <br><br>'+'Eine Funktion, die einen Parameter erwartet, kann immer auch ohne Argument aufgerufen werden. Man sollte sich beim Schreiben von Funktionen also immer \xFCberlegen, '+'was in diesem Fall passieren soll. Gute Praxis ist es, in einem solchen Fall dem Parameter einen Default-Wert (engl.: Vorgabe) zuzuweisen. '+'Das hatten wir schon bei der String-Methode <code>charAt(index)</code> kennen gelernt. Normalerweise gibt diese Methode den Buchstaben an der Stelle <code>index</code> '+'zur\xFCck. Rufen wir <code>charAt</code> ohne Argument auf, erh\xE4lt <code>index</code> den Default <code>0</code>. Es wird der Buchstabe an der Stelle <code>0</code> zur\xFCckgegeben. '+'Um eine Varaible auf <code>undefined</code> zu \xFCberpr\xFCfen, verwendet man wie \xFCblich die strikte Gleichkeit. Die Methode <code>charAt</code> k\xF6nnte also folgenden Code-Ausschnitt enthalten:'+'<pre><code>'+'if (index === undefined) {<br>'+'  index = 0;<br>'+'}<br>'+'</code></pre>',task:'Schreibe eine Funktion <code>hallo</code>, die einen String als Parameter entgegennimmt und <code>"Hallo &lt;Parameter&gt;!"</code> zur\xFCckgibt. '+'<code>hallo("Akg\xFCn")</code> sollte <code>"Hallo Akg\xFCn!"</code> zur\xFCckgeben. Wird <code>hallo</code> ohne Argument aufgerufen, so soll <code>"Hallo Welt!"</code> zur\xFCckgegeben werden.',beforeTests:function(){if(typeof hallo!=='undefined'){hallo=undefined}},tests:[function(){var ok=typeof hallo==='function';var msg;if(ok){msg='<code>hallo</code> ist eine Funktion.'}else{msg='<code>hallo</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=hallo.length===1;var msg;if(ok){msg='<code>hallo</code> hat 1 Parameter.'}else{msg='<code>hallo</code> hat nicht 1, sondern '+hallo.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=hallo();ok=result==='Hallo Welt!';if(ok){msg='<code>hallo()</code> gibt <code>"Hallo Welt!"</code> zur\xFCck.'}else{msg='<code>hallo()</code> gibt nicht <code>"Hallo Welt!"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>hallo()</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=hallo('Melek');ok=result==='Hallo Melek!';if(ok){msg='<code>hallo("Melek")</code> gibt <code>"Hallo Melek!"</code> zur\xFCck.'}else{msg='<code>hallo("Melek")</code> gibt nicht <code>"Hallo Melek!"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>hallo("Melek")</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]})})(jshero.date);
jshero.koans.add({id:"var",title:"Variablen",lesson:"JavaScript-Programme bestehen aus einer Reihe von Anweisungen. Jede Anweisung f\xFChrt eine elementare Operation durch. "+"Durch das Ausf\xFChren vieler Anweisungen kann man schlie\xDFlich komplexe Aufgaben l\xF6sen. "+"Jede Anweisung schreibt man in eine Zeile und schlie\xDFt sie mit einem Semikolon ab.<br><br>"+"Eine elementare Anweisung ist die Deklaration und Initialisierung einer Variablen. "+"In der Programmierung ist eine Variable ein Beh\xE4lter f\xFCr einen Wert. "+"Mit der Anweisung "+"<pre><code>var stadt = \"Prag\";</code></pre>"+"deklariert man eine Variable mit dem Namen <code>stadt</code> und initialisiert sie mit dem Wert <code>\"Prag\"</code>. "+"Mit dem Schl\xFCsselwort <code>var</code> wird die Variable deklariert. "+"Mit dem Gleichheitszeichen, dem Zuweisungsoperator, weist man der Variablen einen Wert zu.<br><br>"+"Beachte: JavaScript unterscheidet zwischen Gro\xDF- und Kleinschreibung. <code>stadt</code> und <code>Stadt</code> sind "+"zwei verschiedene Variablen. Man sagt auch: JavaScript ist case sensitive.",task:"Deklariere eine Variable <code>vorname</code> und initialisiere sie mit dem Wert <code>\"Franz\"</code>.",beforeTests:function(){if(typeof vorname!=="undefined"){vorname=undefined}},tests:[function(){var ok=typeof vorname!=="undefined";var msg;if(ok){msg="<code>vorname</code> hat einen Wert."}else{msg="<code>vorname</code> hat keinen Wert."}return{ok:ok,msg:msg}},function(){var ok=vorname==="Franz";var msg;if(ok){msg="<code>vorname</code> hat den Wert \"Franz\"."}else{msg="<code>vorname</code> hat nicht den Wert <code>\"Franz\"</code>, sondern den Wert <code>"+JSON.stringify(vorname)+"</code>."}return{ok:ok,msg:msg}}]});
jshero.koans.add({id:"var2",title:"Mehrere Variablen",lesson:"M\xF6chte man mehrere Variablen deklarieren und initialisieren, so kann man das in zwei Programmzeilen tun:"+"<pre><code>var stadt = \"Prag\";<br>var land = \"Tschechien\";</code></pre>"+"In jeder Zeile steht eine Anweisung. Jede Anweisung sollte mit einem Semikolon abgeschlossen werden.",task:"Deklariere eine Variable <code>blume</code> und weise ihr den Wert <code>\"Rose\"</code> zu. "+"Deklariere eine zweite Variable <code>tier</code> und weise ihr den Wert <code>\"K\xE4fer\"</code> zu.",beforeTests:function(){if(typeof blume!=="undefined"){blume=undefined}if(typeof tier!=="undefined"){tier=undefined}},tests:[function(){var ok=typeof blume!=="undefined";var msg;if(ok){msg="<code>blume</code> hat einen Wert."}else{msg="<code>blume</code> hat keinen Wert."}return{ok:ok,msg:msg}},function(){var ok=blume==="Rose";var msg;if(ok){msg="<code>blume</code> hat den Wert <code>\"Rose\"</code>."}else{msg="<code>blume</code> hat nicht den Wert <code>\"Rose\"</code>, sondern den Wert <code>"+JSON.stringify(blume)+"</code>."}return{ok:ok,msg:msg}},function(){var ok=typeof tier!=="undefined";var msg;if(ok){msg="<code>tier</code> hat einen Wert."}else{msg="<code>tier</code> hat keinen Wert."}return{ok:ok,msg:msg}},function(){var ok=tier==="K\xE4fer";var msg;if(ok){msg="<code>tier</code> hat den Wert <code>\"K\xE4fer\"</code>."}else{msg="<code>tier</code> hat nicht den Wert <code>\"K\xE4fer\"</code>, sondern den Wert <code>"+JSON.stringify(tier)+"</code>."}return{ok:ok,msg:msg}}]});
(function(){jshero.koans.add({id:'while',title:'while-Schleife',lesson:'Die <code>while</code>-Schleife besitzt nur eine Schleifen-Bedingung. Der Schleifen-Code wird ausgef\xFChrt, solange die Bedingung <code>true</code> ergibt. '+'Ergibt die Bedingung <code>false</code>, wird die Schleife beendet und die Codeausf\xFChrung wird nach der Schleife fortgesetzt.'+'<pre><code>var space = "";<br>'+'while (space.length < 3) {<br>'+'  space = space + "x";<br>'+'}</code></pre>'+'Solange <code>space</code> weniger als 3 Zeichen besitzt, wird es um <code>"x"</code> erg\xE4nzt. '+'Hat <code>space</code> die L\xE4nge 3, wird die Schleife beendet. <code>space</code> hat dann den Wert <code>"xxx"</code>.',task:'Schreibe eine Funktion <code>abstand</code>, die eine nat\xFCrliche Zahl n als Parameter entgegennimmt und die einen String bestehend aus '+'n Leerzeichen zur\xFCckgibt. <code>abstand(1)</code> sollte <code>" "</code> ergeben.',beforeTests:function(){if(typeof abstand!=='undefined'){abstand=undefined}},tests:[function(){var ok=typeof abstand==='function';var msg;if(ok){msg='<code>abstand</code> ist eine Funktion.'}else{msg='<code>abstand</code> ist keine Funktion.'}return{ok:ok,msg:msg}},function(){var ok=abstand.length===1;var msg;if(ok){msg='<code>abstand</code> hat 1 Parameter.'}else{msg='<code>abstand</code> hat nicht 1, sondern '+abstand.length+' Parameter.'}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=abstand(0);ok=result==='';if(ok){msg='<code>abstand(0)</code> gibt <code>""</code> zur\xFCck.'}else{msg='<code>abstand(0)</code> gibt nicht <code>""</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>abstand(0)</code>.';e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=abstand(2);ok=result==='  ';if(ok){msg='<code>abstand(2)</code> gibt <code>"&nbsp;&nbsp;"</code> zur\xFCck.'}else{msg='<code>abstand(2)</code> gibt nicht <code>"&nbsp;&nbsp;"</code>, sondern <code>'+JSON.stringify(result)+'</code> zur\xFCck.'}}catch(exc){ok=false;msg='Fehler beim Aufruf von <code>abstand(2)</code>.';e=exc}return{ok:ok,msg:msg,e:e}}]})})();
jshero.koans.add({id:"xor",title:"XOR",lesson:"In der letzten Aufgabe hast du ein sogenanntes NAND-Gatter (engl.: Not AND - nicht und) programmiert. "+"NAND-Gatter sind in der Digitaltechnik ein sogenannter Standardbaustein. Mit ihm lassen sich alle logischen Verkn\xFCpfungen zusammenstellen. "+"Hier sollst du ein weiteres wichtiges Gatter, das XOR-Gatter (engl.: eXclusive OR - exklusives Oder), kennen lernen.",task:"Schreibe eine Funktion <code>xor</code>, die zwei boolesche Werte als Parameter entgegennimmt. Die R\xFCckgabe der Funktion soll <code>true</code> sein, "+"wenn beide Paramter verschieden sind. In den anderen F\xE4llen soll die R\xFCckgabe <code>false</code> sein. <code>xor(true, false)</code> und "+"<code>xor(false, true)</code> sollen <code>true</code> liefern, <code>xor(true, true)</code> und <code>xor(false, false)</code> sollen <code>false</code> zur\xFCckgeben.",beforeTests:function(){if(typeof nand!=="undefined"){nand=undefined}},tests:[function(){var ok=typeof xor==="function";var msg;if(ok){msg="<code>xor</code> ist eine Funktion."}else{msg="<code>xor</code> ist keine Funktion."}return{ok:ok,msg:msg}},function(){var ok=xor.length===2;var msg;if(ok){msg="<code>xor</code> hat zwei Parameter."}else{msg="<code>xor</code> hat nicht 2, sondern "+xor.length+" Parameter."}return{ok:ok,msg:msg}},function(){var ok,msg,e;try{var result=xor(true,true);ok=result===false;if(ok){msg="<code>xor(true, true)</code> ergibt <code>false</code>."}else{msg="<code>xor(true, true)</code> ergibt nicht <code>false</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>xor(true, true)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=xor(false,false);ok=result===false;if(ok){msg="<code>xor(false, false)</code> ergibt <code>false</code>."}else{msg="<code>xor(false, false)</code> ergibt nicht <code>false</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>xor(false, false)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=xor(true,false);ok=result===true;if(ok){msg="<code>xor(true, false)</code> ergibt <code>true</code>."}else{msg="<code>xor(true, false)</code> ergibt nicht <code>true</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>xor(true, false)</code>.";e=exc}return{ok:ok,msg:msg,e:e}},function(){var ok,msg,e;try{var result=xor(false,true);ok=result===true;if(ok){msg="<code>xor(false, true)</code> ergibt <code>true</code>."}else{msg="<code>xor(false, true)</code> ergibt nicht <code>true</code>, sondern <code>"+JSON.stringify(result)+"</code>."}}catch(exc){ok=false;msg="Fehler beim Aufruf von <code>xor(false, true)</code>.";e=exc}return{ok:ok,msg:msg,e:e}}]});
/* This puts the koans in the desired order */jshero.koans.initReorder(['var','var2','function','function2','functioncall','parameter','parameter2','string','log','stringlength','stringupper','stringcharat','trim','stringindexof','stringindexof2','stringsubstr','replace','number','modulo','mean','math','pi','round','random','parseint','numbertostring','bool','xor','equals','equals2','even','notequals','greaterthan','if','else','elseif','array','array2','array3','arraylength','arraysort','arraypush','for','for2','while','dowhile','ggt','break','bubblesort','arguments','comment','undefined','nan','stringsplit','date','date2','date3','subfunction','further']);

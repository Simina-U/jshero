(function(testutil){jshero.koans.add({id:"for1",title:"for-Schleife",lesson:"Mit Schleifen k\xF6nnen Code-Abschnitte mehrmals durchlaufen werden. JavaScript kennt mehrere Schleifenarten.\nDie einfachste ist die <code>for</code>-Schleife.\n\n<pre><code>let summe = 0;\nfor (let i = 1; i < 3; i++) {\n  summe = summe + i;\n}</code></pre>\n\nDie <code>for</code>-Schleife besteht aus drei Steuer-Anweisungen und dem Schleifen-Code. Die drei Anweisungen folgen dem <code>for</code> in runden Klammern.\nSie werden durch Semikolons voneinander getrennt. Die erste Anweisung ist die Start-Anweisung. Sie wird einmal zu Beginn der Schleife ausgef\xFChrt.\nHier wird normalerweise eine Variable, die sogenannte Schleifenvariable, initialisiert. Die zweite Anweisung ist die Schleifen-Bedingung.\nSie wird vor jedem Schleifendurchlauf zu <code>true</code> oder <code>false</code> ausgewertet.\nIst der Ausdruck <code>true</code>, wird der Schleifen-Code ausgef\xFChrt.\nIst er <code>false</code>, wird die Schleife beendet und die Programmausf\xFChrung wird nach der Schleife fortgesetzt.\nNach jedem Schleifen-Durchlauf wird die dritte Anweisung, die sogenannten End-Anweisung, ausgef\xFChrt.\nHier wird normalerweise die Schleifenvariable erh\xF6ht.\nAnschlie\xDFend beginnt ein neuer Schleifendurchlauf mit erneuter Auswertung der Schleifen-Bedingung.\nDer Schleifen-Code folgt in Mengenklammern den drei Steueranweisungen.\nIn unserem Beispiel hat <code>summe</code> zun\xE4chst den Wert <code>0</code>. In der Start-Anweisung wird <code>i</code> mit <code>1</code> initialisiert.\nDie Schleifenbedingung <code>1 < 3</code> ist erf\xFCllt, also wird der Schleifen-Code ausgef\xFChrt.\n<code>summe</code> erh\xE4lt den Wert <code>0 + 1</code>, also <code>1</code>.\nNun wird in der End-Anweisung <code>i</code> um <code>1</code> erh\xF6ht (<code>i++</code> ist identisch mit <code>i = i + 1</code>).\nEs erh\xE4lt also den Wert <code>2</code>. Der zweite Schleifendurchlauf startet mit Auswertung der Schleifenbedingung.\nDiese Bedingung (<code>2 < 3</code>) ist immer noch erf\xFCllt.\nDer Schleifen-Code wird erneut ausgef\xFChrt und <code>summe</code> erh\xE4lt jetzt den Wert <code>1 + 2</code>, also <code>3</code>.\n<code>i</code> wird abermals erh\xF6ht und hat nun den Wert <code>3</code>.\nDie Schleifenbedingung <code>3 < 3</code> ist jetzt nicht mehr erf\xFCllt. Die Schleife wird beendet und die Programmausf\xFChrung wird nach der Schleife fortgesetzt.\nUnser Codebeispiel hat also alle nat\xFCrlichen Zahlen echt kleiner 3 addiert.",task:"Schreibe eine Funktion <code>addiereBis</code>, die eine Zahl als Parameter entgegennimmt und die\nalle nat\xFCrlichen Zahlen kleiner gleich dem Paramter aufaddiert. Das Ergebnis der Addition soll zur\xFCckgegeben werden.\n<code>addiereBis(3)</code> sollte <code>1+2+3</code> = <code>6</code> ergeben.",hint:"<pre><code>let addiereBis = function(n) {\n  let summe = 0;\n  for (let i = 0; i <= n; i++) {\n    ...\n  }\n  return summe;\n};</pre></code>",solution:"<pre><code>let addiereBis = function(n) {\n  let summe = 0;\n  for (let i = 0; i <= n; i++) {\n    summe = summe + i;\n  }\n  return summe;\n};</pre></code>",tests:[function(){return testutil.assert_isFunction("addiereBis")},function(){return testutil.assert_functionHasNumOfParameter("addiereBis",1)},function(){return testutil.assert_functionReturns("addiereBis(0)",0)},function(){return testutil.assert_functionReturns("addiereBis(1)",1)},function(){return testutil.assert_functionReturns("addiereBis(2)",3)},function(){return testutil.assert_functionReturns("addiereBis(3)",6)},function(){return testutil.assert_functionReturns("addiereBis(9)",45)}]})})(jshero.testutil);
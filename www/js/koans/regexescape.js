jshero.koans.add({id:"regexescape",title:"Regex: Escape",lesson:"Wie wir gesehen haben, besitzen regul\xE4re Ausdr\xFCcke eine Reihe von Zeichen mit besonderer Bedeutung.\nSo steht <code>.</code> nicht f\xFCr einen Punkt, sondern f\xFCr ein beliebiges Zeichen.\nM\xF6chte man nach einen Punkt suchen, so muss man die besondere Bedeutung gewisserma\xDFen\nausschalten. Das macht man mit einen vorangestellten Backslash: \n\n<pre><code>var t1 = /\\./.test('Z. B.');\nvar t2 = /\\./.test('ZB');</code></pre>\n\nDer erste Ausdruck ergibt <code>true</code>, der zweite <code>false</code>.\nOhne den Backslash w\xFCrden beide Ausdr\xFCcke <code>true</code> ergeben.\nEin solches 'Ausschalten' nennt man maskieren oder escapen.\n\nM\xF6chte man nach dem Backslash suchen, so muss man diesen ebenfalls maskieren:\n\n<pre><code>var t = /\\\\/.test('A \\ B');\n// t ist true</code></pre>\n\nInsgesamt gibt es 15 Zeichen, die man maskieren muss, wenn man nach ihnen suchen m\xF6chte:\n<code>* + ? . ( ) [ ] { } \\ / | ^ $</code>",task:"Schreibe eine Funktion <code>pruefe</code>, die feststellt, ob ein String den Teilstring\n<code>'(x)'</code> enh\xE4lt. <code>pruefe('f(x)')</code> sollte <code>true</code> und\n<code>pruefe('f(n)')</code> sollte <code>false</code> ergeben.",tests:[function(){return jshero.testutil.assert_isFunction("pruefe")},function(){return jshero.testutil.assert_functionHasNumOfParameter("pruefe",1)},function(){return jshero.testutil.assert_functionReturns("pruefe('f(x)')",true)},function(){return jshero.testutil.assert_functionReturns("pruefe('g(x)')",true)},function(){return jshero.testutil.assert_functionReturns("pruefe('x')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('f(n)')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('f()')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('(x')",false)},function(){return jshero.testutil.assert_functionReturns("pruefe('x)')",false)}]});